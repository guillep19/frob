imports
{
module AttributeGrammar where
}
type Decls = [Decl]
type Dodecls = [Dodecl]


data Expr
  | Var
    name :: {String}
  | Const
    name :: {String}
  | Int
    value :: {Int}
  | If
    cond :: Expr
    then :: Expr
    else :: Expr
  | BinExpr
    op :: {String}
    left :: Expr
    right :: Expr

data Dodecl
  | Read
      name :: {String}
      input :: Expr
  | Output
      output :: Expr
      name :: {String}
  | Lift
      name :: {String}
      function :: {String}
      source :: {String}
  | Lift2
      name :: {String}
      function :: {String}
      source_1 :: {String}
      source_2 :: {String}
  | Folds
      name :: {String}
      function :: {String}
      value :: Expr
      source :: {String}

data Decl
  | Function
      name :: {String}
      args :: {[String]}
      body :: Expr
  | Const
      name :: {String}
      value :: Expr

data Root
  | Root
      decls :: Decls
      dodecls :: Dodecls

deriving * : Show
wrapper Root

-- Shortcut for semantic rules
set All = Root Decls Decl Dodecls Dodecl Expr
-- Code generation

attr All syn code use {++} {[]}:: String
         syn len use {+} {0} :: Int
         inh pos :: Int

sem Root
  | Root
      lhs.code = @dodecls.code ++ @decls.code
      dodecls.pos = 0
      decls.pos = @dodecls.len

sem Decl
  | Function
      lhs.code = ("[" ++ @name ++ "]\n" ++
                 @body.code ++
                 show(@lhs.pos + @body.len) ++
                 ": t_ret\n")
      lhs.len = @body.len + 1
  | Const
      lhs.code = @value.code ++ 
                 show(@lhs.pos + @value.len) ++
                 ": t_store " ++ @name ++ "\n"
      lhs.len = 0

sem Dodecl
  | Read
      lhs.code = @input.code ++
                 show(@lhs.pos + @input.len) ++
                 ": t_read " ++ @name ++ "\n"
      lhs.len = @input.len + 1
  | Output
      lhs.code = @output.code ++
                 show(@lhs.pos + @output.len) ++
                 ": t_write " ++ @name ++ "\n"
      lhs.len = @output.len + 1
  | Lift
      lhs.code = (show(@lhs.pos) ++
                  ": t_lift " ++ @name ++
                  " " ++ @source ++
                  " " ++ @function ++ "\n")
      lhs.len = 3
  | Lift2
      lhs.code = (show(@lhs.pos) ++
                  ": t_lift2 " ++ @name ++
                  " " ++ @source_1 ++
                  " " ++ @source_2 ++
                  " " ++ @function ++ "\n")
      lhs.len = 4
  | Folds
      lhs.code = (@value.code ++
                  show(@lhs.pos + @value.len) ++
                  ": t_folds " ++ @name ++ "\n    " ++
                  " " ++ @source  ++ "\n    " ++
                  " " ++ @function ++ "\n")
      lhs.len = @value.len + 3


sem Expr
  | Var
      lhs.code = show(@lhs.pos) ++ ": t_load_param " ++ @name ++ "\n"
      lhs.len = 1
  | Const
      lhs.code = show(@lhs.pos) ++ ": t_load " ++ @name ++ "\n"
      lhs.len = 1
  | Int
      lhs.code = show(@lhs.pos) ++ ": t_push " ++ "\n    " ++ show(@value) ++ "\n"
      lhs.len = 2
  | If
      lhs.code = (@cond.code ++
                  show(@lhs.pos + @cond.len) ++ 
                  ": t_jump_false " ++ 
                  show(@lhs.pos + @cond.len + 1 + @then.len + 1) ++
                  "\n" ++
                  @then.code ++
                  show(@lhs.pos + @cond.len + 1 + @then.len) ++ 
                  ": t_jump " ++ 
                  show(@lhs.pos + @cond.len + 1 +
                                  @then.len + 1 + @else.len) ++
                  "\n" ++
                  "[else]\n" ++
                  @else.code ++
                  "[end_if]\n")
      lhs.len = @cond.len + 1 + @then.len + 1 + @else.len
      cond.pos = @lhs.pos
      then.pos = @lhs.pos + @cond.len + 1
      else.pos = @lhs.pos + @cond.len + @then.len + 2
  | BinExpr
      lhs.code = (@left.code ++
                  @right.code ++
                  show(@lhs.pos + @left.len + @right.len) ++ ": t_" ++ @op ++
                  "\n")
      lhs.len = @left.len + @right.len + 1
      left.pos = @lhs.pos
      right.pos = @lhs.pos + @left.len

sem Decls
  | Cons
      tl.pos = @lhs.pos + @hd.len

sem Dodecls
  | Cons
      tl.pos = @lhs.pos + @hd.len

-------------------------------------------
-- Interface to the haskell world:
--   inh  = Inh_Root { }
--   syn  = wrap_Root sem inh
--   code = code_Syn_Root syn
