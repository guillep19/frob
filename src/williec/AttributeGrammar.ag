imports
{
module AttributeGrammar where
}
type Decls = [Decl]
type Dodecls = [Dodecl]


data Expr
  | Var
    name :: {String}
  | Const
    name :: {String}
  | Int
    value :: {Int}
  | If
    cond :: {Expr}
    then :: {Expr}
    else :: {Expr}
  | BinExpr
    op :: {String}
    left :: Expr
    right :: Expr
  | Add
    left :: Expr
    right :: Expr
  | Sub
    left :: Expr
    right :: Expr
  | Times
    left :: Expr
    right :: Expr
  | Div
    left :: Expr
    right :: Expr
  | Cmp
    left :: Expr
    right :: Expr
  | BinBool
    left :: Expr
    right :: Expr

data Dodecl
  | Read
      name :: {String}
      input :: Expr
  | Output
      output :: Expr
      name :: {String}
  | Lift
      name :: {String}
      function :: {String}
      source :: {String}
  | Lift2
      name :: {String}
      function :: {String}
      source_1 :: {String}
      source_2 :: {String}
  | Folds
      name :: {String}
      function :: {String}
      value :: Expr
      source :: {String}

data Decl
  | Function
      name :: {String}
      args :: {[String]}
      body :: Expr
  | Const
      name :: {String}
      value :: Expr

data Root
  | Root
      decls :: Decls
      dodecls :: Dodecls

deriving * : Show
wrapper Root

-- Code generation
attr Root Decls Decl Dodecls Dodecl Expr syn code :: String

sem Decl
  | Function
      lhs.code = "[" ++ @name ++ "]:\n " ++ @body.code ++ "\nret\n"
  | Const
      lhs.code = "const: " ++ @name ++ "value: " ++ @value.code ++ "\n"

sem Decls
  | Cons
      lhs.code =  @hd.code ++ @tl.code
  | Nil
      lhs.code =  ""

sem Dodecls
  | Cons
      lhs.code = @hd.code ++ @tl.code
  | Nil
      lhs.code = ""

sem Dodecl
  | Read
      lhs.code = "read " ++ @name ++ "input: TODO\n"
  | Output
      lhs.code = "output "
  | Lift
      lhs.code = "lift "
  | Lift2
      lhs.code = "lift2 "
  | Folds
      lhs.code = "folds "


sem Expr
  | Var
      lhs.code = "load " ++ @name ++ "\n"
  | Const
      lhs.code = "push const " ++ @name ++ "\n"
  | Int
      lhs.code = "integer value\n"
  | If
      lhs.code = "if ....\n"
  | BinExpr
      lhs.code = "bin expr \n"

sem Root
  | Root
      lhs.code = @decls.code ++ @dodecls.code

-------------------------------------------
-- Interface to the haskell world:
--   inh  = Inh_Root { }
--   syn  = wrap_Root sem inh
--   code = code_Syn_Root syn
