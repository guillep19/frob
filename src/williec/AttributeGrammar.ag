imports
{
module AttributeGrammar where
}
type Decls = [Decl]
type Dodecls = [Dodecl]


data Expr
  | Var
    name :: {String}
  | Const
    name :: {String}
  | Int
    value :: {Int}
  | If
    cond :: Expr
    then :: Expr
    else :: Expr
  | BinExpr
    op :: {String}
    left :: Expr
    right :: Expr

data Dodecl
  | Read
      name :: {String}
      input :: Expr
  | Output
      output :: Expr
      name :: {String}
  | Lift
      name :: {String}
      function :: {String}
      source :: {String}
  | Lift2
      name :: {String}
      function :: {String}
      source_1 :: {String}
      source_2 :: {String}
  | Folds
      name :: {String}
      function :: {String}
      value :: Expr
      source :: {String}

data Decl
  | Function
      name :: {String}
      args :: {[String]}
      body :: Expr
  | Const
      name :: {String}
      value :: Expr

data Root
  | Root
      decls :: Decls
      dodecls :: Dodecls

deriving * : Show
wrapper Root

-- Shortcut for semantic rules
set All = Root Decls Decl Dodecls Dodecl Expr
-- Code generation



attr All syn code :: String
         syn len :: Int

sem Root
  | Root
      lhs.code = @decls.code ++ @dodecls.code
      lhs.len = @decls.len + @dodecls.len

sem Decl
  | Function
      lhs.code = ("[" ++ @name ++ "]\n" ++
                 @body.code ++
                 "t_ret\n")
      lhs.len = @body.len + 1
  | Const
      lhs.code = @value.code ++ 
                 "t_store " ++ @name ++ "\n"
      lhs.len = 0

sem Decls
  | Cons
      lhs.code =  @hd.code ++ @tl.code
      lhs.len = @hd.len + @tl.len
  | Nil
      lhs.code =  ""
      lhs.len = 0

sem Dodecls
  | Cons
      lhs.code = @hd.code ++ @tl.code
      lhs.len = @hd.len + @tl.len
  | Nil
      lhs.code = ""
      lhs.len = 0

sem Dodecl
  | Read
      lhs.code = @input.code ++ "read " ++ @name ++ "\n"
      lhs.len = @input.len + 1
  | Output
      lhs.code = @output.code ++ "t_write " ++ @name ++ "\n"
      lhs.len = @output.len + 1
  | Lift
      lhs.code = ("t_lift " ++ @name ++
                  " " ++ @source ++
                  " " ++ @function ++ "\n")
      lhs.len = 3
  | Lift2
      lhs.code = ("t_lift2 " ++ @name ++
                  " " ++ @source_1 ++
                  " " ++ @source_2 ++
                  " " ++ @function ++ "\n")
      lhs.len = 4
  | Folds
      lhs.code = (@value.code ++
                  "t_folds " ++ @name ++
                  " " ++ @source  ++
                  " " ++ @function ++ "\n")
      lhs.len = @value.len + 3


sem Expr
  | Var
      lhs.code = "t_load_param " ++ @name ++ "\n"
      lhs.len = 1
  | Const
      lhs.code = "t_load " ++ @name ++ "\n"
      lhs.len = 1
  | Int
      lhs.code = "t_push " ++ show(@value) ++ "\n"
      lhs.len = 2
  | If
      lhs.code = (@cond.code ++
                  "t_jump_false _else_\n" ++
                  @then.code ++
                  "t_jump end_if\n" ++
                  "[else]\n" ++
                  @else.code ++
                  "[end_if]\n")
      lhs.len = 1 -- @cond.len + 1 + @then.len + 1 + @else.len
  | BinExpr
      lhs.code = (@left.code ++
                  @right.code ++
                  "t_" ++ @op ++ "\n")
      lhs.len = @left.len + @right.len + 1


-------------------------------------------
-- Interface to the haskell world:
--   inh  = Inh_Root { }
--   syn  = wrap_Root sem inh
--   code = code_Syn_Root syn
