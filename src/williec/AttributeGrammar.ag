imports
{
module AttributeGrammar where
import Env
}
type Decls = [Decl]
type Dodecls = [Dodecl]


data Expr
  | Var
    name :: {String}
  | Const
    name :: {String}
  | Int
    value :: {Int}
  | If
    cond :: Expr
    then :: Expr
    else :: Expr
  | BinExpr
    op :: {String}
    left :: Expr
    right :: Expr

data Dodecl
  | Read
      name :: {String}
      input :: Expr
  | Output
      output :: Expr
      name :: {String}
  | Lift
      name :: {String}
      function :: {String}
      source :: {String}
  | Lift2
      name :: {String}
      function :: {String}
      source_1 :: {String}
      source_2 :: {String}
  | Folds
      name :: {String}
      function :: {String}
      value :: Expr
      source :: {String}

data Decl
  | Function
      name :: {String}
      args :: {[String]}
      body :: Expr
  | Const
      name :: {String}
      value :: Expr

data Root
  | Root
      decls :: Decls
      dodecls :: Dodecls

deriving * : Show
wrapper Root

-- Shortcut for semantic rules
set All = Root Decls Decl Dodecls Dodecl Expr
-- Code generation

attr All syn code use {++} {[]}:: String
         syn len use {+} {0} :: Int
         inh pos :: Int
         chn env :: Env
         inh envInh :: Env
         chn labels :: LabelMap
         inh labelMap :: LabelMap

sem Root
  | Root
      lhs.code = @dodecls.code ++ 
                 show(@dodecls.len) ++
                 ": t_halt\n" ++
                 @decls.code
      dodecls.pos = 0
      decls.pos = @dodecls.len
      decls.labels = emptyLabelMap
      decls.labelMap = @decls.labels
      dodecls.labelMap = @decls.labels
      decls.env = emptyEnv
      dodecls.env = emptyEnv
      dodecls.envInh = @dodecls.env

sem Decl
  | Function
      lhs.code = ("[" ++ @name ++ "]\n" ++
                 @body.code ++
                 show(@lhs.pos + @body.len) ++
                 ": t_ret\n")
      lhs.len = @body.len + 1
      lhs.labels = addLabel @name @lhs.pos @lhs.labels
      body.env = addScope @args @lhs.env
  | Const
      lhs.code = ("[" ++ @name ++ "]\n" ++
                  @value.code ++
                  show(@lhs.pos + @value.len) ++
                  ": t_ret\n")
      lhs.len = @value.len + 1
      lhs.labels = addLabel @name @lhs.pos @lhs.labels

sem Dodecl
  | Read
      lhs.env = addFrpId @name @lhs.env
      lhs.code = @input.code ++
                 show(@lhs.pos + @input.len) ++
                 ": t_read " ++
                 show(findFrpId @name @lhs.envInh) ++
                 " // " ++ @name ++ "\n"
      lhs.len = @input.len + 1
  | Output
      lhs.code = @output.code ++
                 show(@lhs.pos + @output.len) ++
                 ": t_write " ++
                 show(findFrpId @name @lhs.envInh) ++
                 " // " ++ @name ++ "\n"
      lhs.len = @output.len + 1
  | Lift
      lhs.code = (show(@lhs.pos) ++
                  ": t_lift " ++ show(findFrpId @name @lhs.envInh) ++
                  " // " ++ @name ++ "\n" ++
                  "    " ++ show(findFrpId @source @lhs.envInh) ++
                  " // " ++ @source ++ "\n" ++
                  "    " ++ show(getLabel @function @lhs.labels) ++
                  " // " ++ @function ++
                  "\n")
      lhs.len = 3
      lhs.env = addFrpId @name @lhs.env
  | Lift2
      lhs.code = (show(@lhs.pos) ++
                  ": t_lift2 " ++ show(findFrpId @name @lhs.envInh) ++
                  " // " ++ @name ++ "\n" ++
                  "    " ++ show(findFrpId @source_1 @lhs.envInh) ++
                  " // " ++ @source_1 ++ "\n" ++
                  "    " ++ show(findFrpId @source_2 @lhs.envInh) ++
                  " // " ++ @source_2 ++ "\n" ++
                  "    " ++ show(getLabel @function @lhs.labels) ++
                  " // " ++ @function ++
                  "\n")
      lhs.len = 4
      lhs.env = addFrpId @name @lhs.env
  | Folds
      lhs.code = (@value.code ++
                  show(@lhs.pos + @value.len) ++
                  ": t_folds " ++ show(findFrpId @name @lhs.envInh) ++
                  " // " ++ @name ++ "\n" ++
                  "    " ++ show(findFrpId @source @lhs.envInh) ++
                  " // " ++ @source  ++ "\n" ++
                  "    " ++ show(getLabel @function @lhs.labels) ++
                  " // " ++ @function ++
                  "\n")
      lhs.len = @value.len + 3
      lhs.env = addFrpId @name @lhs.env


sem Expr
  | Var
      lhs.code = show(@lhs.pos) ++
                 ": t_load_param " ++ show(getScopeVar @name @lhs.env) ++
                 " // " ++ @name ++ "\n"
      lhs.len = 1
  | Const
      lhs.code = show(@lhs.pos) ++
                 ": t_call " ++ show(getLabel @name @lhs.labels) ++
                 " //" ++ @name ++ "\n"
      lhs.len = 1
  | Int
      lhs.code = show(@lhs.pos) ++ ": t_push " ++ "\n    " ++ show(@value) ++ "\n"
      lhs.len = 2
  | If
      lhs.code = (@cond.code ++
                  show(@lhs.pos + @cond.len) ++ 
                  ": t_jump_false\n    " ++ 
                  show(@lhs.pos + @cond.len + 2 + @then.len + 2) ++
                  "\n" ++
                  @then.code ++
                  show(@lhs.pos + @cond.len + 2 + @then.len) ++ 
                  ": t_jump\n    " ++ 
                  show(@lhs.pos + @cond.len + 2 +
                                  @then.len + 2 + @else.len) ++
                  "\n" ++
                  "[else]\n" ++
                  @else.code ++
                  "[end_if]\n")
      lhs.len = @cond.len + 2 + @then.len + 2 + @else.len
      cond.pos = @lhs.pos
      then.pos = @lhs.pos + @cond.len + 2
      else.pos = @lhs.pos + @cond.len + @then.len + 4
  | BinExpr
      lhs.code = (@left.code ++
                  @right.code ++
                  show(@lhs.pos + @left.len + @right.len) ++ ": " ++ 
                  binopToInstr(@op) ++
                  "\n")
      lhs.len = @left.len + @right.len + 1
      left.pos = @lhs.pos
      right.pos = @lhs.pos + @left.len

sem Decls
  | Cons
      tl.pos = @lhs.pos + @hd.len

sem Dodecls
  | Cons
      tl.pos = @lhs.pos + @hd.len

-------------------------------------------
-- Interface to the haskell world:
--   inh  = Inh_Root { }
--   syn  = wrap_Root sem inh
--   code = code_Syn_Root syn

{
binopToInstr :: String -> String
binopToInstr "+" = "t_add"
binopToInstr "-" = "t_sub"
binopToInstr "*" = "t_mul"
binopToInstr "/" = "t_div"
binopToInstr ">" = "t_cmp_gt"
binopToInstr "<" = "t_cmp_lt"
binopToInstr ">=" = "t_cmp_gte"
binopToInstr "<=" = "t_cmp_lte"
binopToInstr "==" = "t_cmp_eq"
binopToInstr "/=" = "t_cmp_neq"
binopToInstr "and" = "t_op_and"
binopToInstr "or" = "t_op_or"

unaryOpInstr :: String -> String
unaryOpInstr "not" = "t_op_not"
}
