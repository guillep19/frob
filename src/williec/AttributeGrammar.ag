imports
{
module AttributeGrammar where
}
type Decls = [Decl]
type Dodecls = [Dodecl]

data Expr
  | Var
    name :: {String}
  | Const
    name :: {String}
  | Int
    value :: {Int}
  | Add
    left :: Expr
    right :: Expr
  | Sub
    left :: Expr
    right :: Expr
  | Times
    left :: Expr
    right :: Expr
  | Div
    left :: Expr
    right :: Expr

data Dodecl
  | Read
      name :: {String}
      input :: Expr
  | Output
      output :: Expr
      name :: {String}

data Decl
  | Function
      name :: {String}
      args :: {[String]}
      body :: Expr
  | Const
      name :: {String}
      value :: Expr

data Root
  | Root
      decls :: Decls
      dodecls :: Dodecls

deriving * : Show
wrapper Root

-- Code generation
attr Root Decls Decl Dodecls Dodecl Expr syn code :: String

sem Decl
  | Function
      lhs.code = "[" ++ @name ++ "]:\n " ++ @body.code ++ "\nret\n"
  | Const
      lhs.code = "const: " ++ @name ++ "value: " ++ @value.code ++ "\n"

sem Decls
  | Cons
      lhs.code =  @hd.code ++ @tl.code
  | Nil
      lhs.code =  ""

sem Dodecls
  | Cons
      lhs.code = @hd.code ++ @tl.code
  | Nil
      lhs.code = ""

sem Dodecl
  | Read
      lhs.code = "read " ++ @name ++ "input: TODO\n"

sem Expr
  | Var
      lhs.code = "load " ++ @name ++ "\n"
  | Const
      lhs.code = "push const " ++ @name ++ "\n"
  | Int
      lhs.code = "integer value"

sem Root
  | Root
      lhs.code = @decls.code ++ @dodecls.code
-------------------------------------------
-- Interface to the haskell world:
--   inh  = Inh_Root { }
--   syn  = wrap_Root sem inh
--   code = code_Syn_Root syn
