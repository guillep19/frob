-- | Full solution, with disp, with code, with pretty printed output

-- Haskell syntax AG

imports
{
module Main(main) where

import UU.Parsing
import Tokens
}


----------------------------------------------
-- Concrete syntax
----------------------------------------------

{

-- Parser with starting nonterminal Root
-- Semantic functions generated by UUAG
pRoot :: Parser Token Root
pRoot
  = Root_Root <$> pStat

pStats :: Parser Token Stats
pStats
  = pListSep pSemi pStat

pStat :: Parser Token Stat
pStat
  =   Stat_Use    <$ pKey "use"  <*> pVarid
  <|> Stat_Decl   <$ pKey "decl" <*> pVarid
  <|> Stat_Block  <$ pKey "[" <*> pStats <* pKey "]"
}

----------------------------------------------
-- Utility datatypes
----------------------------------------------

{

-- environment
type Env   = [[String]]
initEnv    = [[]]

-- instruction
data Instr
  = Pushconst   Int     -- Const push
  | Goto Int            -- exit block, with level
  | Read Int            -- read the Input Int
  deriving Show

instance PP Instr where
  pp = pp . show

type Code  = [Instr]
} 

----------------------------------------------
-- Utilities
----------------------------------------------

{
enter :: Env -> Env
enter = ([]:)

add :: String -> Env -> Env
add n (h:t) = (h ++ [n]) : t

top :: Env -> [String]
top = head

level :: Env -> Int
level e = length e - 1

lkup :: String -> Env -> Maybe Ref
lkup _ []      = Nothing
lkup n e@(h:t) = maybe (lkup n t) (\i -> Just (level e, i)) (elemIndex n h)
}

----------------------------------------------
-- Abstract syntax
----------------------------------------------

data Root
  | Root
      prog  :: Stat

type Stats = [Stat]

data Stat
  | Decl
      name  :: {String}
  | Use
      name  :: {String}
  | Block
      stats :: Stats

-- Derive show instances when generating Haskell data types for these data declarations
deriving * : Show

-- Generates an interface to the haskell world:
--   inh  = Inh_Root { }
--   syn  = wrap_Root sem inh
--   code = html_Syn_Root syn
wrapper Root

-- give a name to a set of datatypes, for reference in semantic rules
set AllStat = Stats Stat

----------------------------------------------
-- Gathering of declarations
----------------------------------------------

attr AllStat chn decls :: Env

sem Stat
  | Decl
      lhs.decls     = add @name @lhs.decls
  | Block
      lhs.decls     = @lhs.decls

sem Root
  | Root
      prog.decls    = initEnv

----------------------------------------------
-- The actual env holding declared idents
----------------------------------------------

attr AllStat inh env :: Env

sem Root
  | Root
      prog.env      = @prog.decls

----------------------------------------------
-- The mutual dependent def of decls and env
----------------------------------------------

sem Stat
  | Block
      stats.decls   = enter @lhs.env
           .env     = @stats.decls

----------------------------------------------
-- Errors
----------------------------------------------

attr AllStat Root syn errs use {++} {[]} :: Errs

sem Stat
  | Use
      (loc.ref,loc.errs)
                    = case lkup @name @lhs.env of
                        Nothing -> ((-1,-1),[@name ++ " not declared"])
                        Just r  -> (r,[])
  | Decl
      loc.errs      = case lkup @name @lhs.decls of
                        Just (l,_) | level @lhs.decls == l -> [@name ++ " already declared"]
                        _                                  -> []


----------------------------------------------
-- Code generation
----------------------------------------------

attr AllStat Root syn code use {++} {[]} :: Code

sem Stat
  | Use
      lhs.code      = [Ref @ref]
  | Block
      loc.level		= level @stats.decls
         .alloc     = length $ top @stats.decls
      lhs.code      = [Enter @level @alloc] ++ @stats.code ++ [Leave @level]

----------------------------------------------
-- Pretty printed source text
----------------------------------------------

attr Stat Root syn pp use {>-<} {empty} :: PP_Doc
attr Stats syn ppL use {++} {[]} :: {[PP_Doc]}

sem Stat
  | Use
      lhs.pp        = "use"  >#< @name >#< ppErrs @errs
  | Decl
      lhs.pp        = "decl" >#< @name >#< ppErrs @errs
  | Block
      lhs.pp        = pp_block "[ " "] " "; " @stats.ppL

sem Stats
  | Nil
      lhs.ppL       = []
  | Cons
      lhs.ppL       = @hd.pp : @tl.ppL


----------------------------------------------
-- Pipeline
----------------------------------------------


{
main :: IO ()
main
  = do args <- getArgs
       if (length args /= 2)
        then putStrLn "usage: frobcc <source> <dest>"
        else let [source,dest] = args
             in compile source dest

compile :: String -> String -> IO ()
compile source dest
  = do input  <- readFile source
       let toks = runScanner source input
       sem <- runParser toks
       let out  = semantics sem
       writeFile dest (pretty $ vlist $ code_Syn_Root out)

runScanner :: String -> String -> [Token]
runScanner filename
  = scanBlock (initPos filename)

scanBlock :: Pos -> String -> [Token]
scanBlock _ s = alexScanTokens s

runParser :: [Token] -> IO Root
runParser
  = parseIOMessage show pRoot

semantics :: Root -> Syn_Root
semantics r
  = wrap_Root (sem_Root r) (Inh_Root {})

