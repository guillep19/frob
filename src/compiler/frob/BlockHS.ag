-- | Full solution, with disp, with code, with pretty printed output

-- Haskell syntax AG

imports
{
module Main(main) where

import UU.Parsing
import UU.Scanner.Token
import UU.Scanner.TokenParser
import UU.Scanner.GenTokenOrd()
import UU.Scanner.GenTokenSymbol()
import UU.Scanner.TokenShow()
import UU.Scanner.Position
import Data.List
import UU.Pretty
import System.Environment
import System.IO
import Data.Char
import Data.List
}


----------------------------------------------
-- Concrete syntax
----------------------------------------------

{
-- Evil, ugly handcrafted scanner.
-- For Haskell-like languages, you can use UU.Scanner (or Alex)
scanBlock :: Pos -> String -> [Token]
scanBlock _ "" = []
scanBlock p ('u' : 's' : 'e' : r)
  = reserved "use" p : scanBlock (advc 3 p) r
scanBlock p ('d' : 'e' : 'c' : 'l' : r)
  = reserved "decl" p : scanBlock (advc 4 p) r
scanBlock p (c : r)
  | isSpace c      = scanBlock (adv p c) r
  | c `elem` "[];" = reserved [c] p : scanBlock (advc 1 p) r
  | isAlpha c      = valueToken TkVarid [c] p : scanBlock (advc 1 p) r
  | otherwise      = errToken ("Unexpected character " ++ show c) p : scanBlock (adv p c) r


-- Parser with starting nonterminal Root
-- Semantic functions generated by UUAG
pRoot :: Parser Token Root
pRoot
  = Root_Root <$> pStat

pStats :: Parser Token Stats
pStats
  = pListSep pSemi pStat

pStat :: Parser Token Stat
pStat
  =   Stat_Use    <$ pKey "use"  <*> pVarid
  <|> Stat_Decl   <$ pKey "decl" <*> pVarid
  <|> Stat_Block  <$ pKey "[" <*> pStats <* pKey "]"
}

----------------------------------------------
-- Utility datatypes
----------------------------------------------

{
-- 
type Level = Int
type Disp  = Int
type Ref   = (Level,Disp)

-- environment
type Env   = [[String]]
initEnv    = [[]]

-- instruction
data Instr
  = Enter   Int Int     -- ^ enter new block, with level and nr of idents allocated
  | Leave   Int         -- ^ exit block, with level
  | Ref     Ref         -- ^ refer to level+disp
  deriving Show

instance PP Instr where
  pp = pp . show

type Code  = [Instr]

type Err   = String
type Errs  = [Err]
} 

----------------------------------------------
-- Utilities
----------------------------------------------

{
ppErrs :: Errs -> PP_Doc
ppErrs = vlist . map ("--" >#<)
}

{
enter :: Env -> Env
enter = ([]:)

add :: String -> Env -> Env
add n (h:t) = (h ++ [n]) : t

top :: Env -> [String]
top = head

level :: Env -> Int
level e = length e - 1

lkup :: String -> Env -> Maybe Ref
lkup _ []      = Nothing
lkup n e@(h:t) = maybe (lkup n t) (\i -> Just (level e, i)) (elemIndex n h)
}

----------------------------------------------
-- Abstract syntax
----------------------------------------------

data Root
  | Root
      prog  :: Stat

type Stats = [Stat]

data Stat
  | Decl
      name  :: {String}
  | Use
      name  :: {String}
  | Block
      stats :: Stats

-- Derive show instances when generating Haskell data types for these data declarations
deriving * : Show

-- Generates an interface to the haskell world:
--   inh  = Inh_Root { }
--   syn  = wrap_Root sem inh
--   code = html_Syn_Root syn
wrapper Root

-- give a name to a set of datatypes, for reference in semantic rules
set AllStat = Stats Stat

----------------------------------------------
-- Gathering of declarations
----------------------------------------------

attr AllStat chn decls :: Env

sem Stat
  | Decl
      lhs.decls     = add @name @lhs.decls
  | Block
      lhs.decls     = @lhs.decls

sem Root
  | Root
      prog.decls    = initEnv

----------------------------------------------
-- The actual env holding declared idents
----------------------------------------------

attr AllStat inh env :: Env

sem Root
  | Root
      prog.env      = @prog.decls

----------------------------------------------
-- The mutual dependent def of decls and env
----------------------------------------------

sem Stat
  | Block
      stats.decls   = enter @lhs.env
           .env     = @stats.decls

----------------------------------------------
-- Errors
----------------------------------------------

attr AllStat Root syn errs use {++} {[]} :: Errs

sem Stat
  | Use
      (loc.ref,loc.errs)
                    = case lkup @name @lhs.env of
                        Nothing -> ((-1,-1),[@name ++ " not declared"])
                        Just r  -> (r,[])
  | Decl
      loc.errs      = case lkup @name @lhs.decls of
                        Just (l,_) | level @lhs.decls == l -> [@name ++ " already declared"]
                        _                                  -> []


----------------------------------------------
-- Code generation
----------------------------------------------

attr AllStat Root syn code use {++} {[]} :: Code

sem Stat
  | Use
      lhs.code      = [Ref @ref]
  | Block
      loc.level		= level @stats.decls
         .alloc     = length $ top @stats.decls
      lhs.code      = [Enter @level @alloc] ++ @stats.code ++ [Leave @level]

----------------------------------------------
-- Pretty printed source text
----------------------------------------------

attr Stat Root syn pp use {>-<} {empty} :: PP_Doc
attr Stats syn ppL use {++} {[]} :: {[PP_Doc]}

sem Stat
  | Use
      lhs.pp        = "use"  >#< @name >#< ppErrs @errs
  | Decl
      lhs.pp        = "decl" >#< @name >#< ppErrs @errs
  | Block
      lhs.pp        = pp_block "[ " "] " "; " @stats.ppL

sem Stats
  | Nil
      lhs.ppL       = []
  | Cons
      lhs.ppL       = @hd.pp : @tl.ppL


----------------------------------------------
-- Pipeline
----------------------------------------------


{
main :: IO ()
main
  = do args <- getArgs
       if (length args /= 2)
        then putStrLn "usage: block <source> <dest>"
        else let [source,dest] = args
             in compile source dest

compile :: String -> String -> IO ()
compile source dest
  = do input  <- readFile source
       let toks = runScanner source input
       sem <- runParser toks
       let out  = semantics sem
           errs = errs_Syn_Root out
       if null errs 
         then writeFile dest (pretty $ vlist $ code_Syn_Root out)
         else hPutStrLn stderr $ pretty $
                "Errors:" >-< indent 2 (ppErrs errs ) >-< "in:" >-< indent 2 (pp_Syn_Root out)
                

runScanner :: String -> String -> [Token]
runScanner filename
  = scanBlock (initPos filename)

runParser :: [Token] -> IO Root
runParser
  = parseIOMessage show pRoot

semantics :: Root -> Syn_Root
semantics r
  = wrap_Root (sem_Root r) (Inh_Root {})

pretty :: PP_Doc -> String
pretty doc
  = disp doc 30 ""
}

