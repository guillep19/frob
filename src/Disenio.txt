
Lenguaje.

 - Hacer dsl en Haskell

Haskell genera codigo de bajo nivel.

 - Codigo se interpreta en la VM.

Threads en la VM:

Cada Task se comporta como un thread.

El task puede estar en varios estados:
 - Bloqueado
 - Corriendo
 - Finalizado
 
Ejemplo de programa:
--------------------

Tipos basicos:
  Bool: True | False
  Int
  Float

Type Motor {
  >>: a -> mem(x)
}

Inputs:
  Color color-izquierdo
  Color color-derecho
  Distance distancia-casa
Outputs:
  Motor motor-izquierdo
  Motor motor-derecho


esBlanco: Color IO() -> bool
color -> (color < 0.2)

setVelocidad: motor x float -> motor
m, v -> (v >> m)

Type ColorSensor : Sensor {
  get: function() {
    //retorna el valor leido
  }
}

Function hayCasa (Distance d): Bool
  return (d.get_meters() < 10.0)

Tarea contarCasas() {
  property cuenta = 0;
  viendo = False;

  loop {
    if hayCasa(distance) {
      if not viendo {
        viendo = True;
        cuenta = cuenta + 1;
      }
    } else {
      viendo = False;
    }
    sleep(2)
  }
}

#La tarea termina cuando sus hijas terminen.
Tarea encontrarSegundaCasa {
  t: contarCasas()
  |= t.cuenta == 2 -> Finished(t)
  run(t)
}

Tarea seguirLinea {

}


Task ident args lcurly complex-block rcurly


Definicion formal:
------------------

Task = { ti : i \in N }
