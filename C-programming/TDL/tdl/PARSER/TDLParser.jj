/*
 * Notes:
 *
 *   Abbreviations:  CS => Case-Sensitive, CI => Case-Insensitive.
 *
 * Copyright (c) 2008, Carnegie Mellon University
 *     This software is distributed under the terms of the 
 *     Simplified BSD License (see tdl/LICENSE.TXT)
 *
 */

options {
  STATIC           = true; /* There is only *ONE* Parser Object. */
  USER_CHAR_STREAM = true; /* Use a custom character stream. */
}

PARSER_BEGIN(TDLParser)

import java.io.IOException;
import java.io.File;


public class TDLParser
{
	/* Class Constants */
  public final static String SPACE_STRING  = " ";
  public final static int    DEFAULT_STATE = TDLParserConstants.DEFAULT;
  public final static String PARENT_WARNING
		 = ":  Warning:  Use of \"PARENT\" keyword is deprecated."
		   + "  Assuming you meant to use \"THIS\".";
  public final static String SELF_WARNING
		 = ":  Warning:  Use of \"SELF\" keyword is deprecated."
		   + "  Assuming you meant to use \"CHILD\".";

  

	/* Class Variables */
  private   static DataSourceString    staticStringDataSource
				         = new DataSourceString ( "" );
  private   static DataSourceFile      staticFileDataSource
				         = new DataSourceFile ( );

  private   static TDLParser           staticTDLParser = null;

  protected static DataSource          lastDataSource = null;

  protected static DataTaskDefinition  currentDataTaskDefinition = null;


	/* Class variables for debugging... */
  protected static boolean             debugDistributedDeclarationSet = false;


	/* TDLParser routines / interface */
  public static TDLParser getParser()
  {
    if ( TDLParser . staticTDLParser == null )
      TDLParser . staticTDLParser = new TDLParser ( staticStringDataSource );
    return staticTDLParser;
  }

  public static DataSource getLastDataSource()  { return lastDataSource; }

  public static void reinitParser ( String theSourceString )
  {
    TDLParser . staticStringDataSource . setString ( theSourceString );
    TDLParser . reinitParser ( TDLParser . staticStringDataSource );
  }

  public static void reinitParser ( File  theFile )
  {
    TDLParser . staticFileDataSource . setFile ( theFile );
    TDLParser . reinitParser ( TDLParser . staticFileDataSource );
  }

  public static void reinitParser ( DataSource theSource )
  {
    TDLParser . getParser() . ReInit ( theSource );    
    lastDataSource = theSource;
    clearParsingTask();
  }


      /* When printing messages, we need the [<filename>/stdin/Line]: string */
  public static String getFilenameWithoutPathPlusColon()
  {
    return TDLParser.lastDataSource . getFilenameWithoutPathPlusColon();
  }


	/* Sometimes we need to know what kind of task we are currently
	 * parsing, way down in the depths of parsing the Task body...
	 */
  public static boolean getIsParsingMonitorBody()
  {
    return (   (    currentDataTaskDefinition != null          )
	    && (    currentDataTaskDefinition . getTaskType()
		 == DataTaskDefinition.MONITOR_TASK            ) );
  }

  public static boolean getIsParsingExceptionHandlerBody()
  {
    return (   (    currentDataTaskDefinition != null          )
	    && (    currentDataTaskDefinition . getTaskType()
		 == DataTaskDefinition.HANDLER_TASK            ) );
  }

  public static void setParsingTask ( DataTaskDefinition theDataTaskDefinition)
  {
    currentDataTaskDefinition = theDataTaskDefinition;
  }

  public static void clearParsingTask()
  {
    currentDataTaskDefinition = null;
  }



	/* This Main() is used for testing/debugging TDLParser... */
  public static void main ( String args[] ) throws java.io.IOException
  {
    StringBuffer       inputData = new StringBuffer ( 1000 );
    int                inchar;
    DataTaskDefinition dataTaskDef;
    char	       selectedTest = '-';
    char	       subTest      = '-';
    int                i;

    System.err.println("Starting...");

    while ( ( inchar = System.in.read() ) != -1 )
      inputData . append ( (char) ( inchar & 0x00ff ) );

    if ( args . length > 0 )
    {
      if ( args[0] . length() > 0 )
	selectedTest = args[0].charAt(0);

      if ( args[0] . length() > 1 )
	subTest = args[0].charAt(1);
    }

    System.err.println ( "Running test (\"" + selectedTest + "\")  (\""
			 + subTest + "\")  [" + args . length + "]" );


    TDLParser . reinitParser ( inputData . toString() );

    System.err.println("Parsing...");


    try
    {
      switch ( selectedTest )
      {
	case 's':
	  DataStatement  statement = parseStatement(0,0);
	  System.err.println("Ending...");
	  System.err.println("\nResults:\n--------\n" + statement.toString() );
	  break;

	case 'e':
	  DataExpressionStatement Estatement = parseExpressionStatement(0);
	  System.err.println("Ending...");
	  System.err.println("\nResults:\n--------\n" + Estatement.toString());
	  break;

	case 'd':
	  DataDeclarationStatement Dstatement = parseDeclarationStatement(0);
	  System.err.println("Ending...");
	  System.err.println("\nResults:\n--------\n" + Dstatement.toString());
	  break;

	case 'I':
	  DataStatement  Istatement = parseForInitStatement(0);
	  System.err.println("Ending...");
	  System.err.println("\nResults:\n--------\n" + Istatement.toString());
	  break;

	case 'c':
		/* Note:  Parser should be set to correct Token-state up above.
		 *        (But it might not be...)
		 */
	  DataConstraint dataConstraint = parseConstraint ( null, 0 );
	  System.err.println("Ending...");
	  System.err.println("\nResults:\n--------\n"
			     + dataConstraint.toString() );
	  break;

	case 'C':
		/* Note:  Parser should be set to correct Token-state up above.
		 *        (But it might not be...)
		 */
	  DataConstraintStatement dataConstraintStatement
	    = parseConstraintStatement ( 0 );
	  System.err.println("Ending...");
	  System.err.println("\nResults:\n--------\n"
			     + dataConstraintStatement.toString() );
	  break;

	case 'f':
	  DataFile  file = parseFile(null);
	  System.err.println("Ending...");
	  System.err.print("\nResults:\n\n" + file.toString() );
	  break;


	case 'x':
	  Token startToken = getToken(0);
	  DataComponent tmpDataComponent = new DataExpression();

	  switch ( subTest )
	  {
	    case 'a':
	      parseStringConstantAndIdsAssumingTheyAreMacros();
	      break;
	    case 'b':
	      parseLiteral();
	      break;
	    case 'd':
	      parseExpression();
	      break;

	    default:
	    case 'c':
	      parsePrimaryExpression();
	      break;
	  }

	  parseMiscTokens ( tmpDataComponent, startToken, 0 );
	  System.out.println ( "Parsed:  " + tmpDataComponent.toString() );
	  break;


	case 'y':
	  DataComponent tmp_Ytest;

		/* Enable debugging for this test. */
	  TDLParser.debugDistributedDeclarationSet = true;

	  switch ( subTest )
	  {

	    case 'd':
	      tmp_Ytest = parseDistributedDeclarationSet(null);
	      break;
	    case 't':
	      tmp_Ytest = parseDistributedTypedef();
	      break;
	    case 's':
	      tmp_Ytest = parseDistributedStruct(null);
	      break;
	    default:
	    case 'e':
	      tmp_Ytest = parseDistributedEnum (null);
	      break;
	  }

	  System.out.println ( "Parsed:  " + tmp_Ytest.toString() );
	  break;


	case 'z':
	  System.out.println("Running on:  " + inputData . toString() +"\n\n");
	  Token  token = getToken(1);
	  for ( i = 2;  true ;    token = getToken(i++) )
	  {
	    System.out.println ( 
	      "Token [" + i + "]  kind=" + token.kind
	      + " " + TDLParserConstants.tokenImage[token.kind]
	      + "   image=\"" + token.image + "\"" );
	    if ( token.kind == EOF )
	      break;
	  }
	  break;


	case 't':
	default:
	  dataTaskDef = parseTaskDefinitionHead ( null );
	  System.err.println("Ending...");
	  System.err.println("\nResults:\n\n" + dataTaskDef . toString () );
	  System.err.println("\nargcount = "
			     + dataTaskDef . getTaskArgumentCount() );
	  if ( dataTaskDef . getTaskArgumentCount() > 0 )
	  {
	    System.err.println("\narg1:"
	       +   "\n  Dir...: \""
	       + dataTaskDef.getTaskArgument(0).getArgumentDirectionString()
	       + "\"\n  Name..: \""
	       + dataTaskDef.getTaskArgument(0).getArgumentName()
	       + "\"\n  Full..: \""
	       + dataTaskDef.getTaskArgument(0).toString()

	       + "\"\n  DISTRIBTED............: \""
	       + dataTaskDef.getTaskArgument(0).getIsDistributed()
	       + "\"\n  DISTRIBTED_type.......: \""
	       + dataTaskDef.getTaskArgument(0).getDistributedTypeString()
	       + "\"\n  DISTRIBTED_id.........: \""
	       + dataTaskDef.getTaskArgument(0).getDistributedId()
	       + "\"\n  DISTRIBTED_isPointer..: \""
	       + dataTaskDef.getTaskArgument(0).getDistributedIsPointer()

	       + "\"\n" );
	    for ( i=0;
		  i < dataTaskDef.getTaskArgument(0).getSubcomponentsCount();
		  i++ )
	    {
	      System.err.println("  subComponent[" + i + "]...: \""
	         + dataTaskDef.getTaskArgument(0).getStringSubcomponent ( i )
		 + "\"" );
	    }
	  }
	  break;

      } /* switch ( seletedTest ) */

    }
    catch ( ParseException  theParseException )
    {
      System.err.println ("Caught parse Exception:");
      System.err.println ( theParseException );
      if ( theParseException . currentToken != null )
      {
	System.err.println ( "\n\nNote:  Kind = "
			     + theParseException . currentToken.kind );
	System.err.println ( "\nNote:  Token = \""
			     + theParseException . currentToken + "\"" );
	if ( theParseException . currentToken.next != null )
	{
	  System.err.println ( "\n\nNote:  Kind = "
			       + theParseException . currentToken.next.kind );
	  System.err.println ( "\nNote:  Token = \""
			       + theParseException . currentToken.next + "\"");
	}
      }

	/* For debugging, it helps to know what tokens were pending. */
      System.err.println ( "\n\nTokens on stream were:\n" );
      for ( i=0; i<10; i++ )
      {
	System.err.println ( "  Pending Token (" + i + ") was \""
			     + getToken(i).image + "\"   type=" 
			     + getToken(i).kind + "   ("
			     + TDLParserConstants.tokenImage[getToken(i).kind]
			     + ")" );
      }
    }
  }


	/* Used to manually generate a ParseException from code in this file.
	 * Must be compatible with DetailedParseException so we can get
	 * information regarding which token (and where in the file) we died.
	 */
  public static ParseException generateParseException ( Token   theToken,
							String  theText  )
  { return generateParseException ( theToken, theToken, theText ); }

  public static ParseException generateParseException( Token  theToken,
						       Token  theLocationToken,
						       String theText  )
  {
    Token           hackToken      = theToken . newToken ( theToken . kind );
    ParseException  parseException
      = new ParseException ( "\n"
			     + TDLParser.getFilenameWithoutPathPlusColon()
			     + ( theLocationToken.beginLine + 1 )
			     + ":  Error:\n  "
			     + theText );

    hackToken . kind = theToken . kind;

    hackToken . beginLine    = theToken . beginLine;
    hackToken . beginColumn  = theToken . beginColumn;
    hackToken . endLine      = theToken . endLine;
    hackToken . endColumn    = theToken . endColumn;
    hackToken . image        = theToken . image;
    hackToken . next         = theToken;
    hackToken . specialToken = theToken . specialToken;

    parseException . currentToken = hackToken;
    return parseException;
  }


  /* Used to process fluff ( comments, whitespace, etc ) that would
   * ordinarily have been ignored or filtered out by the pre-processor.
   */
  public static void parseFluffIgnoreSpaces ( DataComponent theDataComponent,
					      Token         theToken )
  {
    int index = theDataComponent . getSubcomponentsCount();

    for ( Token  token = theToken . specialToken;
	  token != null;
	  token = token . specialToken )
    {
      if ( token . kind != WHITESPACE )
	theDataComponent . addSubcomponent ( token.image, index );
    }
  }

  public static void parseFluff ( DataComponent theDataComponent,
				  Token         theToken,
				  int           theUnIndent )
  {
    StringBuffer  stringBuffer = null;
    String        string;
    int           i, j,
                  unindentCount,
                  column,
                  spaceToAddForTabChar,
                  componentIndex = theDataComponent . getSubcomponentsCount();

    for ( Token  token = theToken . specialToken;
	  token != null;
	  token = token . specialToken )
    {
      if ( token . kind != WHITESPACE )
      {
	string = token.image;
      }
      else /* Ie:  token . kind == WHITESPACE  && we are un-indenting... */
      {
		/* Find our starting column... */
	column = theToken . beginColumn;

		/* If we have whitespace that doesn't start at column 0, */
		/* something else, non-whitespace, must be there.        */
		/* We do *NOT* want to strip whitespace in this case!!!  */
	if ( column == 0 )
	  unindentCount = theUnIndent;
	else
	  unindentCount = 0;

		/* Create/Erase the stringBuffer is necessary */
	if ( stringBuffer == null )
	  stringBuffer = new StringBuffer();
	stringBuffer . setLength( 0 );

		/* Process the characters */
	for ( i=0; i < token.image.length();  i++ )
	{
	  switch ( token.image.charAt ( i )  )
	  {
	    case '\n':
	    case '\f':
	    case '\r': /* Should we re-indent after carriage-returns? */ 
	      unindentCount = theUnIndent;
	      column = 0;
	      stringBuffer . append ( token.image.charAt ( i ) );
	      break;

	    case '\t':
	      spaceToAddForTabChar = DataComponent.getTabSize()
				     - ( column % DataComponent.getTabSize() );
	      for ( j=0; j < spaceToAddForTabChar; j++ )
	      {
		if ( unindentCount > 0 )
		  unindentCount--;
		else
		  stringBuffer . append ( " " );
	      }
	      column += spaceToAddForTabChar;
	      break;

	    case ' ':
	      if ( unindentCount > 0 )
		unindentCount--;
	      else
		stringBuffer . append ( " " );
	      break;

	    default:
	      System.err.println ( "[TDLParser:parseFluff(... , theindent)]  "
			 + "Error:  Unexpected whitespace character \'0x"
			 + Integer.toHexString ( token.image.charAt ( i ) )
			 + "\'" );
	      break;
	  }
	}

	string = stringBuffer . toString();
      }

      theDataComponent . addSubcomponent ( string, componentIndex );

    } /* For ( token = specialToken's ) */
  }



  public static void parseMiscTokens ( DataComponent theDataComponent,
				       Token         theStartToken,
				       int           theUnIndent )
  {
    for ( Token  token = theStartToken . next;
	  token != getToken(1);
	  token = token . next )
    {
      parseFluff ( theDataComponent, token, theUnIndent );
      theDataComponent . addSubcomponent ( token.image );
    }
  }

  public static void parseMiscTokensIgnoringLast (
					  DataComponent theDataComponent,
					  Token         theStartToken,
					  int           theUnIndent )
  {
    for ( Token  token = theStartToken . next;
	  token != getToken(0);
	  token = token . next )
    {
      parseFluff ( theDataComponent, token, theUnIndent );
      theDataComponent . addSubcomponent ( token.image );
    }
  }


	/* Note:  Can't do conditional-branch parsing inside BNF's. *
	 * So we export as much redundancy as possible over here.   */
  public static void checkForTrailingCommaOrOpenBrace ( Token theNextToken )
    throws ParseException
  {
	/* Idiocy check */
    if (   ( theNextToken.kind != COMMA      )
	&& ( theNextToken.kind != OPEN_BRACE ) )
    {
      throw generateParseException (
		    theNextToken,
		    "Next token should have been a COMMA or an OPEN-BRACE.  "
		  + "Instead found \"" + theNextToken.image + "\"." );
    }
  }

  public static void checkForTrailingCommaOrOpenBraceOrStringOrMacroString (
							   Token theNextToken )
    throws ParseException
  {
	/* Idiocy check */
    if (   ( theNextToken.kind != COMMA           )
	&& ( theNextToken.kind != OPEN_BRACE      )
	&& ( theNextToken.kind != STRING_CONSTANT )
	&& ( theNextToken.kind != ID              ) )
    {
      throw generateParseException (
		    theNextToken,
		    "Next token should have been a COMMA, an OPEN-BRACE, "
		  + "a STRING_CONSTANT, or an identifier corresponding to "
		  + "a #define'd (macro) string constant.  "
		  + "Instead found \"" + theNextToken.image + "\"." );
    }
  }

	/* Note:  Can't do conditional-branch parsing inside BNF's. *
	 * So we export as much redundancy as possible over here.   */
  public static void processTrailingFluffBeforeTheseTokenKindsOnly (
					 DataComponent theDataComponent,
					 Token         theNextToken,
					 int           theUnIndent,
					 int           theFirstNextTokenKind,
					 int           theSecondNextTokenKind )
  {
    if (   ( theNextToken.kind == theFirstNextTokenKind  )
	|| ( theNextToken.kind == theSecondNextTokenKind ) )
    {
	    /* Process subsequent fluff off next token. */
      parseFluff ( theDataComponent, theNextToken, theUnIndent );
	    /* Record that this fluff has already been processed. */
      theNextToken . specialToken = null;
    }
  }


  protected static int parseFileSnarfFluffAndMaybeNextToken (
					    boolean      theIncludeNextToken,
					    StringBuffer theStringBuffer,
					    int          theCurrentLineNumber )
  {
    int    stringBufferCurrentLength = theStringBuffer . length();
    Token  fluffToken;

	    /* Add all the fluff tokens to the string we are building... */
    for ( fluffToken  = getToken ( 1 ) . specialToken;
	  fluffToken != null;
	  fluffToken = fluffToken . specialToken )
    {
      if (   ( theStringBuffer . length() <= 0                          )
	  || ( theCurrentLineNumber       <  0                          )
	  || ( theCurrentLineNumber       >  (fluffToken.beginLine + 1) ) )
      {
	theCurrentLineNumber = fluffToken.beginLine + 1;
      }

        /* Use insert at stringBufferCurrentLength to reverse the order */
      theStringBuffer . insert ( stringBufferCurrentLength, fluffToken.image );
    }


    if ( theIncludeNextToken == true )
    {
      if (   ( theStringBuffer . length() <= 0                           )
	  || ( theCurrentLineNumber       <  0                           )
	  || ( theCurrentLineNumber       >  (getToken(1).beginLine + 1) ) )
      {
	theCurrentLineNumber = getToken ( 1 ) . beginLine + 1;
      }

      	/* Append this token to the string we are building... */
      theStringBuffer . append ( getToken ( 1 ) . image );
    }

    return theCurrentLineNumber;

  } /* protected static int parseFileSnarfFluffAndMaybeNextToken */



	/* This functionality occurs an awfully lot in parseFile() */
  protected static int parseFileInternal_addInCurrentLeadingStrings (
				       StringBuffer  theStringBuffer,
				       DataFile      theThisFile,
				       int           theCurrentLineNumber )
  {
	    /* Add in the current leading string(s) */
    if ( theStringBuffer . length() > 0 )
    {
      theThisFile . addSubcomponent ( new DataComponentPlaceholder (
						  theStringBuffer . toString(),
						  theCurrentLineNumber ) );
      theStringBuffer . setLength ( 0 );

      return -1; /*New value for currentLineNumber; Arbitrary negative number*/
    }
    else
    {
      return theCurrentLineNumber;
    }
  }

	/* Replicated from parseIdToken() down below for use in JAVACODE. */
  protected static boolean isIdToken ( Token theToken )
  {
    switch ( theToken . kind )
    {
      case ID:
      case NAME:

      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:

      case DISTRIBUTED:
      case THREADED:

      case FIRST:
	return true;

      default:
	return false;
    }
  }

}


PARSER_END(TDLParser)




< * >
SPECIAL_TOKEN :
{
    <WHITESPACE:     ([" ","\t","\n","\r","\f"])+ >
  | <C_COMMENT:      "/*" ( ~["*"] | ("*")+ ~["*","/"] )*  ("*")+ "/">
  | <CXX_COMMENT:    "//" (~["\n"])* "\n" >

	/* This is a crude, hacked, kludged means of implementing macros.
	 * But, given the pre-pass nature of C/C++ Macros...  It's the best
	 * we can do.
	 * Note:  Basically, this just says to ignore all macros.  And to
	 *        ignore anything inside a #if0 block.  If users use macros
	 *        inside TDL tasks, they are responsible for getting it right!
	 * Note:  #if0 blocks may *NOT* be nested!!!
	 * Note:  The '#' and '##' macro operators remain unimplemented!
	 *        #define'd macros can be used to work around this limitation.
	 */
  | <C_MACROS_TO_IGNORE: ( "#"
			   ([" ","\t"] | <C_COMMENT> | <CXX_COMMENT>)*
			   (   "define" | "undef" | "if" | "ifdef" | "ifndef"
			     | "elif" | "else" | "endif" | "line" | "error"
			     | "pragma" )
			   ( ~["\n"] | "\\\n" )* "\n") >
  | <C_IF_ZERO_HACK: "#"
		       ([" ","\t"] | <C_COMMENT> | <CXX_COMMENT>)*
		       "if"
		       ([" ","\t"] | <C_COMMENT> | <CXX_COMMENT>)*
		       "0"
		       ([" ","\t"] | <C_COMMENT> | <CXX_COMMENT>)*
		       "\n"
		       ( ~["#"] | ("#")+ ~["#","i","e"] )*
                      "#endif"
		       ([" ","\t"] | <C_COMMENT> | <CXX_COMMENT>)*
		       "\n">
}


< * >
TOKEN :
{
	 /* Keywords, case-sensitive */
    <DO:                      "do">
  | <IF:                      "if">
  | <ELSE:                    "else">
  | <SWITCH:                  "switch">
  | <DEFAULT_LABEL:           "default">
  | <WHILE:                   "while">
  | <BREAK:                   "break">
  | <CONTINUE:                "continue">
  | <RETURN:                  "return">
  | <CASE:                    "case">
  | <SIZEOF:                  "sizeof">
  | <NEW:                     "new">
  | <DELETE:                  "delete">
  | <FRIEND:                  "friend">
  | <TYPEDEF:                 "typedef">
  | <AUTO:                    "auto">
  | <REGISTER:                "register">
  | <INLINE:                  "inline">
  | <CONST:                   "const">
  | <VOLATILE:                "volatile">
  | <CHAR:                    "char">
  | <SHORT:                   "short">
  | <INT:                     "int">
  | <LONG:                    "long">
  | <SIGNED:                  "signed">
  | <UNSIGNED:                "unsigned">
  | <FLOAT:                   "float">
  | <DOUBLE:                  "double">
  | <VOID:                    "void">
  | <CLASS:                   "class">
  | <NAMESPACE:               "namespace">
  | <STRUCT:                  "struct">
  | <UNION:                   "union">
  | <ENUM:                    "enum">
  | <ASM:                     "asm">
  | <PRIVATE:                 "private">
  | <PROTECTED:               "protected">
  | <PUBLIC:                  "public">
  | <OPERATOR:                "operator">
  | <TEMPLATE:                "template">

	/* Keywords, case-sensitive, forbidden inside TDL code... */
  | <GOTO:                    "goto">        /* Outlawed keyword in TDL code */
  | <THROW:                   "throw">       /* Outlawed keyword in TDL code */
  | <CATCH:                   "catch">       /* Outlawed keyword in TDL code */
  | <FINALLY:                 "finally">     /* Outlawed keyword in TDL code */
  | <SETJMP:                  "setjmp">      /* Outlawed keyword in TDL code */
  | <LONGJMP:                 "longjmp">     /* Outlawed keyword in TDL code */
  | <_SETJMP:                 "_setjmp">     /* Outlawed keyword in TDL code */
  | <_LONGJMP:                "_longjmp">    /* Outlawed keyword in TDL code */
  | <SIGSETJMP:               "sigsetjmp">   /* Outlawed keyword in TDL code */
  | <SIGLONGJMP:              "siglongjmp">  /* Outlawed keyword in TDL code */


  | <EXTERN_CS:               "extern">
  | <FOR_CS:                  "for">
  | <STATIC_CS:               "static">
  | <VIRTUAL_CS:              "virtual">

        /* No TDL code inside classes.                        */
	/* (Though THIS can be used as part of a constraint.) */
  | <THIS_CS:                 "this">
}


< * >
TOKEN  [ IGNORE_CASE ] : /* Keywords, case-insensitive */
{
    <EXTERN_CI:               "EXTERN">
  | <FOR_CI:                  "FOR">
  | <STATIC_CI:               "STATIC">
  | <VIRTUAL_CI:              "VIRTUAL">
  | <THIS_CI:                 "THIS">
  | <TASK:                    "Task">
  | <GOAL:                    "Goal">
  | <COMMAND:                 "Command">
  | <MONITOR:                 "Monitor">
  | <EXCEPTION:               "Exception">
  | <HANDLER:                 "Handler">
  | <RESUME:                  "Resume">
  | <HANDLES:                 "Handles">
  | <SUCCESS:                 "Success">
  | <POSTPONE:                "Postpone">
  | <FAIL:                    "Fail">
  | <IN:                      "IN">
  | <OUT:                     "OUT">
  | <INOUT:                   "INOUT">
  | <SELF:                    "self">
  | <CHILD:                   "child">
  | <PARENT:                  "parent">
  | <PREVIOUS:                "previous">
  | <ENABLED:                 "enabled">
  | <ACTIVE:                  "active">
  | <COMPLETED:               "completed">
  | <HANDLING:                "handling">
  | <EXPANSION:               "expansion">
  | <EXECUTION:               "execution">
  | <PLANNING:                "planning">
  | <ACHIEVEMENT:             "achievement">
  | <EXPAND:                  "expand">
  | <FIRST:                   "first">
  | <DELAY:                   "delay">
  | <SEQUENTIAL:              "sequential">
  | <SERIAL:                  "serial">
  | <PARALLEL:                "parallel">
  | <WAIT:                    "wait">
  | <DISABLE:                 "disable">
  | <UNTIL:                   "until">
  | <AFTER:                   "after">
  | <TERMINATE:               "terminate">
  | <AT:                      "at">
  | <MAXIMUM:                 "maximum">
  | <ACTIVATE:                "activate">
	/* Note: IN is already defined above... */
  | <TRIGGER:                 "trigger">
  | <MONITOR_PERIOD:          "period">
  | <ON:                      "on">
  | <PERSISTENT:              "persistent">
  | <DISTRIBUTED:             "distributed">
  | <FORMAT:                  "format">
  | <THREADED:                "threaded">
  | <NAME:                    "name">


    /* Note:  Missing spaces between two keywords should *NOT* burn the user.*/
  | <EXPAND_FIRST:            <EXPAND>     ("_")* <FIRST>               >
  | <DELAY_EXPANSION:         <DELAY>      ("_")* <EXPANSION>           >
  | <SEQUENTIAL_HANDLING:     <SEQUENTIAL> ("_")* <HANDLING>            >
  | <SEQUENTIAL_EXPANSION:    <SEQUENTIAL> ("_")* <EXPANSION>           >
  | <SEQUENTIAL_EXECUTION:    <SEQUENTIAL> ("_")* <EXECUTION>           >
  | <SEQUENTIAL_PLANNING:     <SEQUENTIAL> ("_")* <PLANNING>            >
  | <SEQUENTIAL_ACHIEVEMENT:  <SEQUENTIAL> ("_")* <ACHIEVEMENT>         >
  | <DISABLE_UNTIL:           <DISABLE>    ("_")* <UNTIL>               >
  | <DISABLE_FOR:             <DISABLE>    ("_")* (<FOR_CI> | <FOR_CS>) >
  | <TERMINATE_AT:            <TERMINATE>  ("_")* <AT>                  >
  | <TERMINATE_IN:            <TERMINATE>  ("_")* <IN>                  >
  | <ACTIVATE_AT:             <ACTIVATE>   ("_")* <AT>                  >
  | <ACTIVATE_IN:             <ACTIVATE>   ("_")* <IN>                  >
  | <MAXIMUM_ACTIVATE:        <MAXIMUM>    ("_")* <ACTIVATE>            >
  | <MAXIMUM_TRIGGER:         <MAXIMUM>    ("_")* <TRIGGER>             >
  | <ON_TERMINATE:            <ON>         ("_")* <TERMINATE>           >

  | <SPAWN:                   "spawn">
  | <WITH:                    "with">

	/* More complext tokens... */
  | <USING_FILE_STANDARD:  ( "#" ([" ","\t"])* "using"  ([" ","\t"])* 
			     "<"  (~[">"])+  ">"  ) >
  | <USING_FILE_QUOTE:     ( "#" ([" ","\t"])* "using"  ([" ","\t"])* 
			     "\"" (~["\""])+ "\"" ) >


	/* Keywords, case-sensitive, permitted inside TDL code...     */
	/* (Case is insensitive here -- Must be adjusted later on...) */

  | <TDL_REF:                 "TDL" ("_")* "REF">  /** Special TDL Macro. **/
  | <TDL_REF_IN:              "TDL" ("_")* "REF" ("_")* "IN"> /* Constraint */
  | <TDL_BIND:                "TDL" ("_")* "BIND">

		/*** Special Functions for Monitors only. ***/
  | <GET_NUMBER_OF_TRIGGERS:  "getNumberOfTriggers">
  | <GET_NUMBER_OF_ACTIVATES: "getNumberOfActivates">
}


< * >
TOKEN : /* Symbols */
{
	/* Assignment operations */
    <EQUAL:                           "=">
  | <MULTIPLY_EQUAL:                 "*=">
  | <DIVIDE_EQUAL:                   "/=">
  | <MODULO_EQUAL:                   "%=">
  | <PLUS_EQUAL:                     "+=">
  | <MINUS_EQUAL:                    "-=">
  | <RIGHTSHIFT_EQUAL:              ">>=">
  | <LEFTSHIFT_EQUAL:               "<<=">
  | <AND_EQUAL:                      "&=">
  | <XOR_EQUAL:                      "^=">
  | <OR_EQUAL:                       "|=">

  | <LOGICAL_OR:                     "||">
  | <LOGICAL_AND:                    "&&">
  | <INCLUSIVE_OR:                    "|">
  | <EXCLUSIVE_OR:                    "^">
  | <NOT:                             "!">
  | <EQUALITY:                       "==">
  | <INEQUALITY:                     "!=">
  | <LESS_THAN:                       "<">
  | <GREATER_THAN:                    ">">
  | <LESS_THAN_OR_EQUALS:            "<=">
  | <GREATER_THAN_OR_EQUALS:         ">=">
  | <LEFT_SHIFT:                     "<<">
  | <RIGHT_SHIFT:                    ">>">
  | <PLUS:                            "+">
  | <MINUS:                           "-">
  | <DIVIDE:                          "/">
  | <MODULO:                          "%">
  | <POINTER_TO_MEMBER:              ".*">
  | <POINTER_TO_MEMBER_DEREFERENCE: "->*">
  | <DEREFERENCE:                    "->">
  | <INCREMENT:                      "++">
  | <DECREMENT:                      "--">
  | <SCOPE:                          "::">
  | <ELLIPSIS:                      "...">

  | <OPEN_PAREN:                      "(">
  | <CLOSE_PAREN:                     ")">
  | <OPEN_BRACKET:                    "[">
  | <CLOSE_BRACKET:                   "]">
  | <OPEN_BRACE:                      "{">
  | <CLOSE_BRACE:                     "}">
  | <SEMICOLON:                       ";">
  | <COMMA:                           ",">
  | <AMPERSAND:                       "&">
  | <ASTERISK:                        "*">
  | <TILDE:                           "~">
  | <COLON:                           ":">
  | <QUESTION_MARK:                   "?">
  | <PERIOD:                          ".">

	/* Constants */
  | <#DECIMAL_NUMBER:       ( ["1"-"9"] (["0"-"9"])* ) >
  | <#OCTAL_NUMBER:         ( ("0")+ (["0"-"7"])* ) >
  | <#HEX_NUMBER:           ( "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ ) >
  | <INTEGER_CONSTANT:     ( <DECIMAL_NUMBER> | <OCTAL_NUMBER> | <HEX_NUMBER> )
			   (   ( (["u","U"]) (["l","L"])? )
			     | ( (["l","L"]) (["u","U"])? ) )? >

      /* Note:  While legal, embedded Linefeeds seem to cause problems... */
  | <#A_CHARACTER:	   (   (~["'","\"","\\","\n"])
			     | ( "\\"
				 (   ["n","t","v","b","r","f","a","\\","?",
				      "'", "\""]
				   | ((["0"-"7"]) (["0"-"7"])? (["0"-"7"])? )
				   | ( "x" (["0"-"9","a"-"f","A"-"F"])+ )
				 )
			       )
			   ) >

  | <CHARACTER_CONSTANT:   ( ("L")? "'" (<A_CHARACTER> | "\"")+ "'" ) >
                                     
  | <STRING_CONSTANT:      ( ("L")? "\"" (<A_CHARACTER> | "'")* "\""
                             ( (   <WHITESPACE> | <C_COMMENT> | <CXX_COMMENT>
			         | <C_MACROS_TO_IGNORE> | <C_IF_ZERO_HACK>
			       )*
                                    "\"" (<A_CHARACTER> | "'")* "\""
                              )*
                           ) >


        /* Complex symbol(s) */
  | <ID: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","_","0"-"9"] )* >
}


< * >
TOKEN :
{
      /* Note: This only picks up tokens that don't match <INTEGER_CONSTANT> */
    <NON_NEGATIVE_INTEGER_CONSTANT:     ( (["0"-"9"])+ )>

	/* Used for special ( # . # ) cases in constraints */
  | <FLOAT_CONSTANT_BASIC: (     (   ( (["0"-"9"])+ <PERIOD> (["0"-"9"])* )
				   | (              <PERIOD> (["0"-"9"])+ )
				 )
			   ) >

	/* Rest of the Floating-point constant token possibilities */
  | <FLOATING_CONSTANT:    (
			      (   ( <FLOAT_CONSTANT_BASIC>
				    (  ["E","e"]  (["+","-"])?  (["0"-"9"])+  )
				    (["f","F","l","L"])?
			          )
			      )

			    | (   ( <FLOAT_CONSTANT_BASIC>
				    ( ["f","F","l","L"] )
			          )
			      )

			    | (   ( (["0"-"9"])+
				    ["E","e"] (["+","-"])?  (["0"-"9"])+
				    (["f","F","l","L"])?
			          )
			      )
			   ) >
}


< * >
TOKEN : /* BUGFIX 0.7pre5.  MUST BE LAST TOKEN!!!! */
{
  <GARBAGE_TOKEN:  ~[]>
}


/******************/
/*** <ID> Token ***/
/******************/

/*
 * <ID> really ought to let us use various other tokens as valid ID's.
 * Note: For backward compatibility, this *MUST* ONLY PARSE A SINGLE TOKEN.
 * Note: Limit us to things that are not used elsewhere inside Tasks, or this
 *       is going to become extremely painful.
 * Note: Also replicated in isIdToken(Token) up above.
 */
Token
parseIdToken() :
{
}
{
  (   <ID>
    | <NAME>

    | <TASK>
    | <GOAL>
    | <COMMAND>
    | <MONITOR>
    | <EXCEPTION>
    | <HANDLER>
    | <RESUME>
    | <HANDLES>

    | <DISTRIBUTED>
    | <THREADED>

    | <FIRST>
  )
    { return getToken(0); }
}



/***********************/
/*** STRING_CONSTANT ***/
/***********************/

/*
 * <STRING_CONSTANT> really needs to include <ID>'s, to deal with
 * #defined macros.  However, including <ID>'s in the <STRING_CONSTANT>
 * token causes unbelievable pain and suffering.  (Amongst other things,
 * the token-type chosen is the longest token type.)
 */
void
parseStringConstantAndIdsAssumingTheyAreMacros ( ) :
{
}
{
  (   <STRING_CONSTANT>
    | parseIdToken()
  )+
}




/**********************/
/*** Helper routine ***/
/**********************/

/*
 * Note:  This is a JAVACODE routine.  If it ever gets called from a
 * non-JAVACODE routine, especially a BNF expression, we could have
 * extreme decision-making (look-ahead) difficulties.
 *
 * It is only intended to be called from the Java side of things
 * to automate stripping out non-whitespace fluff -- comments, etc.
 *
 * Addendum:  Keywords inside string-literals can also cause grief...
 */
JAVACODE
String
parseStripFluff ( boolean theStripStrings )
{
  StringBuffer   stringBuffer = new StringBuffer ( 1000 );


  for ( ;   getToken ( 1 ) . kind != EOF;   getNextToken() )
  {
    if (   ( theStripStrings       == true            )
	&& ( getToken ( 1 ) . kind == STRING_CONSTANT ) )
      continue;

    stringBuffer . append ( getToken ( 1 ) . image );
    stringBuffer . append ( " " );
  }

  return stringBuffer . toString();
}


/******************/
/*** Parse File ***/
/******************/

/*
 * Note:  This is a JAVACODE routine.  If it ever gets called from a
 * non-JAVACODE routine, especially a BNF expression, we could have
 * extreme decision-making (look-ahead) difficulties.
 */
JAVACODE
DataFile
parseFile ( DataFile  theDataFile )
{
  int           indexToCheck, spawnIndent, currentLineNumber = -1;
  boolean       needToCheckAdditionalToken;
  StringBuffer  stringBuffer = new StringBuffer();
  DataVector    stack        = new DataVector ( 10 );
  Token         stackToken;
  DataSpawnTask dataSpawnTask;
  DataFile      thisFile = (   ( theDataFile != null )
			     ? theDataFile : new DataFile() );
  int           i, j;
  Token         labeledSpawnToken;
  boolean       stackInsideSomethingOtherThanClassStructNamespace;
  boolean       stackInsideClassStruct; /* Namespace doesn't count. */


  while ( getToken ( 1 ) . kind != EOF )
  {
	/* We used to be able to just check (getToken ( 1 ) . kind == SPAWN),
	 * but labels complicate that...
	 */
    labeledSpawnToken = null;
    for ( i = 1;   getToken ( i ) . kind != EOF;   i += 2 )
    {
      if ( getToken ( i ) . kind == SPAWN )
      {
	labeledSpawnToken = getToken ( i );
	break;
      }

      if (   ( getToken ( i   ) . kind != ID    )
	  || ( getToken ( i+1 ) . kind != COLON ) )
	break;
    }


	/* Check to see if there is anything other than class/namespace "{" *
	 * on the stack (for use later on)...                               */
    stackInsideSomethingOtherThanClassStructNamespace = false;
    stackInsideClassStruct                            = false;
    for ( i = 0;  i < stack.count();  i++ )
    {
      stackToken = (Token) ( stack . elementAt ( i ) );

      if ( stackToken instanceof ClassStructNamespaceToken )
      {
	switch ( ((ClassStructNamespaceToken) stackToken) . type )
	{
	  case CLASS:
	  case STRUCT:
	    stackInsideClassStruct = true;
	    break;
	}
      }
      else
      {
	stackInsideSomethingOtherThanClassStructNamespace = true;
      }

      if (   ( stackInsideSomethingOtherThanClassStructNamespace == true )
	  && ( stackInsideClassStruct                            == true ) )
	break;
    }


	       	/*****************************/
		/* Are we defining a Task??? */
		/*****************************/
		/* Start checking with the next token. */
    indexToCheck = 1;

    do
    {
      needToCheckAdditionalToken = false;
	  
			/* Is it extern? */
      if (   (   ( getToken ( indexToCheck     ) . kind  == EXTERN_CS   )
	      || ( getToken ( indexToCheck     ) . kind  == EXTERN_CI   )

			/* Is it PERSISTENT? */
	      || ( getToken ( indexToCheck     ) . kind  == PERSISTENT  )

			/* Is it distributed? */
	      || ( getToken ( indexToCheck     ) . kind  == DISTRIBUTED )

			/* Is it threaded? */
	      || ( getToken ( indexToCheck     ) . kind  == THREADED    )

			/* Is it static? */
	      || ( getToken ( indexToCheck     ) . kind  == STATIC_CS   )
	      || ( getToken ( indexToCheck     ) . kind  == STATIC_CI   )

			/* Is it virtual? */
	      || ( getToken ( indexToCheck     ) . kind  == VIRTUAL_CS  )
	      || ( getToken ( indexToCheck     ) . kind  == VIRTUAL_CI  ) )

	  && (     getToken ( indexToCheck + 1 ) . kind  != EOF           ) )
      {
	  /* Need to check the next token. */
	indexToCheck ++;
	needToCheckAdditionalToken = true;
      }
    } while ( needToCheckAdditionalToken == true );

	/***************************/
	/* Are we defining a task? */
        /***************************/
    if (   (   ( getToken ( indexToCheck ) . kind == TASK      )
	    || ( getToken ( indexToCheck ) . kind == GOAL      )
	    || ( getToken ( indexToCheck ) . kind == COMMAND   )
	    || ( getToken ( indexToCheck ) . kind == MONITOR   )
	    || ( getToken ( indexToCheck ) . kind == EXCEPTION )
	    || ( getToken ( indexToCheck ) . kind == HANDLER   )
	    || ( getToken ( indexToCheck ) . kind == RESUME    ) )
	/* Tasks can be defined if we are outside everything (empty stack) *
	 * or if we are only inside class/struct/namespace declarations.   */
	&& ( stackInsideSomethingOtherThanClassStructNamespace == false ) )
    {
	    /* Add in the current leading string(s) */
      currentLineNumber
	= parseFileInternal_addInCurrentLeadingStrings( stringBuffer,
							thisFile,
							currentLineNumber);
	    /* Snarf the task. */
      DataTaskDefinition  tmpDataTaskDefinition
	= parseFullTaskDefinition ( null, stackInsideClassStruct );

	    /* If necessary, add scoping here... */
      if ( tmpDataTaskDefinition . getTaskScope() . hasScope() == false )
      {
	int scopeCount = 0;
	for ( i = 0;  i < stack.count();  i++ )
	{
	  stackToken = (Token) ( stack . elementAt ( i ) );
	  if ( stackToken instanceof ClassStructNamespaceToken )
	  {
	    tmpDataTaskDefinition . setWasImplicitlyScoped();

	    tmpDataTaskDefinition . getTaskScope() . addScope ( 
               ((ClassStructNamespaceToken) stackToken) . idToken . image );

	    tmpDataTaskDefinition . getTaskScope()
	      . setIndex ( DataScope.IDENTIFIER_INDEX + scopeCount );

	    tmpDataTaskDefinition . getTaskScope()
	      . setIndex ( DataScope.SCOPE + scopeCount );

	    scopeCount ++;
	  }
	} /* for ( i = 0;  i < stack.count();  i++ ) */
      } /* if ( tmpDataTaskDefinition . hasTaskScope() ) */

	    /* Now we can add it to the file. */
      thisFile . addSubcomponent ( tmpDataTaskDefinition );

	    /* Go on to next parse... */
      continue;
    } /* IF ( Are we defining a task ) */


	/* Are we starting a class or namespace? */
    else if (   (   ( getToken ( 1 ) . kind == CLASS      )
		 || ( getToken ( 1 ) . kind == STRUCT     )
		 || ( getToken ( 1 ) . kind == NAMESPACE  ) )
	     && (     isIdToken ( getToken ( 2 ) )          )
	     && (   ( getToken ( 3 ) . kind == OPEN_BRACE )
		 || ( getToken ( 3 ) . kind == COLON      ) ) )
    {
	/* Add a munged copy of this token so we    *
	 * can detect it's a class/namespace token. */
      ClassStructNamespaceToken  tmpToken = new ClassStructNamespaceToken();
      tmpToken . kind         =  OPEN_BRACE;
      tmpToken . beginLine    =  getToken ( 2 ) . beginLine;
      tmpToken . beginColumn  =  getToken ( 2 ) . beginColumn;
      tmpToken . endLine      =  getToken ( 2 ) . endLine;
      tmpToken . endColumn    =  getToken ( 2 ) . endColumn;
      tmpToken . image        =  "class ..."; /* Reset properly down below. */
      tmpToken . specialToken = null;
      tmpToken . next         = null;
      tmpToken . type         = getToken ( 1 ) . kind;
      tmpToken . idToken      = getToken ( 2 );
      stack . addElement ( tmpToken );

	    /* Add in the current leading string(s) */
      currentLineNumber
	= parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
							 thisFile,
							 currentLineNumber );

      DataClassStructNamespace tmpDataClassStructNamespace
				 = parseStartDataClassStructNamespace ( null );

      thisFile . addSubcomponent ( tmpDataClassStructNamespace );

      tmpToken.image = tmpDataClassStructNamespace . toString();

	    /* Go on to next parse... */
      continue;
    }

	/* Are we entering something? */
    else if (   ( getToken ( 1 ) . kind == OPEN_PAREN   )
	     || ( getToken ( 1 ) . kind == OPEN_BRACKET )
	     || ( getToken ( 1 ) . kind == OPEN_BRACE   ) )
    {
      stack . addElement ( getToken ( 1 ) );
	/* And snarf token down below... */
    }
    
	/* Are we inside something? */
    else if ( stack . isEmpty() == false )
    {
      stackToken = (Token) ( stack . lastElement() );

	/* Are we exiting something? */
      if (   (   ( stackToken     . kind == OPEN_PAREN    )
	      && ( getToken ( 1 ) . kind == CLOSE_PAREN   ) )
	  || (   ( stackToken     . kind == OPEN_BRACKET  )
	      && ( getToken ( 1 ) . kind == CLOSE_BRACKET ) )
	  || (   ( stackToken     . kind == OPEN_BRACE    )
	      && ( getToken ( 1 ) . kind == CLOSE_BRACE   ) ) )
      {
	stack . removeLastElement();

	    /* If we just ended a class/struct/namespace... */
	if ( stackToken instanceof ClassStructNamespaceToken )
	{
	  if ( getToken ( 2 ) . kind != SEMICOLON )
	  {
	    throw generateParseException ( getToken ( 1 ),
		       "Encountered a \""  +  getToken ( 1 ) . image
		     + "\" WITHOUT A FOLLOWING \";\" at line "
		     + (getToken ( 1 ) . beginLine + 1)
		     + " while looking for a match to\n-----\n"
		     + stackToken.image
		     + "\n-----\nat line " + (stackToken . beginLine + 1)
		     + ".\nParse Failed..." );
	  }

	    /* Add in the current leading string(s) */
	  currentLineNumber
	    = parseFileInternal_addInCurrentLeadingStrings( stringBuffer,
							    thisFile,
							    currentLineNumber);

	  thisFile . addSubcomponent ( parseEndDataClassStructNamespace (
					 null,
					 stackToken.image.substring (
					   0,
					   stackToken.image.length() - 2 ) ) );

	    /* Go on to next parse... */
	  continue;
	} /* if ( stackToken instanceof ClassStructNamespaceToken ) */

	/* Otherwise, just keep going to parse the CLOSE_* token. */
      }

	/* Are we in error? */
      else if (   (   (     getToken ( 1 ) . kind == CLOSE_PAREN   )
		   || (     getToken ( 1 ) . kind == CLOSE_BRACKET )
		   || (     getToken ( 1 ) . kind == CLOSE_BRACE   ) )

	       && (   (   ( stackToken     . kind == OPEN_PAREN    )
	               && ( getToken ( 1 ) . kind != CLOSE_PAREN   ) )
		   || (   ( stackToken     . kind == OPEN_BRACKET  )
		       && ( getToken ( 1 ) . kind != CLOSE_BRACKET ) )
		   || (   ( stackToken     . kind == OPEN_BRACE    )
		       && ( getToken ( 1 ) . kind != CLOSE_BRACE   ) ) ) )
      {
	throw generateParseException ( getToken ( 1 ),
		       "Encountered a \""  +  getToken ( 1 ) . image
		     + "\" at line " + (getToken ( 1 ) . beginLine + 1)
		     + " while looking for a match to \"" + stackToken.image
		     + "\" at line " + (stackToken . beginLine + 1)
		     + ".\nParse Failed..." );
      }


	/* Spawn's can be embedded outside of tasks inside functions... */
      else if (   ( stackInsideSomethingOtherThanClassStructNamespace == true )
	       && ( labeledSpawnToken                                 != null )
	       )
      {
	    /* Add in the current leading string(s) */
	currentLineNumber
	  = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
							   thisFile,
							   currentLineNumber );
	    /* How far is this SPAWN indented?
	     * Note: getToken(1) may be a label, rather than the SPAWN token.
	     * (Which in turn makes for strange indentation...)
	     */
	if (   ( getToken ( 1 )   . beginColumn <= stackToken . beginColumn )
	    || (labeledSpawnToken . beginColumn <= stackToken . beginColumn ) )
	  spawnIndent = Math.max ( getToken ( 1 )    . beginColumn,
				   labeledSpawnToken . beginColumn );
	else
	  spawnIndent = Math.min ( getToken ( 1 )    . beginColumn,
				   labeledSpawnToken . beginColumn );

	    /* Snarf the task. */
	dataSpawnTask = parseLabeledSpawnTask ( null, spawnIndent );
		/* We are outside of the usual indenting procedures... So... */
	dataSpawnTask . setExtraIndent ( spawnIndent );
	thisFile . addSubcomponent ( dataSpawnTask );

	    /* Go on to next parse... */
	continue;
      }

    } /* else if ( stack . isEmpty() == false ) */


	/* Otherwise:  General case... */
    else
    {
	/* Are we "#using" (including) another TDL file here? */
      if (   ( getToken ( 1 ) . kind == USING_FILE_STANDARD )
	  || ( getToken ( 1 ) . kind == USING_FILE_QUOTE    ) )
      {
	currentLineNumber
	  = parseFileSnarfFluffAndMaybeNextToken ( false, stringBuffer,
						   currentLineNumber   );

	    /* Add in the current leading string(s) */
	currentLineNumber
	  = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
							   thisFile,
							   currentLineNumber );
	    /* Add this using-file */
	thisFile . setIndex ( DataFile.USING_INDEX
			      + thisFile . getUsingFiles() . count() );
	thisFile . addUsingFileAndStripUsing ( getToken ( 1 ) . image );

	    /* Go on to the next token... */
	getNextToken();

	    /* Go on to next parse... */
	continue;
      }



	       	/*********************************************/
		/* Are we defining a extern "H" {} block ??? */
		/*********************************************/
      else if (   (   ( getToken ( 1 ) . kind == EXTERN_CS                )
		   || ( getToken ( 1 ) . kind == EXTERN_CI                ) )
	       && (     getToken ( 2 ) . kind != EOF                        )
	       && (     getToken ( 2 ) . image . equalsIgnoreCase ("\"H\"") )
	       && (     getToken ( 3 ) . kind == OPEN_BRACE                 ) )
      {
	    /* Add in the current leading string(s) */
	currentLineNumber
	  = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
							   thisFile,
							   currentLineNumber );

	thisFile . addSubcomponent ( parseDataExternH ( null ) );

	    /* Go on to next parse... */
	continue;
      }



	       	/*********************************************************/
		/* Are we defining a distributed typedef/struct/enum ??? */
		/*********************************************************/
      else if (   (     getToken ( 1 ) . kind == DISTRIBUTED   )
	       && (   ( getToken ( 2 ) . kind == STRUCT      )
		   || ( getToken ( 2 ) . kind == ENUM        )
		   || ( getToken ( 2 ) . kind == TYPEDEF     ) ) )
      {
	    /* Add in the current leading string(s) */
	currentLineNumber
	  = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
							   thisFile,
							   currentLineNumber );
	try
	{
	  if      ( getToken ( 2 ) . kind == TYPEDEF )
	    thisFile . addSubcomponent ( parseDistributedTypedef() );
	  else if ( getToken ( 2 ) . kind == STRUCT  )
	    thisFile . addSubcomponent ( parseDistributedStruct(null) );
	  else
	    thisFile . addSubcomponent ( parseDistributedEnum(null) );

	    /* Go on to next parse... */
	  continue;
	}
	catch ( ParseException  theParseException )
	{
		/* Lets be a little bit more verbose here,        *
		 * so as not to confuse the end-users too much... */
	  System.err.println ( TDLParser.getFilenameWithoutPathPlusColon()
			       + ( getToken ( 0 ) . beginLine + 1 )
			       + ":  Parse Error:  "
			       + "DISTRIBUTED struct/enum/typedef "
			       + "has unsupported declaration types." );
	  throw theParseException;
	}
      } /* IF ( is a USING_FILE statement ) ....
	 * ELSE if ( are we defining a extern "H" {} block ) ...
	 * ELSE if ( are we defining a distributed typedef/struct/enum ) ...
	 */

    } /* IF ( class / namespace ) ...
       * ELSE IF ( "([{" ) ...
       * ELSE IF ( "([{" on stack -- at or before "}])" ) ...
       * ELSE ...
       */


	/* Otherwise, just snarf the tokens into the stringbuffer, */
	/* so we can have one really big string rather than lots of */
        /* little strings... */
    currentLineNumber
      = parseFileSnarfFluffAndMaybeNextToken ( true, stringBuffer,
					       currentLineNumber  );


	    /* Go on to the next token... */
    getNextToken();

  } /* while ( getToken ( 1 ) . kind  !=  EOF ) */



	/* Snarf the EOF token... */ 
  currentLineNumber
    = parseFileSnarfFluffAndMaybeNextToken ( false, stringBuffer,
					     currentLineNumber   );


	/* If we are still inside something, report an error... */
  if ( stack . isEmpty() == false )
  {
    throw generateParseException ( getToken ( 1 ),
		    "File ends while still inside nested C/C++ Code.\n"
		    + "File Parse Failure...\nExpected a match to: \""
		    + ( (Token) (stack . lastElement()) ) . image + "\"" );
  }

	/* Add in the current trailing string(s) */
  currentLineNumber
    = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
						     thisFile,
						     currentLineNumber );
  return thisFile;
}




/******************/
/*** Extern "H" ***/
/******************/

/*
 * Note:  This is a JAVACODE routine.  If it ever gets called from a
 * non-JAVACODE routine, especially a BNF expression, we could have
 * extreme decision-making (look-ahead) difficulties.
 *
 * Note:  Using JAVACODE to avoid difficulties with "H" token,
 *        and all the miscellaneous interior tokens.
 *
 * Note:  This could probably be done with some immensely clever programming
 *        inside parseFile().  But thats far too much work for far to little
 *        savings.  Not to mention the complications for future efforts.
 */
JAVACODE
DataExternH
parseDataExternH ( DataExternH theDataExternH )
{
  DataVector    stack        = new DataVector ( 10 );
  Token         stackToken;

  DataExternH   thisDataExternH = (   ( theDataExternH != null )
				    ?   theDataExternH
				    :   new DataExternH() );


  if (   (   ( getToken ( 1 ) . kind == EXTERN_CS                   )
	  || ( getToken ( 1 ) . kind == EXTERN_CI                   ) )
      && (     getToken ( 2 ) . kind != EOF                           )
      && (     getToken ( 2 ) . image . equalsIgnoreCase ( "\"H\"" )  )
      && (     getToken ( 3 ) . kind == OPEN_BRACE                    ) )
  {
    thisDataExternH . setLineNumber ( getToken ( 1 ) . beginLine + 1 );

    parseFluff ( thisDataExternH, getToken ( 1 ), 0 );
    thisDataExternH . setIndex ( DataExternH.EXTERN );

    parseFluff ( thisDataExternH, getToken ( 2 ), 0 );
    thisDataExternH . setIndex ( DataExternH.HEADER_STRING );

    parseFluff ( thisDataExternH, getToken ( 3 ), 0 );
    thisDataExternH . setIndex ( DataExternH.OPEN_BRACE );

	/* Snarf these 3 tokens. */
    getNextToken();
    getNextToken();
    getNextToken();
  }
  else
  {
	/* This should, in theory, never be reached. */
    throw generateParseException ( token,
				   getToken ( 1 ),
				     "Expected: 'EXTERN \"H\" {'.  "
				   + "Found: '" + getToken(1).image + " "
				   + getToken(2).image + " "
				   + getToken(3).image + "\n" );
  }



  while (   (     getToken ( 1 ) . kind != EOF           )
	 && (   ( getToken ( 1 ) . kind != CLOSE_BRACE )
	     || (  stack . isEmpty()    == false       ) ) )
  {
	/* Are we entering something? */
    if (   ( getToken ( 1 ) . kind == OPEN_PAREN   )
	|| ( getToken ( 1 ) . kind == OPEN_BRACKET )
	|| ( getToken ( 1 ) . kind == OPEN_BRACE   ) )
    {
      stack . addElement ( getToken ( 1 ) );
    }
    
	/* Are we inside something? */
    else if ( stack . isEmpty() == false )
    {
	/* Are we exiting something? */
      stackToken = (Token) ( stack . lastElement() );
      if (   (   ( stackToken     . kind == OPEN_PAREN    )
	      && ( getToken ( 1 ) . kind == CLOSE_PAREN   ) )
	  || (   ( stackToken     . kind == OPEN_BRACKET  )
	      && ( getToken ( 1 ) . kind == CLOSE_BRACKET ) )
	  || (   ( stackToken     . kind == OPEN_BRACE    )
	      && ( getToken ( 1 ) . kind == CLOSE_BRACE   ) ) )
      {
	stack . removeLastElement();
      }

	/* Are we in error? */
      else if (   (   (     getToken ( 1 ) . kind == CLOSE_PAREN   )
		   || (     getToken ( 1 ) . kind == CLOSE_BRACKET )
		   || (     getToken ( 1 ) . kind == CLOSE_BRACE   ) )

	       && (   (   ( stackToken     . kind == OPEN_PAREN    )
	               && ( getToken ( 1 ) . kind != CLOSE_PAREN   ) )
		   || (   ( stackToken     . kind == OPEN_BRACKET  )
		       && ( getToken ( 1 ) . kind != CLOSE_BRACKET ) )
		   || (   ( stackToken     . kind == OPEN_BRACE    )
		       && ( getToken ( 1 ) . kind != CLOSE_BRACE   ) ) ) )
      {
	throw generateParseException ( getToken ( 1 ),
		       "Encountered a \""  +  getToken ( 1 ) . image
		     + "\" at line " + (getToken ( 1 ) . beginLine + 1)
		     + " while looking for a match to \"" + stackToken.image
		     + "\" at line " + (stackToken . beginLine + 1)
		     + "\nFile Parse Failed..." );
      }
    }

	       	/**************************************************/
		/* Special case:  Allow Distributed declars here. */
		/**************************************************/
    else if (   (     getToken ( 1 ) . kind == DISTRIBUTED   )
	     && (   ( getToken ( 2 ) . kind == STRUCT      )
		 || ( getToken ( 2 ) . kind == ENUM        )
		 || ( getToken ( 2 ) . kind == TYPEDEF     ) ) )
    {
      try
      {
	if      ( getToken ( 2 ) . kind == TYPEDEF )
	  thisDataExternH . addSubcomponent ( parseDistributedTypedef() );
	else if ( getToken ( 2 ) . kind == STRUCT  )
	  thisDataExternH . addSubcomponent ( parseDistributedStruct(null) );
	else
	  thisDataExternH . addSubcomponent ( parseDistributedEnum(null) );

	    /* Go on to next parse... */
	continue;
      }
      catch ( ParseException  theParseException )
      {
		/* Lets be a little bit more verbose here,        *
		 * so as not to confuse the end-users too much... */
	  System.err.println ( TDLParser.getFilenameWithoutPathPlusColon()
			       + ( getToken ( 0 ) . beginLine + 1 )
			       + ":  Parse Error:  "
			       + "DISTRIBUTED struct/enum/typedef "
			       + "has unsupported declaration types." );
	  throw theParseException;
      }
    }




	/* Otherwise snarf the token. */
    parseFluff ( thisDataExternH, getToken ( 1 ), 0 );
    thisDataExternH . addSubcomponent ( getToken ( 1 ) . image );

	    /* Go on to the next token... */
    getNextToken();

  } /* WHILE ( getToken(1) != EOF (or CLOSE_BRACE if stack empty) ) */
  


  if ( getToken ( 1 ) . kind == CLOSE_BRACE )
  {
    parseFluff ( thisDataExternH, getToken ( 1 ), 0 );
    thisDataExternH . setIndex ( DataExternH.CLOSE_BRACE );

    getNextToken();
  }
  else
  {
    throw generateParseException ( token,
				   getToken ( 1 ),
				     "Premature end of file.  "
				   + "Expected: '}' at end of "
				   + "'EXTERN \"H\" {' clause.\n" );
  }

  return thisDataExternH;
}




/*******************************************/
/*** DISTRIBUTED typedef / struct / enum ***/
/*******************************************/

DataDistributedTypedef
parseDistributedTypedef ( ) :
{
  DataDistributedTypedef        thisTypedef = new DataDistributedTypedef();
  DataDistributedDeclarationSet thisDataDistributedDeclarationSet;
  Token                         token;
}
{
  (
   token = <DISTRIBUTED>
      {
	parseFluff ( thisTypedef, token, 0 );
	thisTypedef . setIndex( DataDistributedTypedef.DISTRIBUTED );
      }

    token = <TYPEDEF>
      {
	parseFluff ( thisTypedef, token, 0 );
	thisTypedef . setIndex( DataDistributedTypedef.TYPEDEF );
      }


        /* DataTaskArguments, via DataDistributedDeclarationSet,       *
	 * while not being designed for this purpose, are nevertheless *
	 * ideally suited toward it.                                   */
    thisDataDistributedDeclarationSet = parseDistributedDeclarationSet ( null )
      {
	thisTypedef . setIndex ( DataDistributedTypedef.DECLARATION );
	thisTypedef
	 . setDataDistributedDeclarationSet(thisDataDistributedDeclarationSet);
      }
  )
    { return thisTypedef; }
}




DataDistributedStruct
parseDistributedStruct ( DataDistributedStruct theDataDistributedStruct ) :
{
  DataDistributedStruct         thisStruct
				  = (   ( theDataDistributedStruct != null )
				      ?   theDataDistributedStruct
				      :  new DataDistributedStruct() );

  Token                         token;
}
{
  (
    token = <DISTRIBUTED>
      {
	parseFluff ( thisStruct, token, 0 );
	thisStruct . setIndex( DataDistributedStruct.DISTRIBUTED );
      }
    
    parseDistributedStructInternal ( thisStruct )

    token = <SEMICOLON>
      {
	parseFluff ( thisStruct, token, 0 );
	thisStruct . setIndex( DataDistributedStruct.SEMICOLON );
      }
  )
    { return thisStruct; }
}


DataDistributedStruct
parseDistributedStructInternal (
			     DataDistributedStruct theDataDistributedStruct ) :
{
  DataDistributedStruct         thisStruct
				  = (   ( theDataDistributedStruct != null )
				      ?   theDataDistributedStruct
				      :  new DataDistributedStruct() );

  DataDistributedDeclarationSet dataDistributedDeclarationSet;
  int                           declarationCount = 0;
  Token                         token;
}
{
  (
    token = <STRUCT>
      {
	parseFluff ( thisStruct, token, 0 );
	thisStruct . setIndex( DataDistributedStruct.STRUCT );
      }

    [ token = parseIdToken()
        {
	  parseFluff ( thisStruct, token, 0 );
	  thisStruct . setStructName ( token.image );
	  thisStruct . setIndex ( DataDistributedStruct.NAME_INDEX );
	}
    ]

    token = <OPEN_BRACE>
      {
	parseFluff ( thisStruct, token, 0 );
	thisStruct . setIndex ( DataDistributedStruct.OPEN_BRACE );
      }


    (   /* DataTaskArguments, via DataDistributedDeclarationSet,       *
	 * while not being designed for this purpose, are nevertheless *
	 * ideally suited toward it.                                   */
      dataDistributedDeclarationSet = parseDistributedDeclarationSet ( null )
        {
	  thisStruct . setIndex ( DataDistributedStruct.DECLARATION
				  + (declarationCount ++) );
	  thisStruct . addDataDistributedDeclarationSet (
				  dataDistributedDeclarationSet );
	}
    )+

    token = <CLOSE_BRACE>
      {
	parseFluff ( thisStruct, token, 0 );
	thisStruct . setIndex( DataDistributedStruct.CLOSE_BRACE );
      }
  )
    { return thisStruct; }
}



DataDistributedEnumEntry
parseDataDistributedEnumEntry (
		       DataDistributedEnumEntry theDataDistributedEnumEntry ) :
{
  DataDistributedEnumEntry  thisEnumEntry
			      = (   ( theDataDistributedEnumEntry != null )
				  ?   theDataDistributedEnumEntry
				  :  new DataDistributedEnumEntry() );

  Token                     token, equalsToken;
  DataExpression            dataExpression;
}
{
  (
    token = parseIdToken()
      {
	parseFluff ( thisEnumEntry, token, 0 );
	thisEnumEntry . setId ( token.image );
	thisEnumEntry . setIndex ( DataDistributedEnumEntry.ID );
      }

    [ LOOKAHEAD ( <EQUAL>
                  parseConstantExpression()
                )

      equalsToken = <EQUAL>
        {
	  parseFluff ( thisEnumEntry, equalsToken, 0 );
	  thisEnumEntry . setIndex ( DataDistributedEnumEntry.EQUALS );
	}

	/* Note:  Don't use an "| <INTEGER_CONSTANT>" construct here.
	 * It messes up the lookahead at a higher level.
	 * (Instead, check for singleton "<INTEGER_CONSTANT>" manually.)
	 */
      parseConstantExpression()
        {
		/* If this was a single <INTEGER_CONSTANT> */
	  if (   ( equalsToken    . next == getToken ( 0 )   )
	      && ( getToken ( 0 ) . kind == INTEGER_CONSTANT ) )
	  {
            parseFluff ( thisEnumEntry, getToken(0), 0 );
	    thisEnumEntry . setIndex ( DataDistributedEnumEntry.EQUALS_VALUE );
	    thisEnumEntry . setPositiveIntegerEqualsString (getToken(0).image);
	  }
	  else
	  {
	    dataExpression = new DataExpression();
	    parseMiscTokens ( dataExpression, equalsToken, 0 );

	    thisEnumEntry . setIndex( DataDistributedEnumEntry.EQUALS_VALUE);
	    thisEnumEntry . setGeneralEqualsExpression ( dataExpression );
	  }
	}
    ]
  )
    { return thisEnumEntry; }
}


DataDistributedEnum
parseDistributedEnum ( DataDistributedEnum theDataDistributedEnum ) :
{
  DataDistributedEnum  thisEnum = (   ( theDataDistributedEnum != null )
				    ?   theDataDistributedEnum
				    :  new DataDistributedEnum() );

  DataDistributedEnumEntry     dataDistributedEnumEntry;
  int                          enumEntryCount = 0;
  Token                        token;
}
{
  (
    token = <DISTRIBUTED>
      {
	parseFluff ( thisEnum, token, 0 );
	thisEnum . setIndex( DataDistributedEnum.DISTRIBUTED );
      }

    parseDistributedEnumInternal ( thisEnum )

    token = <SEMICOLON>
      {
	parseFluff ( thisEnum, token, 0 );
	thisEnum . setIndex ( DataDistributedEnum.SEMICOLON );
      }
  )
    { return thisEnum; }
}


DataDistributedEnum
parseDistributedEnumInternal ( DataDistributedEnum theDataDistributedEnum ) :
{
  DataDistributedEnum  thisEnum = (   ( theDataDistributedEnum != null )
				    ?   theDataDistributedEnum
				    :  new DataDistributedEnum() );

  DataDistributedEnumEntry     dataDistributedEnumEntry;
  int                          enumEntryCount = 0;
  Token                        token;
}
{
  (
    token = <ENUM>
      {
	parseFluff ( thisEnum, token, 0 );
	thisEnum . setIndex( DataDistributedEnum.ENUM );
      }

    [ token = parseIdToken()
        {
	  parseFluff ( thisEnum, token, 0 );
	  thisEnum . setEnumName ( token.image );
	  thisEnum . setIndex ( DataDistributedEnum.NAME_INDEX );
	}
    ]

    token = <OPEN_BRACE>
      {
	parseFluff ( thisEnum, token, 0 );
	thisEnum . setIndex ( DataDistributedEnum.OPEN_BRACE );
      }


    dataDistributedEnumEntry = parseDataDistributedEnumEntry ( null )
      {
	thisEnum . setIndex ( DataDistributedEnum.ENUM_ENTRY
			      + (enumEntryCount ++) );
	thisEnum . addDataDistributedEnumEntry ( dataDistributedEnumEntry );
      }


    (
      token = <COMMA>
        {
	  parseFluff ( thisEnum, token, 0 );
	  thisEnum . setIndex ( DataDistributedEnum.COMMA + enumEntryCount );
	}

      dataDistributedEnumEntry = parseDataDistributedEnumEntry ( null )
        {
	  thisEnum . setIndex ( DataDistributedEnum.ENUM_ENTRY
				+ (enumEntryCount ++) );
	  thisEnum . addDataDistributedEnumEntry ( dataDistributedEnumEntry );
	}
    )*


    token = <CLOSE_BRACE>
      {
	parseFluff ( thisEnum, token, 0 );
	thisEnum . setIndex ( DataDistributedEnum.CLOSE_BRACE );
      }
  )
    { return thisEnum; }
}


/******************************/
/*** Class/Struct/Namespace ***/
/******************************/

DataClassStructNamespace
parseStartDataClassStructNamespace (
		      DataClassStructNamespace  theDataClassStructNamespace ) :
{
  Token                    token = getToken(0);
  DataClassStructNamespace thisDataClassStructNamespace
                                  = (   ( theDataClassStructNamespace != null )
				      ?   theDataClassStructNamespace 
				      :  new DataClassStructNamespace() );
  thisDataClassStructNamespace . setIsStart();
}
{
  (
     ( <CLASS> | <STRUCT> | <NAMESPACE> )

     parseIdToken()

     [ parseBaseSpec() ]

     <OPEN_BRACE>
  )
    { 
      parseMiscTokens ( thisDataClassStructNamespace, token, 0 );
      return thisDataClassStructNamespace;
    }
}

DataClassStructNamespace
parseEndDataClassStructNamespace (
		       DataClassStructNamespace theDataClassStructNamespace,
		       String                   theCorrespondingStart       ) :
{
  Token token;
  DataClassStructNamespace thisDataClassStructNamespace
                                  = (   ( theDataClassStructNamespace != null )
				      ?   theDataClassStructNamespace 
				      :  new DataClassStructNamespace() );
  thisDataClassStructNamespace . setIsEnd();
  thisDataClassStructNamespace
    . setCorrespondingStartString ( theCorrespondingStart );
}
{
  (
     token = <CLOSE_BRACE>
       {
	 parseFluff ( thisDataClassStructNamespace, token, 0 );
	 thisDataClassStructNamespace . addSubcomponent ( token.image );
       }

     token = <SEMICOLON>
       {
	 parseFluff ( thisDataClassStructNamespace, token, 0 );
	 thisDataClassStructNamespace . addSubcomponent ( token.image );
       }
  )
    { return thisDataClassStructNamespace; }
}




/***********************/
/*** Task Definition ***/
/***********************/

DataTaskDefinition
parseFullTaskDefinition ( DataTaskDefinition theDataTaskDefinition,
			  boolean            theInsideClassStruct   ) :
{
  DataTaskDefinition     returnValue;
  DataCompoundStatement  dataCompoundStatement;
  DataTaskDefinition     thisTask = (   ( theDataTaskDefinition != null )
				      ?   theDataTaskDefinition 
				      :  new DataTaskDefinition() );
}
{
  ( 
      returnValue = parseExternTaskDefinition( thisTask, theInsideClassStruct )

    | ( LOOKAHEAD ( 6 ) /* Deal with: "<EXCEPTION> <HANDLER>"     and       *
			 * [<distributed>] [<persistent>] [<threaded>] GOAL */

	  ( returnValue
	          = parseActualTaskDefinition_Rest ( thisTask,
						     theInsideClassStruct )
	      { setParsingTask ( returnValue ); }
	     
	    dataCompoundStatement = parseCompoundStatement ( 0 )
	      {
		clearParsingTask();
		returnValue . setTaskBody ( dataCompoundStatement );
	      }
	  )

	| returnValue
	        = parseActualTaskDefinition_Exception ( thisTask,
							theInsideClassStruct )
      )
  )
    { return returnValue; }
}


DataTaskDefinition
parseTaskDefinitionHead ( DataTaskDefinition theDataTaskDefinition ) :
{
  DataTaskDefinition  returnValue;
  DataTaskDefinition  thisTask = (   ( theDataTaskDefinition != null )
				   ?   theDataTaskDefinition 
				   :  new DataTaskDefinition() );
}
{
  (
      returnValue = parseExternTaskDefinition ( thisTask, false )

    | ( LOOKAHEAD ( 6 ) /* Deal with: "<EXCEPTION> <HANDLER>"     and       *
			 * [<distributed>] [<persistent>] [<threaded>] GOAL */

	  returnValue = parseActualTaskDefinition_Rest ( thisTask, false )

	| returnValue = parseActualTaskDefinition_Exception ( thisTask, false )
      )
  )
    { return returnValue; }
}


DataTaskDefinition
parseExternTaskDefinition ( DataTaskDefinition theDataTaskDefinition,
			    boolean            theInsideClassStruct  ) :
{
  Token               token;
  DataTaskDefinition  thisTask = (   ( theDataTaskDefinition != null )
				   ?   theDataTaskDefinition 
				   :  new DataTaskDefinition() );
}
{
  (  
    ( token = <EXTERN_CS>  |  token = <EXTERN_CI> )
        { 
	  if ( thisTask . addExternKeywordToTaskLeadsOrder() == false )
	  {
	    throw generateParseException ( token,
				"Task may NOT have more than one "
				+ "\"EXTERN\" keyword." );
	  }
	  parseFluff ( thisTask, token, 0 );
	  thisTask . setIndex ( DataTaskDefinition.EXTERN );
	}


    (
        parseTaskDefinitionInternal_Task    ( thisTask, theInsideClassStruct )
      | parseTaskDefinitionInternal_Goal    ( thisTask, theInsideClassStruct )
      | parseTaskDefinitionInternal_Command ( thisTask, theInsideClassStruct )
      | parseTaskDefinitionInternal_Monitor ( thisTask, theInsideClassStruct )
      | parseTaskDefinitionInternal_Resume  ( thisTask, theInsideClassStruct )
      | ( LOOKAHEAD ( 2 )
	    parseTaskDefinitionInternal_Handler   ( thisTask,
						    theInsideClassStruct )
	  | parseTaskDefinitionInternal_Exception ( thisTask,
						    theInsideClassStruct )
	)
    )

    token = <SEMICOLON>
      {
	parseFluff ( thisTask, token, 0 );
	thisTask . setIndex ( DataTaskDefinition.SEMICOLON );
      }
  )
    { return thisTask; }
}



DataTaskDefinition
parseActualTaskDefinition_Exception (
				   DataTaskDefinition theDataTaskDefinition,
				   boolean            theInsideClassStruct  ) :
{
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
				  ?   theDataTaskDefinition 
				  :  new DataTaskDefinition() );
  DataSpawnTask      exceptionBaseTask;
  Token              token;
  DataConstraint     formatDataConstraint;

  thisTask . setIsExtern ( false );
}
{
  (
      ( [ parseTaskDefinitionInternal_TaskLeads_Static ( thisTask,
							 theInsideClassStruct )
	]

	(
          parseTaskDefinitionInternal_DistributedException( thisTask,
	                                                 theInsideClassStruct )

	| parseTaskDefinitionInternal_Exception( thisTask,
                                                 theInsideClassStruct )
        )
		/* Allow optional exception superclass */
	[ LOOKAHEAD ( <COLON> parseSpawnTask_ScopedTaskOnly ( null, 0 ) )

	  token = <COLON>
	    {
	      parseFluff ( thisTask, token, 0 );
	      thisTask . setIndex ( DataTaskDefinition.COLON );
	    }

	  exceptionBaseTask = parseSpawnTask_ScopedTaskOnly ( null, 0 )
	    {
	      thisTask . setExceptionBaseTask ( exceptionBaseTask );
	    }
	]


	[
	  [ parseTaskDefinitionWith ( thisTask )
	  ]

	  formatDataConstraint = parseFormatConstraint ( null, 0 )
	    {
	      thisTask . addConstraint ( formatDataConstraint );
	      if ( getToken ( 1 ) . kind != SEMICOLON )
	      {
		throw generateParseException ( getToken(1),
		    "Next token should have been a SEMICOLON.  "
		  + "Instead found \"" + getToken(1).image + "\"." );
	      }
	    }
	]


		/* Exceptions must be followed by a semicolon. */
	token = <SEMICOLON>
	  {
	    parseFluff ( thisTask, token, 0 );
	    thisTask . setIndex ( DataTaskDefinition.SEMICOLON );
	  }
      ) /* Exceptions */

  )
    { return thisTask; }
}



DataTaskDefinition
parseActualTaskDefinition_Rest ( DataTaskDefinition theDataTaskDefinition,
				 boolean            theInsideClassStruct  ) :
{
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
				  ?   theDataTaskDefinition 
				  :  new DataTaskDefinition() );
  DataConstraint     dataConstraint;
  DataSpawnTask      exceptionBaseTask;
  Token              token;

  thisTask . setIsExtern ( false );
}
{
  (

      (  /* Leave this here to generate a "nicer" exception...            */
         /* Exception generated in parseTaskDefinitionInternals_Rest(...) */
        parseTaskDefinitionInternal_Task ( thisTask, theInsideClassStruct )
      ) /* Tasks */


    | ( LOOKAHEAD ( 6 ) /* Deal with:                                      *
			 * [<distributed>] [<persistent>] [<threaded>] ... */

	 (
		/* Note: Parses static/virtual too. */
	   [ parseTaskDefinitionInternal_TaskLeads_All ( thisTask,
							 theInsideClassStruct )
	   ]

	   (
	       ( /* Goals/Commands */

		 (   parseTaskDefinitionInternal_Goal   ( thisTask,
							  theInsideClassStruct)
		   | parseTaskDefinitionInternal_Command( thisTask,
							  theInsideClassStruct)
		 )

		 [
		   [ parseTaskDefinitionWith ( thisTask )
		   ]

			/* Allow optional simple constraints only *
			 * for Goals or Commands.                 */
		   parseSimpleConstraintOrPersistentOrFormatAndTrailingFluff (
								     thisTask )

		   ( <COMMA> /* Comma fluff is dealt with in              *
			      * parseSimpleConstraint....AndTrailingFluff */

		     parseSimpleConstraintOrPersistentOrFormatAndTrailingFluff(
								     thisTask )
		   )*
		 ]
	       ) /* Goals/Commands */




	     | ( /* Monitors */
		 parseTaskDefinitionInternal_Monitor ( thisTask,
						       theInsideClassStruct )

		 [
		   [ parseTaskDefinitionWith ( thisTask )
		   ]

			    /* Allow optional monitor constraints only *
			     * for Monitors                            */
		   parseMonitorConstraintOrPersistentOrFormatAndTrailingFluff(
								     thisTask )

		   ( <COMMA> /* Comma fluff is dealt with in               *
			      * parseMonitorConstraint....AndTrailingFluff */

		    parseMonitorConstraintOrPersistentOrFormatAndTrailingFluff(
								     thisTask )
		   )*
		 ]
	       ) /* Monitors */
	   )
	 )



       | (
		/* Handler & Resume can both have Static/Virtual */
	   [ parseTaskDefinitionInternal_TaskLeads_Static_Virtual_All (
							 thisTask,
							 theInsideClassStruct )
	   ]

	   (
	     ( /* Exception Handlers */

	       parseTaskDefinitionInternal_Handler ( thisTask,
						     theInsideClassStruct )

	       [ parseTaskDefinitionWith ( thisTask )
	       ]

	       (   /* Allow optional handler constraints here */
		 parseHandlerConstraintOrPersistentOrFormatAndTrailingFluff (
								     thisTask )

		 <COMMA> /* Comma fluff is dealt with in               *
			  * parseHandlerConstraint....AndTrailingFluff */
	       )*

			/* Require exception handler "handles" clause */
	       token = <HANDLES>
	         {
		   parseFluff ( thisTask, token, 0 );
		   thisTask . setIndex ( DataTaskDefinition.HANDLES );
		 }

	       token = parseIdToken()
	         {
		   parseFluff ( thisTask, token, 0 );
		   thisTask . setIndex ( DataTaskDefinition.HANDLES_INDEX );
		   thisTask . setHandlesException ( token.image );
		 }

	       [   /* Allow optional constraints here */
		 token = <COMMA>
		   {
		     parseFluff ( thisTask, token, 0 );
		     thisTask
		     . setIndex ( DataTaskDefinition.HANDLES_COMMA_INDEX );
		   }

			/* Allow optional handler constraints here */
		 parseHandlerConstraintOrPersistentOrFormatAndTrailingFluff (
								     thisTask )

		 ( <COMMA> /* Comma fluff is dealt with in               *
			    * parseHandlerConstraint....AndTrailingFluff */

		   parseHandlerConstraintOrPersistentOrFormatAndTrailingFluff(
								     thisTask )
		 )*
	       ]

	     ) /* Exception Handlers */



	   | (   /* Resume */

	       parseTaskDefinitionInternal_Resume ( thisTask,
						    theInsideClassStruct )

	       /* Note:  No constraints available for RESUME Tasks. */

	     ) /* Resume (from postpone) tasks (routines) */

           ) /* Handler | Resume */

	 ) /* Not Goal/Command/Monitor, choosing Handler/Resume */

      ) /* LOOKAHEAD(6) -- Dealing with: [<distributed>] [<persistent>] ... */
  )
    {
	/* TASK_BODY_INDEX doesn't really do much anymore.               *
	 * Its functionality has been superseded by HANDLES_COMMA_INDEX. */
      thisTask . setIndex ( DataTaskDefinition.TASK_BODY_INDEX );
      return thisTask;
    }
}




DataTaskDefinition
parseTaskDefinitionInternal_TaskLeads_Static (
				   DataTaskDefinition theDataTaskDefinition,
				   boolean            theInsideClassStruct  ) :
{
  String             taskIndex;
  Token              token;
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
				  ?   theDataTaskDefinition 
				  :  new DataTaskDefinition() );
}
{
  (
    (
        token = <STATIC_CS>   { taskIndex = DataTaskDefinition.STATIC;      }
      | token = <STATIC_CI>   { taskIndex = DataTaskDefinition.STATIC;      }
    )
      {
	if ( theInsideClassStruct == false )
	  throw generateParseException ( token,
		      "Task may only be STATIC inside a class or struct." );

	if ( thisTask . getIsVirtual() )
	  throw generateParseException ( token,
				  "Task may NOT be both VIRTUAL and STATIC." );

	if ( thisTask . addToTaskLeadsKeywordOrder(taskIndex) == false )
	  throw generateParseException ( token,
				         "Task may NOT have more than one "
					 + "\"" + token.image + "\" keyword.");

	parseFluff ( thisTask, token, 0 );
	thisTask . setIndex ( taskIndex );
      }
  )
    { return thisTask; }
}

DataTaskDefinition
parseTaskDefinitionInternal_TaskLeads_Virtual (
				   DataTaskDefinition theDataTaskDefinition,
				   boolean            theInsideClassStruct  ) :
{
  String             taskIndex;
  Token              token;
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
				  ?   theDataTaskDefinition 
				  :  new DataTaskDefinition() );
}
{
  (
    (
        token = <VIRTUAL_CS>  { taskIndex = DataTaskDefinition.VIRTUAL;     }
      | token = <VIRTUAL_CI>  { taskIndex = DataTaskDefinition.VIRTUAL;     }
    )
      {
	if ( theInsideClassStruct == false )
	  throw generateParseException ( token,
		      "Task may only be VIRTUAL inside a class or struct." );

	if ( thisTask . getIsStatic() )
	  throw generateParseException ( token,
				  "Task may NOT be both STATIC and VIRTUAL." );

	if ( thisTask . addToTaskLeadsKeywordOrder(taskIndex) == false )
	  throw generateParseException ( token,
				         "Task may NOT have more than one "
					 + "\"" + token.image + "\" keyword.");

	parseFluff ( thisTask, token, 0 );
	thisTask . setIndex ( taskIndex );
      }
  )
    { return thisTask; }
}


DataTaskDefinition
parseTaskDefinitionInternal_TaskLeads_Distributed_Persistent_Threaded (
				   DataTaskDefinition theDataTaskDefinition ) :
{
  String             taskIndex;
  Token              token;
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
				  ?   theDataTaskDefinition 
				  :  new DataTaskDefinition() );
}
{
  (
    (
        token = <DISTRIBUTED> { taskIndex = DataTaskDefinition.DISTRIBUTED; }
      | token = <PERSISTENT>  { taskIndex = DataTaskDefinition.PERSISTENT;  }
      | token = <THREADED>    { taskIndex = DataTaskDefinition.THREADED;    }
    )
      {
	if ( thisTask . addToTaskLeadsKeywordOrder(taskIndex) == false )
	  throw generateParseException ( token,
				         "Task may NOT have more than one "
					 + "\"" + token.image + "\" keyword.");

	parseFluff ( thisTask, token, 0 );
	thisTask . setIndex ( taskIndex );
      }
  )
    { return thisTask; }
}


DataTaskDefinition
parseTaskDefinitionInternal_TaskLeads_Static_Virtual_All (
				   DataTaskDefinition theDataTaskDefinition,
				   boolean            theInsideClassStruct  ) :
{
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
				  ?   theDataTaskDefinition 
				  :  new DataTaskDefinition() );
}
{
  (
    (   parseTaskDefinitionInternal_TaskLeads_Static  ( theDataTaskDefinition,
							theInsideClassStruct  )
      | parseTaskDefinitionInternal_TaskLeads_Virtual ( theDataTaskDefinition,
							theInsideClassStruct  )
    )+
  )
    { return thisTask; }
}


DataTaskDefinition
parseTaskDefinitionInternal_TaskLeads_All (
				   DataTaskDefinition theDataTaskDefinition,
				   boolean            theInsideClassStruct  ) :
{
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
				  ?   theDataTaskDefinition 
				  :  new DataTaskDefinition() );
}
{
  (
    (
        parseTaskDefinitionInternal_TaskLeads_Static  ( theDataTaskDefinition,
							theInsideClassStruct  )
      | parseTaskDefinitionInternal_TaskLeads_Virtual ( theDataTaskDefinition,
							theInsideClassStruct  )
      | parseTaskDefinitionInternal_TaskLeads_Distributed_Persistent_Threaded(
							theDataTaskDefinition )
    )+
  )
    { return thisTask; }
}




void
parseTaskDefinitionInternal_Task ( DataTaskDefinition theDataTaskDefinition,
				   boolean            theInsideClassStruct  ) :
{
  Token  token;
}
{
  ( token = <TASK>

    parseTaskDefinitionInternals_Rest ( theDataTaskDefinition,
					DataTaskDefinition.TASK_TASK,
					token, null, theInsideClassStruct )
  )
    {}
}

void
parseTaskDefinitionInternal_Goal ( DataTaskDefinition theDataTaskDefinition,
				   boolean            theInsideClassStruct  ) :
{
  Token  token;
}
{
  ( token = <GOAL>

    parseTaskDefinitionInternals_Rest ( theDataTaskDefinition,
					DataTaskDefinition.GOAL_TASK,
					token, null, theInsideClassStruct )
  )
    {}
}

void
parseTaskDefinitionInternal_Command(DataTaskDefinition theDataTaskDefinition,
				    boolean            theInsideClassStruct ) :
{
  Token  token;
}
{
  ( token = <COMMAND>

    parseTaskDefinitionInternals_Rest ( theDataTaskDefinition,
					DataTaskDefinition.COMMAND_TASK,
					token, null, theInsideClassStruct )
  )
    {}
}

void
parseTaskDefinitionInternal_Monitor(DataTaskDefinition theDataTaskDefinition,
				    boolean            theInsideClassStruct ) :
{
  Token  token;
}
{
  ( token = <MONITOR>

    parseTaskDefinitionInternals_Rest ( theDataTaskDefinition,
					DataTaskDefinition.MONITOR_TASK,
					token, null, theInsideClassStruct )
  )
    {}
}

void
parseTaskDefinitionInternal_Exception (
				   DataTaskDefinition theDataTaskDefinition,
				   boolean            theInsideClassStruct  ) :
{
  Token  token;
}
{
  ( token = <EXCEPTION>

    parseTaskDefinitionInternals_Rest ( theDataTaskDefinition,
					DataTaskDefinition.EXCEPTION_TASK,
					token, null, theInsideClassStruct )
  )
    {}
}

void
parseTaskDefinitionInternal_DistributedException (
				   DataTaskDefinition theDataTaskDefinition,
				   boolean            theInsideClassStruct  ) :
{
}
{
  ( token = <DISTRIBUTED>
       { 
         parseFluff ( theDataTaskDefinition, token, 0 );
	 if ( !theDataTaskDefinition . addToTaskLeadsKeywordOrder(
				             DataTaskDefinition.DISTRIBUTED ) )
	   throw generateParseException ( token,
		 		          "Task may NOT have more than one "
					  + "\"DISTRIBUTED\" keyword.");
	 theDataTaskDefinition . setIndex( DataTaskDefinition.DISTRIBUTED );
       }

    parseTaskDefinitionInternal_Exception ( theDataTaskDefinition,
					    theInsideClassStruct )
  )
    {}
}

void
parseTaskDefinitionInternal_Handler(DataTaskDefinition theDataTaskDefinition,
				    boolean            theInsideClassStruct ) :
{
  Token  token;
  Token  token2 = null;
}
{
  (
    ( 
        ( token2 = <EXCEPTION>
	  token  = <HANDLER>
	)

      | token = <HANDLER>
    )

    parseTaskDefinitionInternals_Rest ( theDataTaskDefinition,
					DataTaskDefinition.HANDLER_TASK,
					token, token2, theInsideClassStruct )
  )
    {}
}

void
parseTaskDefinitionInternal_Resume (DataTaskDefinition theDataTaskDefinition,
				    boolean            theInsideClassStruct ) :
{
  Token  token;
}
{
  ( token = <RESUME>

    parseTaskDefinitionInternals_Rest ( theDataTaskDefinition,
					DataTaskDefinition.RESUME_TASK,
					token, null, theInsideClassStruct )
  )
    {}
}



void
parseTaskDefinitionInternals_Rest ( DataTaskDefinition theDataTaskDefinition,
				    int                theTaskType,
				    Token              token,
				    Token              token2,
				    boolean            theInsideClassStruct ) :
{
  DataTaskArgument  tmpDataTaskArgument = null;

	/************************************/
	/* Handle Parsing of token / token2 */
	/************************************/

  theDataTaskDefinition . setTaskType ( theTaskType );

		/* Only parse "Task" Tasks when we are external... */
  if (    ( token.kind == TASK )
       && ( theDataTaskDefinition . getIsExtern() == false ) )
  {
    throw generateParseException ( token,
				     "Can only use Task-Type of "
				   + "\"Task\" with extern tasks." );
  }
  if ( token2 != null )
  {
    parseFluff ( theDataTaskDefinition, token2, 0 );
    theDataTaskDefinition . setIndex ( DataTaskDefinition.TASK_TYPE_INDEX
				       + "0" );
  }
  parseFluff ( theDataTaskDefinition, token, 0 );
  theDataTaskDefinition . setIndex( DataTaskDefinition.TASK_TYPE_INDEX );
}
{
  (
    token = parseTaskScopeAndName ( theDataTaskDefinition,
				    theInsideClassStruct  )
      {
	parseFluff ( theDataTaskDefinition, token, 0 );
	theDataTaskDefinition
          . setTaskNameWithoutParsingOrRegistration ( token.image );
	theDataTaskDefinition . setIndex( DataTaskDefinition.TASK_NAME_INDEX );
	theDataTaskDefinition . setLineNumber ( token.beginLine + 1 );
      }

    token = <OPEN_PAREN>
      {
	parseFluff ( theDataTaskDefinition, token, 0 );
	theDataTaskDefinition . setIndex ( DataTaskDefinition.OPEN_PAREN );
      }

    (   LOOKAHEAD ( (<VOID>)? <CLOSE_PAREN> )
        (
	  [ 
	    token = <VOID>
	      {
		parseFluff ( theDataTaskDefinition, token, 0 );
		theDataTaskDefinition . addSubcomponent ( token.image );
	      }
	  ]

          token = <CLOSE_PAREN>
	    {
	      parseFluff ( theDataTaskDefinition, token, 0 );
	    }
        )
      |
        (
	  tmpDataTaskArgument = parseTaskArgument ( null )
	    {
	      theDataTaskDefinition . addTaskArgument ( tmpDataTaskArgument );
	    }

	  ( <COMMA>     /* parseTaskArgument() dealt with this token's fluff */

	    tmpDataTaskArgument = parseTaskArgument ( null )
	      {
		theDataTaskDefinition . addTaskArgument( tmpDataTaskArgument );
	      }
	  )*

	  <CLOSE_PAREN> /* parseTaskArgument() dealt with this token's fluff */
        )
    )
      {
	theDataTaskDefinition . setIndex ( DataTaskDefinition.CLOSE_PAREN );
      }
  )
    { }
}



	/* Parses the scoping, return the Identifier Token untouched. */
Token
parseScopedIdentifier ( DataScope theDataScope ) :
{
  Token         identifierToken, scopeToken;
  int           scopeCount = 0;

  if ( theDataScope == null )
  {
    throw generateParseException (
       getToken(1),
       "Internal Programmer Error:  parseScopedIdentifier() invoked with NULL "
       + "value for theDataScope." );
  }

  theDataScope . clearAllScopes();
}
{
  (
    identifierToken = parseIdToken()

    ( scopeToken = <SCOPE>
        {
	  parseFluff ( theDataScope, identifierToken, 0 );
	  theDataScope . addScope  ( identifierToken.image );
	  theDataScope . setIndex  ( DataScope.IDENTIFIER_INDEX + scopeCount );

	  parseFluff ( theDataScope, scopeToken, 0 );
	  theDataScope . setIndex  ( DataScope.SCOPE + scopeCount );

	  scopeCount ++;
        }

      identifierToken = parseIdToken()

    )*
  )
    { return identifierToken; }
}


Token
parseTaskScopeAndName ( DataTaskDefinition theDataTaskDefinition,
			boolean            theInsideClassStruct  ) :
{
  Token               taskNameToken;
  DataTaskDefinition  previouslyRegisteredTask;
  DataScope           dataScope = ( ( theDataTaskDefinition != null )
				   ?  theDataTaskDefinition . getTaskScope()
				   :  new DataScope() );
}
{
  (
    taskNameToken = parseScopedIdentifier ( dataScope )
  )
    {
	/* Note:  We now permit multiple tasks to be registered under the
	 * same name.  However:  Overloading of exception tasks is prohibited.
	 * The types must match.  And the Distributed/Non-Distributed
	 * nature must match.
	 *
	 * Caveat:  This functionality occurs in two places.  Here and in
	 * DataTaskDefinition.registerTask(DataTaskDefinition).  The code
	 * here is only invoked after the tasks are registered, which currently
	 * only occurs after the entire file is read and parsed...  It is still
	 * useful in the event one is parsing multiple files, and registering
	 * tasks inbetween them.  But, by and large, this code is
	 * NEVER ACTUALLY UTILIZED.
	 */

      previouslyRegisteredTask
        = DataTaskDefinition.getFirstTaskForName (
	    dataScope . getAllScopeStrings() + taskNameToken . image );

      if ( theDataTaskDefinition != null )
      {
	if ( previouslyRegisteredTask != null )
	{
		/* Check for overloaded exception tasks */
	  if (   (    previouslyRegisteredTask . getTaskType()
		   == DataTaskDefinition.EXCEPTION_TASK        )
	      || (    theDataTaskDefinition    . getTaskType()
		   == DataTaskDefinition.EXCEPTION_TASK        ) )
	  {
	    throw generateParseException (
	    taskNameToken,
	      "TASK \"" + taskNameToken . image + "\" is both overloaded and "
	    + "of type \"Exception\".  Overloading is not permitted for "
	    + "\"Exception\" tasks.  "
	    + "Please choose another name for this task." );
	  }

		/* Check for Task-Type disagreement */
	  if (   previouslyRegisteredTask . getTaskType()
	      != theDataTaskDefinition    . getTaskType() )
	  {
	    throw generateParseException (
	    taskNameToken,
	      "TASK \"" + taskNameToken . image + "\" is of type \""
	    + theDataTaskDefinition . getTaskTypeString()
	    + "\".  Task \"" + taskNameToken . image
	    + "\" is overloaded, and was previously declared (registered) "
	    + "under type \""
	    + previouslyRegisteredTask . getTaskTypeString()
	    + "\".  These Task-Types are supposed to be the same, as one of "
	    + "these Tasks will wind up being allocated with the other's "
	    + "Task-Type, creating issues with constraint satisfaction.  "
	    + "Please choose another name for this task, "
	    + "or make both of them the same Task-Type." );
	  }

		/* Check for Distributed/Non-Distributed disagreement.
		 * (For now, assume theDataTaskDefinition will have already
		 *  had its DISTRIBUTED flag set/unset appropriately.)
		 */
	  if (   previouslyRegisteredTask . getIsDistributed()
	      != theDataTaskDefinition    . getIsDistributed() )
	  {
	    throw generateParseException (
	    taskNameToken,
	      "TASK \"" + taskNameToken . image + "\" is \""
	    + (theDataTaskDefinition    . getIsDistributed() ? "" : "NON-")
	    + "DISTRIBUTED\".  Task \"" + taskNameToken . image
	    +"\" is overloaded, and was previously declared (registered) as \""
	    + (previouslyRegisteredTask . getIsDistributed() ? "" : "NON-")
	    + "DISTRIBUTED\".  This DISTRIBUTED nature must be the "
	    + "same between overloaded tasks, as one of these Tasks will wind "
	    + "up being allocated with the other's DISTRIBUTED/NON-DISTRIBUTED"
	    + " allocation function, with the associated problems.  "
	    + "Please choose another name for this task, make both of them "
	    + "\"DISTRIBUTED\", or make both of them \"NON-DISTRIBUTED\"." );
	  }
	} /* if ( previouslyRegisteredTask != null ) */



	  /* Note: Place this here so the error message makes sense... */
	if ( theDataTaskDefinition . getTaskScope() . hasScope() )
	{
	  if ( theInsideClassStruct )
	  {
	    throw generateParseException (
	      taskNameToken,
	      "TASK \"" + taskNameToken . image + "\" is both scoped and "
	      + "inside a class/struct.  This is not permitted."
	      + "It may be scoped or inside a class/struct, but not both." );
	  }

	  theDataTaskDefinition . setWasExplicitlyScoped();
	}

      } /* if ( theDataTaskDefinition != null ) */

      return taskNameToken;
    }
}





void
parseTaskDefinitionWith ( DataTaskDefinition theDataTaskDefinition ) :
{
  Token  withToken;
}
{
  ( withToken = <WITH>
      {
	theDataTaskDefinition . setHasWithKeyword ( true );
	parseFluff ( theDataTaskDefinition, withToken, 0 );
	theDataTaskDefinition . setIndex ( theDataTaskDefinition.WITH );
      }
  )
    {}
}



DataComponent
parsePersistentTaskData ( DataTaskDefinition theDataTaskDefinition ) :
{
  DataTaskArgument  dataTaskArgument = null;
  Token             token;
}
{
  ( token = <PERSISTENT>
      {
	dataTaskArgument = new DataTaskArgument();
	parseFluff ( dataTaskArgument, token, 0 );
	dataTaskArgument . setIndex ( DataTaskArgument.PERSISTENT );
	dataTaskArgument . setIsPersistentDeclaration ( true );
      }

    parseTaskArgumentNoFormat ( dataTaskArgument )
      {
	theDataTaskDefinition
	  . addPersistentTaskDeclaration ( dataTaskArgument );
      }
  )
    { return dataTaskArgument; }
}



DataConstraint
parseFormatConstraint ( DataConstraint  theDataConstraint,
			int             theUnIndent        ) :
{
  DataConstraint      thisConstraint = (   ( theDataConstraint != null )
				         ?   theDataConstraint
				         :   new DataConstraint() );
  Token               formatToken;
  DataExpression      formatStringDataExpression;

  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  ( formatToken = <FORMAT>
      {
	thisConstraint.setConstraintType ( DataConstraint.DISTRIBUTED_FORMAT );
	thisConstraint . setLineNumber ( formatToken.beginLine + 1 );
	parseFluff ( thisConstraint, formatToken, theUnIndent );
	thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
      }

	/* This will handle strings with IDs in them too. */
//da0g: Double-check #line number macros
    formatStringDataExpression = parseConstantExpressionObject(0)
      {
	thisConstraint
	 . setDistributedFormatStringExpression ( formatStringDataExpression );
      }
  )
    { return thisConstraint; }
}





    /* Note: Only parses trailing fluff if next subsequent token is a comma. */
DataComponent
parseSimpleConstraintOrPersistentOrFormatAndTrailingFluff (
				   DataTaskDefinition theDataTaskDefinition ) :
{
  DataConstraint   dataConstraint        = null;
  DataComponent    returnValue           = null;
  boolean          foundFormatConstraint = false;
}
{
  (   returnValue = parsePersistentTaskData ( theDataTaskDefinition )

    | dataConstraint = parseFormatConstraint ( null, 0 )
        {
	  theDataTaskDefinition . addConstraint ( dataConstraint );
	  returnValue           = dataConstraint;
	  foundFormatConstraint = true;
	}

    | dataConstraint = parseSimpleConstraint  ( null, 0 )
        {
	  theDataTaskDefinition . addConstraint ( dataConstraint );
	  returnValue = dataConstraint;
	}
  )
    {
      if ( foundFormatConstraint == true )
	checkForTrailingCommaOrOpenBraceOrStringOrMacroString ( getToken(1) );
      else
	checkForTrailingCommaOrOpenBrace ( getToken(1) );

      processTrailingFluffBeforeTheseTokenKindsOnly (
				   returnValue, getToken(1), 0, COMMA, COMMA );
      return returnValue;
    }
}

    /* Note: Only parses trailing fluff if next subsequent token is a comma. */
DataComponent
parseMonitorConstraintOrPersistentOrFormatAndTrailingFluff (
				   DataTaskDefinition theDataTaskDefinition ) :
{
  DataConstraint   dataConstraint        = null;
  DataComponent    returnValue           = null;
  boolean          foundFormatConstraint = false;
}
{
  (   returnValue = parsePersistentTaskData ( theDataTaskDefinition )

    | dataConstraint = parseFormatConstraint ( null, 0 )
        {
	  theDataTaskDefinition . addConstraint ( dataConstraint );
	  returnValue           = dataConstraint;
	  foundFormatConstraint = true;
	}

    | dataConstraint = parseMonitorConstraint  ( null, 0 )
        {
	  theDataTaskDefinition . addConstraint ( dataConstraint );
	  returnValue = dataConstraint;
	}
  )
    {
      if ( foundFormatConstraint == true )
	checkForTrailingCommaOrOpenBraceOrStringOrMacroString ( getToken(1) );
      else
	checkForTrailingCommaOrOpenBrace ( getToken(1) );

      processTrailingFluffBeforeTheseTokenKindsOnly (
				   returnValue, getToken(1), 0, COMMA, COMMA );
      return returnValue;
    }
}

    /* Note: Only parses trailing fluff if next subsequent token is a comma. */
DataComponent
parseHandlerConstraintOrPersistentOrFormatAndTrailingFluff (
				   DataTaskDefinition theDataTaskDefinition ) :
{
  DataConstraint   dataConstraint        = null;
  DataComponent    returnValue           = null;
  boolean          foundFormatConstraint = false;
}
{
  (   returnValue = parsePersistentTaskData ( theDataTaskDefinition )

    | dataConstraint = parseFormatConstraint ( null, 0 )
        {
	  theDataTaskDefinition . addConstraint ( dataConstraint );
	  returnValue           = dataConstraint;
	  foundFormatConstraint = true;
	}

    | dataConstraint = parseHandlerConstraint  ( null, 0 )
        {
	  theDataTaskDefinition . addConstraint ( dataConstraint );
	  returnValue = dataConstraint;
	}
  )
    {
      if ( foundFormatConstraint == true )
	checkForTrailingCommaOrOpenBraceOrStringOrMacroString ( getToken(1) );
      else
	checkForTrailingCommaOrOpenBrace ( getToken(1) );

      processTrailingFluffBeforeTheseTokenKindsOnly (
				   returnValue, getToken(1), 0, COMMA, COMMA );
      return returnValue;
    }
}




/**********************/
/*** Task Arguments ***/
/**********************/


DataTaskArgument
parseTaskArgumentDeclarator ( DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
  Token startToken = getToken(0);
  Token token;
}
{
  (
    ( LOOKAHEAD ( parsePtrOperator() )
      parsePtrOperator()
    )*

    (   token = parseArgumentNameToken()
          {
	    parseMiscTokensIgnoringLast ( thisArgument, startToken, 0 );
	    parseFluff ( thisArgument, token, 0 );
	    startToken = token;
	    thisArgument . setArgumentNameWithoutParsingChecks ( token.image );
	    thisArgument . setIndex ( DataTaskArgument.ARGUMENT_NAME_INDEX );
	  }

      | ( token = <OPEN_PAREN>
            {
	      parseMiscTokens ( thisArgument, startToken, 0 );
	      startToken = token;
	    }

          parseTaskArgumentDeclarator ( thisArgument )

          token = <CLOSE_PAREN>
            {
	      parseFluff ( thisArgument, token, 0 );
	      thisArgument . addSubcomponent ( token.image );
	      startToken = token;
	    }
	)
    )

	/* Handles: "declarator ( args ) cv" and "declarator [ const-expr ]" */
    ( LOOKAHEAD ( parseDeclarator_Subpart() )
      parseDeclarator_Subpart()
    )*
  )
    {
      parseMiscTokens ( thisArgument, startToken, 0 );
      return thisArgument;
    }
}


DataTaskArgument
parseTaskArgumentDeclaration ( DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
  Token startToken;
  Token token;

	/* Erase any argument-equals-index... */
  thisArgument . removeIndex ( DataTaskArgument.ARGUMENT_EQUALS_INDEX );
}
{
  (
    parseTaskArgumentDeclarator ( thisArgument )
      {
	startToken = getToken(0);
      }

    [ token = <EQUAL>
        {
	    parseMiscTokens ( thisArgument, startToken, 0 );
	    startToken = token;
		/* Set this to the subcomponent index OF the equals */
	    thisArgument
	      . setIndex ( DataTaskArgument.ARGUMENT_EQUALS_INDEX,
			   thisArgument . getSubcomponentsCount() - 1 );
	}

	/* Note:  comma's deliminate task-arguments, so we're using */
	/* parseAssignmentExpression() instead of parseExpression() */
      parseAssignmentExpression()
        {
	  parseMiscTokens ( thisArgument, startToken, 0 );
	}
    ]
  )
    { 
      return thisArgument;
    }
}



  /* Deals with parsing valid C++ code for the Task Argument. */
DataTaskArgument
parseTaskArgument_WithoutArgDir_validCxxCode (
				       DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
  Token startToken = getToken(0);
  Token token;
}
{
  (
    parseDeclSpecifier()
      {
	parseMiscTokens ( thisArgument, startToken, 0 );
      }


    ( LOOKAHEAD ( parseTaskArgumentDeclaration ( thisArgument )

		     /* Note:  This is also checked for in
		      * parseTaskArgument_WithoutArgDir(...)
		      * for the Distributed case.
		      */

		  (   <COMMA>       /* Multiple argument separator.          */
		    | <CLOSE_PAREN> /* Last Task argument trailing token.    */

			/* Used by DataTaskArgument to parse strings */
		    | <EOF>

			/* Possible last PERSISTENT element trailing token */
		    | <OPEN_BRACE>

		    | <FORMAT> /* Might have an optional format specification*/
		  )
		 )
        (
	  parseTaskArgumentDeclaration ( thisArgument )
	)

      | parseTaskArgument_WithoutArgDir_validCxxCode ( thisArgument )
    )
  )
    { return thisArgument; }
}



DataTaskArgument
parseTaskArgument_TrailingDistributedFormatString(
				       DataTaskArgument theDataTaskArgument,
				       int              theUnIndent         ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
  Token             token;
  DataExpression    constantDataExpression;
}
{
  (
    token = <FORMAT>
      {
	parseFluff ( thisArgument, token, theUnIndent );
	thisArgument . setIndex ( DataTaskArgument.FORMAT );

	  /* Attach any fluff to thisArgument, not to the constantExpression */
	processTrailingFluffBeforeTheseTokenKindsOnly( thisArgument,
						       getToken ( 1 ),
						       0,
						       getToken ( 1 ) . kind,
						       getToken ( 1 ) . kind );
	thisArgument . setIndex ( DataTaskArgument.FORMAT_EXPRESSION );
      }

//da0g: Double-check #line number macros
    constantDataExpression = parseConstantExpressionObject(0)
      {
	thisArgument . setFormatExpression ( constantDataExpression );
      }
  )
    { return thisArgument; }
}


DataTaskArgument
parseTaskArgument_WithoutArgDir ( DataTaskArgument theDataTaskArgument,
				  boolean          theSetLineNumber     ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );

	/* Note:  Doing this here will insure that we set the line number
	 * to the first token of the task argument *AFTER* the optional
	 * IN/OUT/INOUT direction.
	 */
  if ( theSetLineNumber == true )
    thisArgument . setLineNumber ( getToken ( 1 ) . beginLine + 1 );
}
{
  ( LOOKAHEAD ( parseDistributedTaskArgument ( thisArgument )

		     /* Note:  This is also checked for in
		      * parseTaskArgument_WithoutArgDir_validCxxCode(...)
		      * for the standard-C++ case.
		      */

		(   <COMMA>       /* Multiple argument separator.          */
		  | <CLOSE_PAREN> /* Last Task argument trailing token.    */

			/* Used by DataTaskArgument to parse strings */
		  | <EOF>

			/* The Distributed case cannot be part of a
			 * PERSISTENT constraint.
			 */
		  /* <OPEN_BRACE> */

		  | <FORMAT>  /* Could have an optional format specification */
		)
	      )
      parseDistributedTaskArgument ( thisArgument )

    | parseTaskArgument_WithoutArgDir_validCxxCode ( thisArgument )
  )
    {
	/*   Task arguments that are separated by commas,
	 * or task-arguments that end in a ')', need to have
	 * their subseqent token's (the comma or close-paren)
	 * fluff attached to the task-argument.
	 *   An exception to this rule is made for PERSISTENT
	 * declarations that occur right before the task's body.
	 */
      processTrailingFluffBeforeTheseTokenKindsOnly (
			    thisArgument, getToken(1), 0, COMMA, CLOSE_PAREN );

	/* Also snarf subsequent EOF token fluff.  (For debugging.) */
      processTrailingFluffBeforeTheseTokenKindsOnly (
			    thisArgument, getToken(1), 0, EOF, EOF );

      return thisArgument;
    }
}
   


DataTaskArgument
parseTaskArgumentNoFormat ( DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
  Token             token;

  thisArgument . setArgumentDirection ( DataTaskArgument.DEFAULT_DIRECTION );
}
{
  (
    [ token = parseArgumentDirection()
	{
	  parseFluff ( thisArgument, token, 0 );
	  thisArgument . setArgumentDirectionString ( token.image );
	  thisArgument . setIndex (
			       DataTaskArgument.ARGUMENT_DIRECTION_INDEX );
	}
    ]

    parseTaskArgument_WithoutArgDir ( thisArgument, true )
  )
    { return thisArgument; }
}



DataTaskArgument
parseTaskArgument ( DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
}
{
  (
    parseTaskArgumentNoFormat ( thisArgument )

	/* And add a optional distributed-format constraint. */
    [ parseTaskArgument_TrailingDistributedFormatString ( thisArgument , 0 )
        {
	    /*   Task arguments that are separated by commas,
	     * or task-arguments that end in a ')', need to have
	     * their subseqent token's (the comma or close-paren)
	     * fluff attached to the task-argument.
	     *   An exception to this rule is made for PERSISTENT
	     * declarations that occur right before the task's body.
	     */
	  processTrailingFluffBeforeTheseTokenKindsOnly (
			    thisArgument, getToken(1), 0, COMMA, CLOSE_PAREN );

	    /* Also snarf subsequent EOF token fluff.  (For debugging.) */
	  processTrailingFluffBeforeTheseTokenKindsOnly (
			    thisArgument, getToken(1), 0, EOF, EOF );
	}
    ]
  )
    { return thisArgument; }
}


DataTaskArgument
parseTaskArgument_WithoutArgDir_AndTrailingEOF (
				       DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  dataTaskArgument;
}
{
  ( dataTaskArgument = parseTaskArgument_WithoutArgDir ( theDataTaskArgument,
							 true )
    <EOF>
  )
    { return dataTaskArgument; }
}


DataTaskArgument
parseTaskArgument_AndTrailingEOF ( DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  dataTaskArgument;
}
{
  ( dataTaskArgument = parseTaskArgument ( theDataTaskArgument )
    <EOF>
  )
    { return dataTaskArgument; }
}


Token
parseArgumentDirection() :
{}
{
  ( <IN> | <OUT> | <INOUT> )
    { return getToken(0); }
}


Token
parseArgumentNameToken() :
{}
{
  parseIdToken()  { return getToken(0); }
}

String
parseArgumentName() :
{
  Token token;
}
{
  token = parseArgumentNameToken()
    { return token.image; }
}




/********************************/
/* Distributed Declaration Sets */
/********************************/

DataDistributedDeclarationSet
parseDistributedDeclarationSet (
	    DataDistributedDeclarationSet  theDataDistributedDeclarationSet ) :
{
  DataDistributedDeclarationSet  thisDeclarationSet
    = (   ( theDataDistributedDeclarationSet != null )
	?   theDataDistributedDeclarationSet
	:   new DataDistributedDeclarationSet() );

  thisDeclarationSet . clear();
}
{
	/* Note:  This LOOKAHEAD only works properly because the <SEMICOLON>
	 * token ends both of these two choices.  (Otherwise we get a premature
	 * partial "_Direct" match when we wanted a full "_WithFormat" match.)
	 */
  ( LOOKAHEAD ( parseDistributedDeclarationSet_Direct ( thisDeclarationSet ) )
      parseDistributedDeclarationSet_Direct     ( thisDeclarationSet )
    | parseDistributedDeclarationSet_WithFormat ( thisDeclarationSet )
  )
    { return thisDeclarationSet; }
}


DataDistributedDeclarationSet
parseDistributedDeclarationSet_WithFormat (
	    DataDistributedDeclarationSet  theDataDistributedDeclarationSet ) :
{
  DataDistributedDeclarationSet  thisDeclarationSet
    = (   ( theDataDistributedDeclarationSet != null )
	?   theDataDistributedDeclarationSet
	:   new DataDistributedDeclarationSet() );

  Token  token;
  int    declarationCount = 0;

  thisDeclarationSet . clear();

  if ( TDLParser.debugDistributedDeclarationSet )
    System.err.println( "parseDistributedDeclarationSet_WithFormat:  "
			+ getToken(1).image );
}
{
  (
    parseTaskArgumentNoFormat ( 
      thisDeclarationSet . getFirstDeclarationCreatingIfNecessary() )

	/* And add a manditory distributed-format constraint. */
    parseTaskArgument_TrailingDistributedFormatString ( 
			    thisDeclarationSet . getLastExistingDeclaration(),
			    0 )
      {
	  /* Store "fluff" as part of DataTaskArgument, *
	   * not DataDistributedDeclarationSet.         */
	processTrailingFluffBeforeTheseTokenKindsOnly (
			    thisDeclarationSet . getLastExistingDeclaration(),
			    getToken(1), 0, COMMA, SEMICOLON );
	thisDeclarationSet
	  . setIndex ( DataDistributedDeclarationSet.DECLARATION_INDEX
		       + (declarationCount ++) );
      }

    ( token = <COMMA>

      parseTaskArgumentDeclaration (
        thisDeclarationSet . createNextDeclaration() )

	/* And add a manditory distributed-format constraint. */
      parseTaskArgument_TrailingDistributedFormatString (
			    thisDeclarationSet . getLastExistingDeclaration(),
			    0 )
        {
	    /* Store "fluff" as part of DataTaskArgument, *
	     * not DataDistributedDeclarationSet.         */
	  processTrailingFluffBeforeTheseTokenKindsOnly (
			    thisDeclarationSet . getLastExistingDeclaration(),
			    getToken(1), 0, COMMA, SEMICOLON );
	  thisDeclarationSet
	    . setIndex ( DataDistributedDeclarationSet.DECLARATION_INDEX
			 + (declarationCount ++) );
	}

    )*

	/* parseDistributedDeclarationSet()'s LOOKAHEAD only works properly
	 * because this <SEMICOLON> token ends both of the two choices.
	 * (Otherwise we'd get a premature partial "_Direct" match when we
	 *  wanted a full "_WithFormat" match.)
	 */
    token = <SEMICOLON>
  )
    { return thisDeclarationSet; }
}


void
parseDistributedDeclarationSet_Direct_subpart (
				       DataTaskArgument theDataTaskArgument ) :
{
}
{
  (	/* At this point, we can have either:
	 * 1) A known distributed second-part with an optional format string.
	 * 2) A standard non-distributed second-part with a mandatory format
	 *    string.
	 */
    ( LOOKAHEAD ( parseDistributedDeclaration_SecondIdentifierPart ( null )
		  ( <FORMAT> | <COMMA> | <SEMICOLON> )
		 )
        ( parseDistributedDeclaration_SecondIdentifierPart (
	    theDataTaskArgument )

	    /* The problem is that struct/enum will parse here, but parsing
	     * will fail when it hits a trailing format string...
	     */
	  [ parseTaskArgument_TrailingDistributedFormatString (
	      theDataTaskArgument, 0 )
	  ]
        )

      | ( parseTaskArgumentDeclaration ( theDataTaskArgument )

	  parseTaskArgument_TrailingDistributedFormatString ( 
	    theDataTaskArgument, 0 )
	)
    )
      {    /* Store "fluff" as part of this DataTaskArgument */
	processTrailingFluffBeforeTheseTokenKindsOnly (
	   theDataTaskArgument, getToken(1), 0, COMMA, SEMICOLON );
      }
  )
}

DataDistributedDeclarationSet
parseDistributedDeclarationSet_Direct (
	    DataDistributedDeclarationSet  theDataDistributedDeclarationSet ) :
{
  DataDistributedDeclarationSet  thisDeclarationSet
    = (   ( theDataDistributedDeclarationSet != null )
	?   theDataDistributedDeclarationSet
	:   new DataDistributedDeclarationSet() );

  Token  token;
  int    declarationCount = 0;

  thisDeclarationSet . clear();

  if ( TDLParser.debugDistributedDeclarationSet )
    System.err.println( "parseDistributedDeclarationSet_Direct:  "
			+ getToken(1).image );
}
{
  (
    parseDistributedDeclaration_FirstTypePart_IncludingStructEnumDeclarations (
      thisDeclarationSet . getFirstDeclarationCreatingIfNecessary() )

    parseDistributedDeclarationSet_Direct_subpart (
      thisDeclarationSet . getLastExistingDeclaration() )
        {
	  thisDeclarationSet
	    . setIndex ( DataDistributedDeclarationSet.DECLARATION_INDEX
			 + (declarationCount ++) );
	}

    ( token = <COMMA>

      parseDistributedDeclarationSet_Direct_subpart (
        thisDeclarationSet . createNextDeclaration() )
          {
	    thisDeclarationSet
	      . setIndex ( DataDistributedDeclarationSet.DECLARATION_INDEX
			   + (declarationCount ++) );
	  }
    )*

	/* parseDistributedDeclarationSet()'s LOOKAHEAD only works properly
	 * because this <SEMICOLON> token ends both of the two choices.
	 * (Otherwise we'd get a premature partial "_Direct" match when we
	 *  wanted a full "_WithFormat" match.)
	 */
    token = <SEMICOLON>
  )
    { return thisDeclarationSet; }
}





/*********************************************************/
/* Distributed Task Arguments / Distributed Declarations */
/*********************************************************/

/*
 * Caveat:  parseDistributedTaskArgument intentionally does *NOT*
 * parse struct { ... } or enum { ... }.  These must be parsed elsewhere.
 *
 * parseDistributedDeclaration_FirstTypePart_IncludingStructEnumDeclarations
 * does parse these.
 */
DataTaskArgument
parseDistributedTaskArgument ( DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
}
{
  (
	/* This is a restricted subset of the valid Task arguments that *
	 * we understand how to process for DISTRIBUTED purposes.       */
    parseDistributedDeclaration_FirstTypePart        ( thisArgument )
    parseDistributedDeclaration_SecondIdentifierPart ( thisArgument )
  )
    { return thisArgument; }
}


DataTaskArgument
parseDistributedDeclaration_FirstTypePart (
				       DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
}
{
  (
	/* [ <CONST> ] */
    parseDistributedDeclaration_internalLeadingConst  ( thisArgument )

	/* Types (int, double, struct <ID>, etc *
	 * that we can handle for distributed   */
    parseDistributedDeclaration_internalTypeItself    ( thisArgument )
  )
    { return thisArgument; }    
}


DataTaskArgument
parseDistributedDeclaration_FirstTypePart_IncludingStructEnumDeclarations (
				       DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
}
{
  (
	/* [ <CONST> ] */
    parseDistributedDeclaration_internalLeadingConst ( thisArgument )

	/* Types (int, double, struct <ID>, etc *
	 * that we can handle for distributed.  *
	 * Including struct/enum declarations!  */
    parseDistributedDeclaration_includingStructOrEnumDeclarations(thisArgument)
  )
    { return thisArgument; }    
}



DataTaskArgument
parseDistributedDeclaration_SecondIdentifierPart (
				       DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
  Token             token;
}
{
  (
	/* [<CONST>] [ <ASTERISK> [<CONST] ], invokes setDistributedPointer()*/
    parseDistributedDeclaration_internalTrailingStuff ( thisArgument )

    token = parseArgumentNameToken()
      {
	parseFluff ( thisArgument, token, 0 );
	thisArgument . setArgumentNameWithoutParsingChecks ( token.image );
	thisArgument . setIndex ( DataTaskArgument.ARGUMENT_NAME_INDEX );
      }


    [   parseDistributedTaskArgument_Array        ( thisArgument )
      | parseDistributedTaskArgument_DefaultValue ( thisArgument )
    ]
  )
    { return thisArgument; }    
}

void
parseDistributedDeclaration_internalLeadingConst (
					    DataTaskArgument theThisArgument) :
{
  Token   startToken = getToken(0);
}
{
  (
    [ <CONST>
    ]
  )
    {
      parseMiscTokens ( theThisArgument, startToken, 0 );
    }
}



void
parseDistributedDeclaration_internalTypeItself (
					   DataTaskArgument theThisArgument ) :
{
  Token        token;
  Token        startToken    = getToken(0);
  boolean      intTypeSigned = true;
  StringBuffer stringBuffer = null;
}
{
  (
      ( [ (   <UNSIGNED> 
                { intTypeSigned = false; }

            | <SIGNED>
                { intTypeSigned = true; }
          )

	  [ <CONST>
	  ]
        ]

        (     <CHAR>
                {
		  theThisArgument
		    . setDistributedType (   ( intTypeSigned == true )
					   ? DataTaskArgument.INT1
					   : DataTaskArgument.U_INT1 );
		}
	  | ( <SHORT> [ LOOKAHEAD(2)  [ <CONST> ] <INT> ] )
                {
		  theThisArgument
		    . setDistributedType (   ( intTypeSigned == true )
					   ? DataTaskArgument.INT2
					   : DataTaskArgument.U_INT2 );
		}
	  |   <INT>
                {
		  theThisArgument
		    . setDistributedType (   ( intTypeSigned == true )
					   ? DataTaskArgument.INT4
					   : DataTaskArgument.U_INT4 );
		}
	  | ( <LONG>  [ LOOKAHEAD(2)  [ <CONST> ] <INT> ] )
	        {
		  theThisArgument
		    . setDistributedType (   ( intTypeSigned == true )
					   ? DataTaskArgument.INT4
					   : DataTaskArgument.U_INT4 );
		}
        )
      )

    | <FLOAT>
        { theThisArgument . setDistributedType ( DataTaskArgument.FLOAT   ); }

    | <DOUBLE>
        { theThisArgument . setDistributedType ( DataTaskArgument.DOUBLE  ); }


    | ( LOOKAHEAD ( parseIdToken() <SCOPE> parseIdToken() )
	  ( token = parseIdToken()
	        {
		  stringBuffer = new StringBuffer ( 100 /* Arbitrary */ );
		  stringBuffer . append ( token.image );
		}

	    ( LOOKAHEAD ( <SCOPE> parseIdToken() )
	        ( token = <SCOPE>
	            { stringBuffer . append ( token.image ); }

	          token = parseIdToken()
	            { stringBuffer . append ( token.image ); }
		)
	    )+
	  )
            {
	      theThisArgument
		. setDistributedType ( DataTaskArgument.IDENTIFIER );
	      theThisArgument . setDistributedId   ( stringBuffer.toString() );
	    }


       | token = parseIdToken()
          {
	    if ( token.image . equals ( "BOOLEAN" ) )
	      theThisArgument . setDistributedType( DataTaskArgument.BOOLEAN );

	    else if ( token.image . equals ( "STRING" ) )
	      theThisArgument . setDistributedType( DataTaskArgument.STRING  );


	    else if ( token.image . equals ( "u_int1" ) )
	      theThisArgument . setDistributedType( DataTaskArgument.U_INT1  );

	    else if ( token.image . equals ( "u_int2" ) )
	      theThisArgument . setDistributedType( DataTaskArgument.U_INT2  );

	    else if ( token.image . equals ( "u_int4" ) )
	      theThisArgument . setDistributedType( DataTaskArgument.U_INT4  );

	    else if ( token.image . equals ( "u_int8" ) )
	      theThisArgument . setDistributedType( DataTaskArgument.U_INT8  );


	    else if ( token.image . equals ( "int1" ) )
	      theThisArgument . setDistributedType ( DataTaskArgument.INT1  );

	    else if ( token.image . equals ( "int2" ) )
	      theThisArgument . setDistributedType ( DataTaskArgument.INT2  );

	    else if ( token.image . equals ( "int4" ) )
	      theThisArgument . setDistributedType ( DataTaskArgument.INT4  );

	    else if ( token.image . equals ( "int8" ) )
	      theThisArgument . setDistributedType ( DataTaskArgument.INT8  );


	    else /* Assume typedef/struct/enum by name */
	    {
	      theThisArgument
		. setDistributedType ( DataTaskArgument.IDENTIFIER );
	      theThisArgument . setDistributedId   ( token.image );
	    }
	  }
      )



    | ( <STRUCT>
        token = parseIdToken()
      )
        {
	  theThisArgument . setDistributedType ( DataTaskArgument.STRUCT );
	  theThisArgument . setDistributedId ( token.image );
	}



    | ( <ENUM>
        token = parseIdToken()
      )
        {
	  theThisArgument . setDistributedType ( DataTaskArgument.ENUM );
	  theThisArgument . setDistributedId ( token.image );
	}
  )
   {
     parseMiscTokens ( theThisArgument, startToken, 0 );
   }
}



void
parseDistributedDeclaration_internalTrailingStuff (
					   DataTaskArgument theThisArgument ) :
{
  Token   startToken = getToken(0);

  theThisArgument . setDistributedPointer ( false );
}
{
  (
    [ <CONST>
    ]


    [ <ASTERISK>
         {
	   theThisArgument . setDistributedPointer ( true );
	 }

      [ <CONST>
      ]
    ]
  )
    { 
      parseMiscTokens ( theThisArgument, startToken, 0 );
    }
}




DataTaskArgument
parseDistributedTaskArgument_Array ( DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );
  DataExpression    constantDataExpression;
  DataComponent     targetDataComponent;
  Token             token;
}
{
  (
    ( token = <OPEN_BRACKET>
        {
	  parseFluff ( thisArgument, token, 0 );
	  thisArgument . addSubcomponent ( token.image );
	  constantDataExpression = null;
	}

      
      constantDataExpression = parseConstantExpressionObject(0)
        {
	  thisArgument . addSubcomponent ( constantDataExpression );
	  thisArgument
	    . addDistributedArrayExpression ( constantDataExpression );
	}

      token = <CLOSE_BRACKET>
        {
	  parseFluff ( thisArgument, token, 0 );
	  thisArgument . addSubcomponent ( token.image );
	}
    )+
  )
    {
      return thisArgument;
    }
}



DataTaskArgument
parseDistributedTaskArgument_DefaultValue (
				       DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
				     ?   theDataTaskArgument 
				     :   new DataTaskArgument() );

  Token             token, startToken = getToken(0);
}
{
  (
    token = <EQUAL>
      {
	parseMiscTokens ( thisArgument, startToken, 0 );
	startToken = token;
		/* Set this to the subcomponent index OF the equals */
	thisArgument
	  . setIndex ( DataTaskArgument.ARGUMENT_EQUALS_INDEX,
		       thisArgument . getSubcomponentsCount() - 1 );
      }

	  
	/* Note:  comma's deliminate task-arguments, so we're using */
	/* parseAssignmentExpression() instead of parseExpression() */
    parseAssignmentExpression()
  )
    {
      parseMiscTokens ( thisArgument, startToken, 0 );
      return thisArgument;
    }
}


DataTaskArgument
parseDistributedDeclaration_includingStructOrEnumDeclarations (
				       DataTaskArgument theDataTaskArgument ) :
{
  DataTaskArgument  thisArgument  = (   ( theDataTaskArgument != null )
				      ?   theDataTaskArgument 
				      :   new DataTaskArgument() );

  DataDistributedStruct  nestedStruct;
  DataDistributedEnum    nestedEnum;
}
{
  ( ( LOOKAHEAD ( ( <STRUCT> | <ENUM> ) [ parseIdToken() ] <OPEN_BRACE> )
        ( 
	   nestedStruct = parseDistributedStructInternal ( null )
	     {
	       thisArgument . setDistributedType (
			        DataTaskArgument.DATA_DISTRIBUTED_STRUCT );
	       thisArgument . setDistributedStruct ( nestedStruct );
	     }

	 | nestedEnum = parseDistributedEnumInternal ( null )
	     {
	       thisArgument . setDistributedType (
			        DataTaskArgument.DATA_DISTRIBUTED_ENUM );
	       thisArgument . setDistributedEnum ( nestedEnum );
	     }
	 )
       | parseDistributedDeclaration_internalTypeItself ( thisArgument )
    )
  )
    {
      return thisArgument;
    }
}






/*******************/
/*** Constraints ***/
/*******************/


	/* Simple constraints have grown since their conception.
	 * They used to be just expand_first and delay_expansion.
	 * Now they contain all the constraints that can be applied
	 * as top task-level constraints to goals, commands, & monitors.
	 */
DataConstraint
parseSimpleConstraint ( DataConstraint  theDataConstraint,
			int             theUnIndent       ) :
{
  Token               token, token_2;
  boolean             foundFirstToken      = false;
  DataSpawnTask       exceptionHandlerTask;
  DataSpawnTask       onTerminateSpawnTask = null;
  DataLabelStatement  dataLabel, oldLabel  = null;
  DataConstraint      thisConstraint = (   ( theDataConstraint != null )
				         ?   theDataConstraint
				         :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  (
              /* Simple constraints */
      (
          ( token = <EXPAND_FIRST>
	      { thisConstraint
		  . setConstraintType ( DataConstraint.EXPAND_FIRST ); }
	  )
	| ( token = <DELAY_EXPANSION>
	      { thisConstraint
		  . setConstraintType ( DataConstraint.DELAY_EXPANSION ); }
	  )
      )
        {
	  thisConstraint . setLineNumber ( token.beginLine + 1 );
          parseFluff ( thisConstraint, token, theUnIndent );
          thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
        }

              /* Multi-token simple constraints */
    | (   (   token   = <EXPAND>
	      token_2 = <FIRST>
	  )
	    { thisConstraint
		. setConstraintType ( DataConstraint.EXPAND_FIRST ); }

        | (   token   = <DELAY>
	      token_2 = <EXPANSION>
	  )
	    { thisConstraint
		. setConstraintType ( DataConstraint.DELAY_EXPANSION ); }
      )
        {
	  thisConstraint . setLineNumber ( token.beginLine + 1 );
          parseFluff ( thisConstraint, token, theUnIndent );
          thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );

          parseFluff ( thisConstraint, token_2, theUnIndent );
          thisConstraint . setIndex ( DataConstraint.KEYWORD + 1 );
	}


              /* exception constraints */
    | ( [ token = <EXCEPTION>
	    {
	      parseFluff ( thisConstraint, token, theUnIndent );
	      thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
	      thisConstraint . setLineNumber ( token.beginLine + 1);
	      foundFirstToken = true;
	    }
	]

	token = <HANDLER>
	  {
	    parseFluff ( thisConstraint, token, theUnIndent );
	    thisConstraint . setIndex ( DataConstraint.KEYWORD + 1 );
	    if ( foundFirstToken == false )
	    {
	      thisConstraint . setLineNumber ( token.beginLine + 1);
	      foundFirstToken = true;
	    }
	  }
	
	exceptionHandlerTask = parseSpawnTask_ExpressionAndScopedTaskOnly (
							    null, theUnIndent )
	  {
	    thisConstraint
		. setConstraintType ( DataConstraint.EXCEPTION_HANDLER );
	    thisConstraint . setExceptionHandlerTask ( exceptionHandlerTask );
	  }
      ) /* exception constraints */


		/* On terminate constraints */
    | ( (   ( token = <ON_TERMINATE>
	        {
		  thisConstraint
		      . setConstraintType ( DataConstraint.ON_TERMINATE );
		  thisConstraint . setLineNumber ( token.beginLine + 1 );
		  parseFluff ( thisConstraint, token, theUnIndent );
		  thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
		  thisConstraint . setHasOnTerminateSpawnKeyword ( false );
		}
	    )
	  | ( token = <ON>
	        {
		  thisConstraint
		      . setConstraintType ( DataConstraint.ON_TERMINATE );
		  thisConstraint . setLineNumber ( token.beginLine + 1 );
		  parseFluff ( thisConstraint, token, theUnIndent );
		  thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
		  thisConstraint . setHasOnTerminateSpawnKeyword ( false );
		}

	      token = <TERMINATE>
	        {
		  parseFluff ( thisConstraint, token, theUnIndent );
		  thisConstraint . setIndex ( DataConstraint.KEYWORD + 1 );
		}
	    )
        )


	( LOOKAHEAD ( parseLabel ( theUnIndent, false ) )
	    dataLabel = parseLabel ( theUnIndent, false )
	      {
	        if ( onTerminateSpawnTask == null )
	          onTerminateSpawnTask = new DataSpawnTask();

		  /* Order is important here to preserve parent information */
		if ( oldLabel == null )
		  onTerminateSpawnTask . setLabel ( dataLabel );
		else
		  oldLabel . setLabel ( dataLabel );
		oldLabel = dataLabel;
	      }
	)*

	[ token = <SPAWN>
	    {
	      thisConstraint . setHasOnTerminateSpawnKeyword ( true );
	      parseFluff ( thisConstraint, token, theUnIndent );
	      thisConstraint . setIndex ( DataConstraint.KEYWORD + 2 );
	    }
	]

	onTerminateSpawnTask = parseSpawnTask_ExpressionAndScopedTaskOnly (
							 onTerminateSpawnTask,
							 theUnIndent )
	  {
	    thisConstraint . setOnTerminateTask ( onTerminateSpawnTask );
	  }

      ) /* On terminate constraints */
  )
    { return thisConstraint; }
}



DataConstraint
parseMaximumActivateConstraint ( DataConstraint  theDataConstraint,
				 int             theUnIndent       ) :
{
  Token           token, token_2 = null;
  DataExpression  numericExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  (   	/* Maximum Activate constraint */
      ( token             = <MAXIMUM_ACTIVATE>
	numericExpression = parseAssignmentExpressionObject (theUnIndent, true)
      )
	  {
	    thisConstraint
	      . setConstraintType( DataConstraint.MAXIMUM_ACTIVATE );
	    thisConstraint . setLineNumber ( token.beginLine + 1 );

	    parseFluff ( thisConstraint, token, theUnIndent );
	    thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );

	    thisConstraint . setNumericExpression ( numericExpression );
	  }

              /* Multi-token constraint */
    | ( token             = <MAXIMUM>
	token_2           = <ACTIVATE>
	numericExpression = parseAssignmentExpressionObject (theUnIndent, true)
      )
          {
	    thisConstraint
	      . setConstraintType( DataConstraint.MAXIMUM_ACTIVATE );
	    thisConstraint . setLineNumber ( token.beginLine + 1 );

	    parseFluff ( thisConstraint, token, theUnIndent );
	    thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );

	    parseFluff ( thisConstraint, token_2, theUnIndent );
	    thisConstraint . setIndex ( DataConstraint.KEYWORD + 1 );

	    thisConstraint . setNumericExpression ( numericExpression );
	  }
  )
    { return thisConstraint; }
}


DataConstraint
parseMaximumTriggerConstraint ( DataConstraint  theDataConstraint,
				int             theUnIndent       ) :
{
  Token           token, token_2 = null;
  DataExpression  numericExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  (   	/* Maximum Trigger constraint */
      ( token             = <MAXIMUM_TRIGGER>
	numericExpression = parseAssignmentExpressionObject (theUnIndent, true)
      )
          {
	    thisConstraint
	      . setConstraintType ( DataConstraint.MAXIMUM_TRIGGER );
	    thisConstraint . setLineNumber ( token.beginLine + 1 );

	    parseFluff ( thisConstraint, token, theUnIndent );
	    thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );

	    thisConstraint . setNumericExpression ( numericExpression );
	  }

              /* Multi-token constraint */
    | ( token             = <MAXIMUM>
	token_2           = <TRIGGER>
	numericExpression = parseAssignmentExpressionObject (theUnIndent, true)
      )
          {
	    thisConstraint
	      . setConstraintType ( DataConstraint.MAXIMUM_TRIGGER );
	    thisConstraint . setLineNumber ( token.beginLine + 1 );

	    parseFluff ( thisConstraint, token, theUnIndent );
	    thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );

	    parseFluff ( thisConstraint, token_2, theUnIndent );
	    thisConstraint . setIndex ( DataConstraint.KEYWORD + 1 );

	    thisConstraint . setNumericExpression ( numericExpression );
	  }
  )
    { return thisConstraint; }
}



DataConstraint
parseMonitorConstraint ( DataConstraint  theDataConstraint,
			 int             theUnIndent       ) :
{
  Token           token, token_2 = null, numericToken;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  (   parseSimpleConstraint ( thisConstraint, theUnIndent )

    | parseSequentialOrSerialConstraint ( thisConstraint, theUnIndent, true )

    | ( LOOKAHEAD ( 2 ) /* Deal with <MAXIMUM> { <ACTIVATE> | <TRIGGER> } */
          parseMaximumActivateConstraint ( thisConstraint, theUnIndent )
        | parseMaximumTriggerConstraint  ( thisConstraint, theUnIndent )
      )

    | ( token = <MONITOR_PERIOD>
	  {
	    thisConstraint
	      . setConstraintType ( DataConstraint.MONITOR_PERIOD );
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
	    parseFluff ( thisConstraint, token, theUnIndent );
	    thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
	  }

	parseRelativeTimeExpression ( thisConstraint, theUnIndent )
      )
  )
    { return thisConstraint; }
}



DataConstraint
parseHandlerConstraint ( DataConstraint  theDataConstraint,
			 int             theUnIndent       ) :
{
  DataConstraint  dataConstraint = null;
}
{
  (   	/* Exception-Handler constraints */
      ( dataConstraint = parseMaximumActivateConstraint ( theDataConstraint,
							  theUnIndent       ) )
  )
    { return dataConstraint; }
}



DataConstraint
parseSequentialOrSerialConstraint ( DataConstraint  theDataConstraint,
				    int             theUnIndent,
				    boolean         theIsMonitorConstraint ) :
{
  Token           token, token_2;
  int             keywordIndex = 0;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  (
		/* Two-token constraints... */
      (
        (   token = <SEQUENTIAL>
	    (   ( token_2 = <HANDLING>
		    { thisConstraint . setConstraintType (
				        DataConstraint.SEQUENTIAL_HANDLING ); }
		)
	      | ( token_2 = <EXPANSION>
		    { thisConstraint . setConstraintType (
					DataConstraint.SEQUENTIAL_EXPANSION );}
		)
	      | ( token_2 = <EXECUTION>
		    { thisConstraint . setConstraintType (
					DataConstraint.SEQUENTIAL_EXECUTION );}
		)
	      | ( token_2 = <PLANNING>
		    { thisConstraint . setConstraintType (
					DataConstraint.SEQUENTIAL_EXPANSION );}
		)
	      | ( token_2 = <ACHIEVEMENT>
		    { thisConstraint . setConstraintType (
					DataConstraint.SEQUENTIAL_EXECUTION );}
		)
	    ) /* token_2... */
        ) /* token... */
          {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );

            parseFluff ( thisConstraint, token_2, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );

	    if ( theIsMonitorConstraint )
	    {
	      if ( token_2.kind == HANDLING )
	      {
		throw generateParseException ( token_2,
		    "Sequential Handling constraint is not yet "
		    + "available for monitors..." );
	      }

		/* Default to blank... */
	      thisConstraint . setEventTagTask ( null );
	    }
	    else  /* Ie: Not a monitor constraint */
	    {
		/* Default to previous */
	      thisConstraint . setEventTagTask ( DataConstraint.PREVIOUS );
	    }
          }


	[ LOOKAHEAD ( parseTagTask ( thisConstraint, theUnIndent ),
		      { theIsMonitorConstraint == false } )
	  parseTagTask ( thisConstraint, theUnIndent )
	]

      ) /*  <SEQUENTIAL>  ( <HANDLING> | <EXPANSION> | ... )



              /* One-Token constraints... */
    | (
        (   ( token = <SEQUENTIAL_HANDLING>
	        { thisConstraint . setConstraintType (
				       DataConstraint.SEQUENTIAL_HANDLING );  }
	    )

          | ( token = <SEQUENTIAL_EXPANSION>
	        { thisConstraint . setConstraintType (
				       DataConstraint.SEQUENTIAL_EXPANSION ); }
	    )

          | ( token = <SEQUENTIAL_EXECUTION>
	        { thisConstraint . setConstraintType (
				       DataConstraint.SEQUENTIAL_EXECUTION ); }
	    )

          | ( token = <SEQUENTIAL_PLANNING>
	        { thisConstraint . setConstraintType (
				       DataConstraint.SEQUENTIAL_EXPANSION ); }
	    )

          | ( token = <SEQUENTIAL_ACHIEVEMENT>
	        { thisConstraint . setConstraintType (
				       DataConstraint.SEQUENTIAL_EXECUTION ); }
	    )

          | ( token = <SERIAL>
	        { thisConstraint . setConstraintType (
				       DataConstraint.SERIAL ); }
	    )
        )
          {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );

	    if ( theIsMonitorConstraint )
	    {
	      if ( token.kind == SEQUENTIAL_HANDLING )
	      {
		throw generateParseException ( token,
		    "Sequential Handling constraint is not yet "
		    + "available for monitors..." );
	      }

		/* Default to blank... */
	      thisConstraint . setEventTagTask ( null );
	    }
	    else  /* Ie: Not a monitor constraint */
	    {
		/* Default to previous */
	      thisConstraint . setEventTagTask ( DataConstraint.PREVIOUS );
	    }
          }

	[ LOOKAHEAD ( parseTagTask ( thisConstraint, theUnIndent ),
		      { theIsMonitorConstraint == false } )
	  parseTagTask ( thisConstraint, theUnIndent )
	]

      ) /* <SEQUENTIAL_HANDLING> | <SEQUENTIAL_EXPANSION> | ...  | <SERIAL> )*/

  )
    { return thisConstraint; }
}




DataConstraint
parseDistributedOnAgentConstraint ( DataConstraint theDataConstraint,
				    int            theUnIndent       ) :
{
  Token           token;
  int             keywordIndex = 0;
  DataExpression  agentDataExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  (
	/* ON "AGENT" constraint */
    token = <ON>
      {
	thisConstraint . setConstraintType ( DataConstraint.ON_AGENT );
	thisConstraint . setLineNumber     ( token.beginLine + 1     );
	parseFluff ( thisConstraint, token, theUnIndent );
	thisConstraint
	  . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
      }


	/* This will handle strings with IDs in them too. */
//da0g: Double-check #line number macros
    agentDataExpression = parseAssignmentExpressionObject ( theUnIndent, true )
      {
	thisConstraint
	  . setDistributedOnAgentExpression ( agentDataExpression );
      }
  )
    { return thisConstraint; }
}



DataConstraint
parseConstraint ( DataConstraint  theDataConstraint,
		  int             theUnIndent       ) :
{
  Token           token,
		  token_2,
                  timeBoundaryToken                = null,
                  constraintOptionToken            = null,
                  constrainerConstraintOptionToken = null;

  int             keywordIndex = 0;

  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  (
	  /* Some constraints -- which can be used for Task-definitions --
	   * are being parsed in parseSimpleConstraint() which in turn is
	   * being invoked from parseMonitorConstraint().
	   *   (So lets not duplicate the work...)
	   *
	   * Note: parseMonitorConstraint() has a restricted version of
	   * parseSequentialOrSerialConstraint(), so we need to invoke
	   * the parseSequentialOrSerialConstraint() with the correct flag.
	   */
      ( LOOKAHEAD ( parseSequentialOrSerialConstraint ( thisConstraint,
							theUnIndent,
							false          ) )

	  ( parseSequentialOrSerialConstraint ( thisConstraint,
						theUnIndent,
						false          ) )

	     /* Allow Maximum Activate, Maximum Trigger, Monitor Period...
	      * Note: Includes parseSimpleConstraint ( ... )
	      * Note: Includes restricted version of:
	      *          parseSequentialOrSerialConstraint ( ... ).
	      */
	| ( LOOKAHEAD ( parseMonitorConstraint ( thisConstraint,
						 theUnIndent    ) )
	       parseMonitorConstraint ( thisConstraint, theUnIndent )
	    |  parseDistributedOnAgentConstraint ( thisConstraint,
						   theUnIndent )
	  )
      )
	
              /* Simplistic constraints */
    | (   ( token = <PARALLEL>
	      { thisConstraint
		  . setConstraintType ( DataConstraint.PARALLEL ); }
	  )
        | ( token = <WAIT>
	      { thisConstraint
		  . setConstraintType ( DataConstraint.WAIT ); }
	  )
      )
        {
	  thisConstraint . setLineNumber ( token.beginLine + 1 );
          parseFluff ( thisConstraint, token, theUnIndent );
          thisConstraint
            . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
        }



              /* Fancy Constraints */

    | ( token = <DISABLE_UNTIL>
	  {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
	    thisConstraint . setConstraintOption ( DataConstraint.INVALID );
	    parseFluff ( thisConstraint, token, theUnIndent );
	    thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
	  }
	
	 ( LOOKAHEAD ( parseEvent ( thisConstraint, theUnIndent ) )
	     parseEvent ( thisConstraint, theUnIndent )
	         {
		   thisConstraint . setConstraintType (
					  DataConstraint.DISABLE_UNTIL_EVENT );
		 }

	   | parseAbsoluteTimeExpression ( thisConstraint, theUnIndent ) 
	         {
		   thisConstraint . setConstraintType (
					   DataConstraint.DISABLE_UNTIL_TIME );
		 }
	 ) /* parseEvent | parseAbsoluteTimeExpression */

      ) /* DISABLE_UNTIL */


    | ( token = <DISABLE_FOR>
	  {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
	    thisConstraint . setConstraintOption ( DataConstraint.INVALID );
	  }
	
	parseTrailingChunkIncludingAfterEvent ( thisConstraint,
						token, keywordIndex,
						theUnIndent )
	{
	  thisConstraint
	    . setConstraintType ( DataConstraint.DISABLE_FOR_TIME );
	  keywordIndex += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
	}
      ) /* DISABLE_FOR */


    | ( token = <DISABLE>
          {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );

		/* Establish the no-event-option default */
	    thisConstraint . setConstraintOption ( DataConstraint.INVALID );
          }

        [
          constraintOptionToken = parseConstraintOption()
            {
              thisConstraint . setConstraintOptionStringWithoutParsing (
                                             constraintOptionToken . image );
              parseFluff ( thisConstraint, constraintOptionToken, theUnIndent);
              thisConstraint . setIndex ( DataConstraint.CONSTRAINT_OPTION );
            }
        ]

        (
	    (
	      (   token = <FOR_CS>
	        | token = <FOR_CI>
	      )

	      parseTrailingChunkIncludingAfterEvent ( thisConstraint,
						      token, keywordIndex,
						      theUnIndent )
	        {
		  thisConstraint
		    . setConstraintType ( DataConstraint.DISABLE_FOR_TIME );
		  keywordIndex
		    += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
		}

            ) /* token = <FOR...> */


          | ( token = <UNTIL>
                {
                  parseFluff ( thisConstraint, token, theUnIndent );
                  thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
                }

              ( LOOKAHEAD ( parseEvent ( thisConstraint, theUnIndent ) )
		  parseEvent ( thisConstraint, theUnIndent )
		    {
		      thisConstraint . setConstraintType (
                                          DataConstraint.DISABLE_UNTIL_EVENT );
		    }

		| parseAbsoluteTimeExpression ( thisConstraint, theUnIndent ) 
                      {
                        thisConstraint . setConstraintType (
                                           DataConstraint.DISABLE_UNTIL_TIME );
                      }
	      ) /* parseEvent | parseAbsoluteTimeExpression */
	    ) /* | ( token = <UNTIL> ... */
	) /* <token = <FOR...> | token = <UNTIL> */
      ) /* | ( token = <DISABLE> ... */




    | ( token = <TERMINATE_AT>
	  {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
	    parseFluff ( thisConstraint, token, theUnIndent );
	    thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
	  }
	
	 ( LOOKAHEAD ( parseEvent ( thisConstraint, theUnIndent ) )
	     parseEvent ( thisConstraint, theUnIndent )
	       {
		 thisConstraint . setConstraintType (
                                           DataConstraint.TERMINATE_AT_EVENT );
	       }

	   | parseAbsoluteTimeExpression ( thisConstraint, theUnIndent ) 
	       {
		 thisConstraint . setConstraintType (
                                            DataConstraint.TERMINATE_AT_TIME );
	       }
	 ) /* parseEvent | parseAbsoluteTimeExpression */

      ) /* TERMINATE_AT */


    | ( token = <TERMINATE_IN>
	  {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
	  }

	parseTrailingChunkIncludingAfterEvent ( thisConstraint,
						token, keywordIndex,
						theUnIndent )
	{
	  thisConstraint
	    . setConstraintType ( DataConstraint.TERMINATE_IN_TIME );
	  keywordIndex += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
	}
      ) /* TERMINATE_IN */


    | ( token = <TERMINATE>
          {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
		/* Note that we have no "AFTER" event by default... */
	    thisConstraint . setEventTagTask ( null );
		/* And NO time values by default. */
	    thisConstraint . setHasTime ( false );
		/* Set default constraint-type (If not further qualified) */
	    thisConstraint . setConstraintType ( DataConstraint.TERMINATE );
          }

        [
	    (
	      ( token = <IN> )

	      parseTrailingChunkIncludingAfterEvent ( thisConstraint,
						      token, keywordIndex,
						      theUnIndent )
	        {
		  thisConstraint
		    . setConstraintType ( DataConstraint.TERMINATE_IN_TIME );
		  keywordIndex
		    += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
		}

            ) /* token = <IN> */


          | ( token = <AT>
                {
                  parseFluff ( thisConstraint, token, theUnIndent );
                  thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
                }

              ( LOOKAHEAD ( parseEvent ( thisConstraint, theUnIndent ) )
		  parseEvent ( thisConstraint, theUnIndent )
		    {
		      thisConstraint . setConstraintType (
                                           DataConstraint.TERMINATE_AT_EVENT );
		    }

		| parseAbsoluteTimeExpression ( thisConstraint, theUnIndent ) 
		    {
		      thisConstraint . setConstraintType (
                                           DataConstraint.TERMINATE_AT_TIME );
		    }
	      ) /* parseEvent | parseAbsoluteTimeExpression */
	    ) /* | ( token = <AT> ... */
	] /* <token = <IN> | token = <AT> */
      ) /* | ( token = <TERMINATE> ... */




    | ( token = <ACTIVATE_AT>
	  {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
	    parseFluff ( thisConstraint, token, theUnIndent );
	    thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
	  }
	
	 ( LOOKAHEAD ( parseEvent ( thisConstraint, theUnIndent ) )
	     parseEvent ( thisConstraint, theUnIndent )
	       {
		 thisConstraint . setConstraintType (
					    DataConstraint.ACTIVATE_AT_EVENT );
	       }
	     
	   | parseAbsoluteTimeExpression ( thisConstraint, theUnIndent ) 
	       {
		 thisConstraint . setConstraintType (
					     DataConstraint.ACTIVATE_AT_TIME );
	       }
	 ) /* parseEvent | parseAbsoluteTimeExpression */

      ) /* ACTIVATE_AT */


    | ( token = <ACTIVATE_IN>
	  {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
	  }

	parseTrailingChunkIncludingAfterEvent ( thisConstraint,
						token, keywordIndex,
						theUnIndent )
	{
	  thisConstraint
	    . setConstraintType ( DataConstraint.ACTIVATE_IN_TIME );
	  keywordIndex += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
	}
      ) /* ACTIVATE_IN */


    | ( token = <ACTIVATE>
          {
	    thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
		/* Note that we have no "AFTER" event by default... */
	    thisConstraint . setEventTagTask ( null );
		/* And NO time values by default. */
	    thisConstraint . setHasTime ( false );
		/* Set default constraint-type (If not further qualified) */
	    thisConstraint . setConstraintType ( DataConstraint.ACTIVATE );
          }

        [
	    (
	      ( token = <IN> )

	      parseTrailingChunkIncludingAfterEvent ( thisConstraint,
						      token, keywordIndex,
						      theUnIndent )
	        {
		  thisConstraint
		    . setConstraintType ( DataConstraint.ACTIVATE_IN_TIME );
		  keywordIndex
		    += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
		}

            ) /* token = <IN> */


          | ( token = <AT>
                {
                  parseFluff ( thisConstraint, token, theUnIndent );
                  thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
                }

              ( LOOKAHEAD ( parseEvent ( thisConstraint, theUnIndent ) )
		  parseEvent ( thisConstraint, theUnIndent )
		    {
		      thisConstraint . setConstraintType (
					    DataConstraint.ACTIVATE_AT_EVENT );
		    }

		| parseAbsoluteTimeExpression ( thisConstraint, theUnIndent ) 
		    {
		      thisConstraint . setConstraintType (
					     DataConstraint.ACTIVATE_AT_TIME );
		    }
	      ) /* parseEvent | parseAbsoluteTimeExpression */
	    ) /* | ( token = <AT> ... */
	] /* <token = <IN> | token = <AT> */
      ) /* | ( token = <ACTIVATE> ... */

  )
    { return thisConstraint; }
}


Token
parseConstraintOption ( ) :
{}
{
  (
      <HANDLING>
    | <EXPANSION>
    | <EXECUTION>
    | <ACHIEVEMENT>
    | <PLANNING>
  )
    { return getToken(0); }
}


Token
parseStateBoundary ( ) :
{}
{
  (
      <ENABLED>
    | <ACTIVE>
    | <COMPLETED>
  )
    { return getToken(0); }
}


void
parseTagTaskIdWithIndexes(DataConstraintTagTaskIndexes theTagTaskObject,
			  DataComponent                theTagTaskDataComponent,
			  int                          theUnIndent ) :
{
  DataVector      indexes = null; 
  Token           token;
  DataExpression  dataExpression;
}
{
  (
      ( token = parseIdToken()
          {
	    theTagTaskObject . setTagTask ( token.image );
	    parseFluff ( theTagTaskDataComponent, token, theUnIndent );
	    theTagTaskDataComponent
	      . setIndex ( DataConstraintTagTaskIndexes.TAG_TASK );
	  }

        ( token = <OPEN_BRACKET>
	    {
	      parseFluff ( theTagTaskDataComponent, token, theUnIndent );
	      if ( indexes == null )
		indexes = new DataVector();
	      theTagTaskDataComponent . setIndex (
		      DataConstraintTagTaskIndexes.BEGIN_TAG_TASK_INDEX
		    + indexes.count() );
	    }


	  (   dataExpression = parseExpressionObject ( theUnIndent )
		{
		  theTagTaskDataComponent . setIndex ( "" + indexes.count() );
		  indexes . addElement ( dataExpression );
		}

	    | token = <PERIOD>
	        {
		  parseFluff ( theTagTaskDataComponent, token, theUnIndent );
		  theTagTaskDataComponent . setIndex ( "" + indexes.count() );
		  indexes . addElement (
			DataConstraintTagTaskIndexes.DEFAULT_TAG_TASK_INDEX );
		}
	  )


	  token = <CLOSE_BRACKET>
	    {
	      parseFluff ( theTagTaskDataComponent, token, theUnIndent );
	      theTagTaskDataComponent . setIndex (
		      DataConstraintTagTaskIndexes.END_TAG_TASK_INDEX
		    + indexes.count() );
	    }

	)* /* ( token = <OPEN_BRACKET> ... */
           {
	     if ( indexes == null )
	       theTagTaskObject . setTagTaskIndexesWithoutParsing( null );
	     else
	     {
	       Object[]  tagIndexes = new Object [ indexes.count() ];
	       for ( int i=0;   i < indexes.count();   i++ )
	       {
		 tagIndexes [ i ] = indexes . elementAt(i);
	       }
	       theTagTaskObject . setTagTaskIndexesWithoutParsing (tagIndexes);
	     }
	   }
      ) /* ( token = parseIdToken() ... */
  )
    {}
}



DataConstraint
parseTagTask ( DataConstraint  theDataConstraint,
	       int             theUnIndent       ) :
{
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :   new DataConstraint() );

  DataVector      indexes = null; 
  Token           token, periodToken;
  DataExpression  dataExpression;
}
{
  (
      (   ( token = <PREVIOUS>
	      { thisConstraint . setEventTagTask ( DataConstraint.PREVIOUS ); }
	  )

	| (   ( token = <PARENT>
		  {
		    System.err.println (
				    TDLParser.getFilenameWithoutPathPlusColon()
				    + (token.beginLine + 1)
				    + TDLParser.PARENT_WARNING );
		  }
	      )
	    | token = <THIS_CS>
	    | token = <THIS_CI>
	  )
	    { thisConstraint . setEventTagTask ( DataConstraint.THIS ); }

	| (   ( token = <SELF>
		  {
		    System.err.println (
				    TDLParser.getFilenameWithoutPathPlusColon()
				    + (token.beginLine + 1)
				    + TDLParser.SELF_WARNING );
		  }
	      )
	    | ( token = <CHILD> )
	  )
	    { thisConstraint . setEventTagTask ( DataConstraint.CHILD ); }
      )
        {
	  parseFluff ( thisConstraint, token, theUnIndent );
	  thisConstraint . setIndex ( DataConstraint.TAG_TASK );
	  thisConstraint . setEventTagTaskIndexesWithoutParsing ( null );
	}


    | ( parseTagTaskIdWithIndexes ( thisConstraint, thisConstraint,
				    theUnIndent ) )
  )
    { return thisConstraint; }
}



DataConstraint
parseEvent ( DataConstraint  theDataConstraint,
	     int             theUnIndent       ) :
{
  DataConstraint thisConstraint             = null;
  Token          eventConstraintOptionToken = null;
  Token          stateBoundaryToken         = null;
}
{
  (
    thisConstraint = parseTagTask ( theDataConstraint, theUnIndent )
      {    /* Establish default of NO ConstraintOption... */
	thisConstraint . setEventConstraintOption ( DataConstraint.INVALID );
      }

    [
      eventConstraintOptionToken = parseConstraintOption()
        {
	  thisConstraint . setEventConstraintOptionStringWithoutParsing (
					  eventConstraintOptionToken . image );
	  parseFluff ( thisConstraint, eventConstraintOptionToken,
		       theUnIndent );
	  thisConstraint . setIndex ( DataConstraint.EVENT_CONSTRAINT_OPTION );
	}
    ]

    stateBoundaryToken = parseStateBoundary()
      {
	thisConstraint . setStateBoundaryStringWithoutParsing (
						  stateBoundaryToken . image );
	parseFluff ( thisConstraint, stateBoundaryToken, theUnIndent );
	thisConstraint . setIndex ( DataConstraint.STATE_BOUNDARY );
      }
  )
    {
      return thisConstraint;
    }
}



DataConstraint
parseAbsoluteTimeExpression ( DataConstraint  theDataConstraint,
			      int             theUnIndent       ) :
{
  DataConstraint thisConstraint = (   ( theDataConstraint != null )
				    ?   theDataConstraint
				    :   new DataConstraint() );
  DataExpression dataExpression;
}
{
  ( LOOKAHEAD ( parseAbsoluteTime ( thisConstraint, theUnIndent ) )
      parseAbsoluteTime ( thisConstraint, theUnIndent )
        {
	  thisConstraint . setTimeExpression ( null );
	}

	/* Disallow the comma operator in this expression */
    | dataExpression = parseAssignmentExpressionObject ( getToken(0).endColumn,
							 false )
        {
	  thisConstraint . setTimeExpression ( dataExpression );
	}
  )
    { return thisConstraint; }
}


DataConstraint
parseRelativeTimeExpression ( DataConstraint  theDataConstraint,
			      int             theUnIndent       ) :
{
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :   new DataConstraint() );
  DataExpression dataExpression;
}
{
  ( LOOKAHEAD ( parseRelativeTime ( thisConstraint, theUnIndent ) )
      parseRelativeTime ( thisConstraint, theUnIndent )
        {
	  thisConstraint . setTimeExpression ( null );
	}

	/* Disallow the comma operator in this expression */
    | dataExpression = parseAssignmentExpressionObject ( getToken(0).endColumn,
							 false )
        {
	  thisConstraint . setTimeExpression ( dataExpression );
	}
  )
    { return thisConstraint; }
}




DataConstraint
parseAbsoluteTime ( DataConstraint  theDataConstraint,
		    int             theUnIndent       ) :
{
  DataConstraint thisConstraint = (   ( theDataConstraint != null )
				    ?   theDataConstraint
				    :   new DataConstraint() );
  Token    token,
           hours             = null,
	   minutes           = null,
	   seconds           = null,
           fractionOfASecond = null;
  int      intValue;
  String   errorString       = null;
  String   tmpString;
}
{
  (
    (   hours = <INTEGER_CONSTANT>
      | hours = <NON_NEGATIVE_INTEGER_CONSTANT>
    )
      {
	parseFluff ( thisConstraint, hours, theUnIndent );
	intValue = Integer.parseInt ( hours.image );
	if ( intValue < 0 )
	  errorString =  "Hours (" + hours.image + ") < 0.";
	if ( intValue > 23 )
	  errorString = "Hours (" + hours.image + ") > 23.";
	if ( errorString != null )
	{
	  throw generateParseException ( hours, errorString );
	}
	else
	{
	  thisConstraint . setHoursWithoutParsing ( hours.image );
	  thisConstraint . setIndex ( DataConstraint.PRE_TIME_HOURS );
	}
      }

    token = <COLON>
      {
	parseFluff ( thisConstraint, token, theUnIndent );
	thisConstraint . setIndex ( DataConstraint.POST_TIME_HOURS );
      }

    (   minutes = <INTEGER_CONSTANT>
      | minutes = <NON_NEGATIVE_INTEGER_CONSTANT>
    )
      {
	parseFluff ( thisConstraint, minutes, theUnIndent );
	intValue = Integer.parseInt ( minutes.image );
	if ( intValue < 0 )
	  errorString = "Minutes (" + minutes.image + ") < 0.";
	if ( intValue > 59 )
	  errorString = "Minutes (" + minutes.image + ") > 59.";
	if ( errorString != null )
	{
	  throw generateParseException ( minutes, errorString );
	}
	else
	{
	  thisConstraint . setMinutesWithoutParsing ( minutes.image );
	  thisConstraint . setIndex ( DataConstraint.PRE_TIME_MINUTES );
	}
      }


    token = <COLON>
      {
	parseFluff ( thisConstraint, token, theUnIndent );
	thisConstraint . setIndex ( DataConstraint.POST_TIME_MINUTES);
      }

    (   
        ( seconds = <FLOAT_CONSTANT_BASIC>
	    {
	      parseFluff ( thisConstraint, seconds, theUnIndent );
	      thisConstraint . setIndex ( DataConstraint.PRE_TIME_SECONDS );
	      thisConstraint . removeIndex( DataConstraint.POST_TIME_SECONDS );
	      thisConstraint . removeIndex (
			       DataConstraint.PRE_TIME_FRACTIONS_OF_A_SECOND );

		    /* If there is no period, something is very very wrong. */
	      if ( seconds.image . indexOf ( '.' ) == -1 )
	      {
		throw generateParseException ( seconds,
					   "Internal error:  No <PERIOD> "
					 + "found in floating point number." );
	      }

		    /* If the period is the first character */
	      else if ( seconds.image . startsWith ( "." ) )
	      {
		thisConstraint . setSecondsWithoutParsing ( "0" );
	      }

		    /* Lets extract the seconds the hard way... */
	      else
	      {
		tmpString = seconds.image
			      . substring ( 0,
					    seconds.image . indexOf( '.' ) );
		intValue = Integer.parseInt ( tmpString );

		if ( intValue < 0 )
		  errorString =  "Seconds (" + seconds.image + ") < 0.";
		if ( intValue > 59 )
		  errorString = "Seconds (" + seconds.image + ") > 59.";
		if ( errorString != null )
		  throw generateParseException ( seconds, errorString );
		else
		  thisConstraint . setSecondsWithoutParsing ( tmpString );
	      }

		    /* And set the fractions-of-a-second value... */
	      if (    ( seconds.image . indexOf ( '.' ) + 1 )
		   >= ( seconds.image . length()            ) )
	      {
		thisConstraint . setFractionsOfASecondWithoutParsing ( "0" );
	      }
	      else
	      {
		thisConstraint . setFractionsOfASecondWithoutParsing (
		    seconds.image . substring ( seconds.image . indexOf ( '.' )
						+ 1 ) );
	      }
	    }
	)


      | ( (   seconds = <INTEGER_CONSTANT>
	    | seconds = <NON_NEGATIVE_INTEGER_CONSTANT>
	  )
	    {
	      parseFluff ( thisConstraint, seconds, theUnIndent );
	      intValue = Integer.parseInt ( seconds.image );
	      if ( intValue < 0 )
		errorString =  "Seconds (" + seconds.image + ") < 0.";
	      if ( intValue > 59 )
		errorString = "Seconds (" + seconds.image + ") > 59.";
	      if ( errorString != null )
		throw generateParseException ( seconds, errorString );
	      else
	      {
		thisConstraint . setSecondsWithoutParsing ( seconds.image );
		thisConstraint . setIndex ( DataConstraint.PRE_TIME_SECONDS);
	      }
	    }

	  [ token = <PERIOD>
	      {
		parseFluff ( thisConstraint, token, theUnIndent );
		thisConstraint.setIndex ( DataConstraint.POST_TIME_SECONDS);
	      }


	    (   fractionOfASecond = <INTEGER_CONSTANT>
	      | fractionOfASecond = <NON_NEGATIVE_INTEGER_CONSTANT>
	    )
	      {
		parseFluff ( thisConstraint, fractionOfASecond, theUnIndent );
		thisConstraint . setFractionsOfASecondWithoutParsing (
						     fractionOfASecond.image );
		thisConstraint . setIndex (
			       DataConstraint.PRE_TIME_FRACTIONS_OF_A_SECOND );
	      }
	  ]
	)
    )
  )
    { return thisConstraint; }
}




DataConstraint
parseRelativeTime ( DataConstraint  theDataConstraint,
		    int             theUnIndent       ) :
{
  Token           token, hours, minutes, seconds, fractionOfASecond ;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :   new DataConstraint() );
}
{
  (
    (   hours = <INTEGER_CONSTANT>
      | hours = <NON_NEGATIVE_INTEGER_CONSTANT>
    )
      {
	parseFluff ( thisConstraint, hours, theUnIndent );
	thisConstraint . setHoursWithoutParsing ( hours.image );
	thisConstraint . setIndex ( DataConstraint.PRE_TIME_HOURS );
      }

    token = <COLON>
      {
	parseFluff ( thisConstraint, token, theUnIndent );
	thisConstraint . setIndex ( DataConstraint.POST_TIME_HOURS );
      }


    (   minutes = <INTEGER_CONSTANT>
      | minutes = <NON_NEGATIVE_INTEGER_CONSTANT>
    )
      {
	parseFluff ( thisConstraint, minutes, theUnIndent );
	thisConstraint . setMinutesWithoutParsing ( minutes.image );
	thisConstraint . setIndex ( DataConstraint.PRE_TIME_MINUTES );
      }

    token = <COLON>
      {
	parseFluff ( thisConstraint, token, theUnIndent );
	thisConstraint . setIndex ( DataConstraint.POST_TIME_MINUTES );
      }


    (
        seconds = <FLOAT_CONSTANT_BASIC>
	  {
	    parseFluff ( thisConstraint, seconds, theUnIndent );
	    thisConstraint . setIndex ( DataConstraint.PRE_TIME_SECONDS );
	    thisConstraint . removeIndex ( DataConstraint.POST_TIME_SECONDS );
	    thisConstraint
	      . removeIndex ( DataConstraint.PRE_TIME_FRACTIONS_OF_A_SECOND );

		/* If there is no period, something is very very wrong. */
	    if ( seconds.image . indexOf ( '.' ) == -1 )
	    {
	      throw generateParseException ( seconds,
					   "Internal error:  No <PERIOD> "
					 + "found in floating point number." );
	    }

		/* If the period is the first character */
	    else if ( seconds.image . startsWith ( "." ) )
	    {
	      thisConstraint . setSecondsWithoutParsing ( "0" );
	    }

		/* Lets extract the seconds the hard way... */
	    else
	    {
	      thisConstraint . setSecondsWithoutParsing (
		seconds.image . substring ( 0,
					    seconds.image . indexOf( '.' ) ) );
	    }


		/* And set the fractions-of-a-second value... */
	    if (    ( seconds.image . indexOf ( '.' ) + 1 )
		 >= ( seconds.image . length()            ) )
	    {
	      thisConstraint . setFractionsOfASecondWithoutParsing ( "0" );
	    }
	    else
	    {
	      thisConstraint . setFractionsOfASecondWithoutParsing (
		seconds.image . substring( seconds.image . indexOf('.') + 1 ));
	    }
	  }


      | ( (   seconds = <INTEGER_CONSTANT>
	    | seconds = <NON_NEGATIVE_INTEGER_CONSTANT>
	  )
            {
	      parseFluff ( thisConstraint, seconds, theUnIndent );
	      thisConstraint . setSecondsWithoutParsing ( seconds.image );
	      thisConstraint . setIndex ( DataConstraint.PRE_TIME_SECONDS );
	    }

	  [ token = <PERIOD>
	      {
		parseFluff ( thisConstraint, token, theUnIndent );
		thisConstraint . setIndex ( DataConstraint.POST_TIME_SECONDS );
	      }

	    (   fractionOfASecond = <INTEGER_CONSTANT>
	      | fractionOfASecond = <NON_NEGATIVE_INTEGER_CONSTANT>
	    )
	      {
		parseFluff ( thisConstraint, fractionOfASecond, theUnIndent );
		thisConstraint . setFractionsOfASecondWithoutParsing (
						     fractionOfASecond.image );
		thisConstraint
		  . setIndex ( DataConstraint.PRE_TIME_FRACTIONS_OF_A_SECOND );
	      }
	  ]
	)
    )
  )
    { return thisConstraint; }
}




/** Extremely useful, if somewhat hard to describe routine...
  * It processes the last token, then parses <relative-time>,
  * followed by an optional "AFTER event" clause.
  */
DataConstraint
parseTrailingChunkIncludingAfterEvent ( DataConstraint  theDataConstraint,
					Token           theInitialToken,
					int             theKeywordIndex,
					int             theUnIndent       ) :
{
  DataConstraint thisConstraint = (   ( theDataConstraint != null )
				    ?   theDataConstraint
				    :   new DataConstraint() );
  Token    token;

	/* Handle initial token processing */
  parseFluff ( thisConstraint, theInitialToken, theUnIndent );
  thisConstraint . setIndex ( DataConstraint.KEYWORD + (theKeywordIndex++) );
	/* Note that we have no "AFTER" event by default... */
  thisConstraint . setEventTagTask ( null );
}
{
  (
     parseRelativeTimeExpression ( thisConstraint, theUnIndent )

     [
       token = <AFTER>
         {
	   parseFluff ( thisConstraint, token, theUnIndent );
	   thisConstraint
	     . setIndex ( DataConstraint.KEYWORD + (theKeywordIndex++) );
	 }

       parseEvent ( thisConstraint, theUnIndent )
     ]
  )
    { return thisConstraint; }
}



DataConstraintStatement
parseConstraintStatement ( int theUnIndent ) :
{
  DataVector               indexes = null; 
  Token                    token = getToken(1); /* The First Token */
  DataConstraintStatement  constraintStatement = new DataConstraintStatement();
  DataExpression           dataExpression;
}
{
  ( (   (   ( token = <PARENT>
		{
		  System.err.println (
				    TDLParser.getFilenameWithoutPathPlusColon()
				    + (token.beginLine + 1)
				    + TDLParser.PARENT_WARNING );
		}
	    )
	  | token = <THIS_CS>
	  | token = <THIS_CI>
	)
	  {
	    constraintStatement . setTaskTag ( DataConstraintStatement.THIS );
	    parseFluff ( constraintStatement, token, theUnIndent );
	    constraintStatement . setIndex ( DataConstraintStatement.TAG_TASK);
	  }

      | ( parseTagTaskIdWithIndexes ( constraintStatement, constraintStatement,
				      theUnIndent ) )
    )
      {
	constraintStatement . setLineNumber ( token.beginLine + 1 );
      }

    parseConstraint ( constraintStatement . getConstraint(), theUnIndent )

    token = <SEMICOLON>
      {
	parseFluff ( constraintStatement, token, theUnIndent );
	constraintStatement . setIndex ( DataConstraintStatement.SEMICOLON );
      }
  )
    { return constraintStatement; }
}



/*
 * This constraint, unlike most constraints, assume's the "PARENT" value
 * is a TCM_Task_Tree_Ref object.
 */
DataConstraint
parseTcmTaskTreeParentConstraint ( DataConstraint theDataConstraint,
				   int            theUnIndent       ) :
{
  Token           token;
  int             keywordIndex = 0;
  DataExpression  parentDataExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :  new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  (
	/* PARENT "TCM_Task_Tree_Ref" constraint */
    token = <PARENT>
      {
	thisConstraint
	. setConstraintType ( DataConstraint.TCM_TASK_TREE_PARENT );
	thisConstraint . setLineNumber ( token.beginLine + 1 );
	parseFluff ( thisConstraint, token, theUnIndent );
	thisConstraint
	  . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
      }

    parentDataExpression = parseAssignmentExpressionObject( theUnIndent, true )
      {
	thisConstraint
	  . setTcmTaskTreeParentExpression ( parentDataExpression );
      }
  )
    { return thisConstraint; }
}


/*
 * This constraint, unlike most constraints, assume's the "TDL_REF_IN" value
 * is a TCM_Task_Tree_Ref object.
 */
DataConstraint
parseTdlRefInConstraint ( DataConstraint theDataConstraint,
			  int            theUnIndent       ) :
{
  Token           token;
  int             keywordIndex = 0;
  DataExpression  tdlRefInExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :  new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  (
	/* TDL_REF [ IN ] "TCM_Task_Tree_Ref-value" constraint */
    (   ( token = <TDL_REF>
	    {
	      thisConstraint . setConstraintType ( DataConstraint.TDL_REF_IN );
	      thisConstraint . setLineNumber ( token.beginLine + 1 );
	      parseFluff ( thisConstraint, token, theUnIndent );
	      thisConstraint
	        . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
	    }

	  [ token = <IN>
              {
		parseFluff ( thisConstraint, token, theUnIndent );
		thisConstraint
	          . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
	      }
	  ]
	)

      | ( token = <TDL_REF_IN>
	    {
	      thisConstraint . setConstraintType ( DataConstraint.TDL_REF_IN );
	      thisConstraint . setLineNumber ( token.beginLine + 1 );
	      parseFluff ( thisConstraint, token, theUnIndent );
	      thisConstraint
	        . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
	    }
        )
    )

//da0g: Double-check #line number macros
    tdlRefInExpression = parseAssignmentExpressionObject ( theUnIndent, true )
      {
	thisConstraint . setTdlRefInExpression ( tdlRefInExpression );
      }
  )
    { return thisConstraint; }
}


/*
 * Assume's the "NAME" value evaluates to a TCM (STRING) type.
 */
DataConstraint
parseTcmTaskTreeNameConstraint ( DataConstraint theDataConstraint,
				 int            theUnIndent       ) :
{
  Token           token;
  int             keywordIndex = 0;
  DataExpression  nameDataExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
				     ?   theDataConstraint
				     :  new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
}
{
  (
	/* NAME "(STRING)" constraint */
    token = <NAME>
      {
	thisConstraint
	. setConstraintType ( DataConstraint.TCM_TASK_TREE_NAME );
	thisConstraint . setLineNumber ( token.beginLine + 1 );
	parseFluff ( thisConstraint, token, theUnIndent );
	thisConstraint
	  . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
      }

    nameDataExpression = parseAssignmentExpressionObject( theUnIndent, true )
      {
	thisConstraint . setTcmTaskTreeNameExpression ( nameDataExpression );
      }
  )
    { return thisConstraint; }
}




/************************/
/*** Task Spawning... ***/
/************************/


DataSpawnTask
// da0g marker
//parseSpawnTask_TaskOnly ( DataSpawnTask theDataSpawnTask,
parseSpawnTask_ScopedTaskOnly ( DataSpawnTask theDataSpawnTask,
				int           theUnIndent      ) :
{
  Token           token;
  DataExpression  dataExpression = null;
  DataSpawnTask   spawnTask = ( ( theDataSpawnTask != null )
			       ?  theDataSpawnTask : new DataSpawnTask() );
}
{
  (
    token = parseScopedIdentifier( spawnTask . getTaskScope() )
      {
	parseFluff ( spawnTask, token, theUnIndent );
	spawnTask . setIndex ( DataSpawnTask.TASK_NAME_INDEX );
	spawnTask . setTaskName ( token.image );
      }

    token = <OPEN_PAREN>
      {
	parseFluff ( spawnTask, token, theUnIndent );
	spawnTask . setIndex ( DataSpawnTask.OPEN_PAREN );
      }


     /* Optional Comma separated argument-values */
    [
      dataExpression = parseAssignmentExpressionObject ( theUnIndent, false )
        {
	  spawnTask . addArgument ( dataExpression );
        }
      
      (
        token = <COMMA>
	  {
	    parseFluff ( dataExpression, token, theUnIndent );
	  }

        dataExpression = parseAssignmentExpressionObject ( theUnIndent, false )
          {
	    spawnTask . addArgument ( dataExpression );
	  }
      )*
    ]


    token = <CLOSE_PAREN>
      {
	if ( dataExpression != null )
	  parseFluff ( dataExpression, token, theUnIndent );
	else
	  parseFluff ( spawnTask, token, theUnIndent );
	spawnTask . setIndex ( DataSpawnTask.CLOSE_PAREN );
      }
  )
    { return spawnTask; }
}



DataSpawnTask
parseSpawnTask_ExpressionAndScopedTaskOnly ( DataSpawnTask theDataSpawnTask,
					     int           theUnIndent      ) :
{
  Token           token;
  DataExpression  dataExpression = null;
  DataSpawnTask   spawnTask = ( ( theDataSpawnTask != null )
			       ?  theDataSpawnTask : new DataSpawnTask() );
}
{
  (
    ( LOOKAHEAD (
	parseAssignmentExpressionObject_NoDereference ( null, theUnIndent )
	( <DEREFERENCE> | <PERIOD> )
	parseAssignmentExpressionObject_NoDereference ( null, theUnIndent ) )

      dataExpression = parseAssignmentExpressionObject_NoDereference (
							     dataExpression,
							     theUnIndent    )
        {
	  spawnTask . setTaskExpression ( dataExpression );
	}

      (   token = <DEREFERENCE>
        | token = <PERIOD>
      )
        {
	  parseFluff ( dataExpression, token, theUnIndent );
	  dataExpression . addSubcomponent ( token . image );
	}
    )*


    parseSpawnTask_ScopedTaskOnly ( spawnTask, theUnIndent )
  )
    { return spawnTask; }
}



//DataSpawnTask
//parseSpawnTask_TaskOnly ( DataSpawnTask theDataSpawnTask, int theUnIndent ) :


DataConstraint
parseSpawnTask_IndividualSpawnConstraint ( int theUnIndent ) :
{
  DataConstraint  dataConstraint;
}
{
  (
      dataConstraint = parseConstraint                  ( null, theUnIndent )

	/* PARENT     constraints can only be attached to the spawn statement*/
    | dataConstraint = parseTcmTaskTreeParentConstraint ( null, theUnIndent )

	/* TDL_REF_IN constraints can only be attached to the spawn statement*/
    | dataConstraint = parseTdlRefInConstraint          ( null, theUnIndent )

	/* NAME       constraints can only be attached to the spawn statement*/
    | dataConstraint = parseTcmTaskTreeNameConstraint   ( null, theUnIndent )
  )
    { return dataConstraint; }
}


DataSpawnTask
parseSpawnTask_ConstraintsOnly ( DataSpawnTask  theDataSpawnTask,
				 int            theUnIndent      ) :
{
  Token           token;
  DataConstraint  dataConstraint = null;
  DataSpawnTask   spawnTask = ( ( theDataSpawnTask != null )
			       ?  theDataSpawnTask : new DataSpawnTask() );
}
{
  (
    dataConstraint = parseSpawnTask_IndividualSpawnConstraint ( theUnIndent )
      {
	spawnTask . addConstraint ( dataConstraint );
      }

    (
      token = <COMMA>
        {
	  parseFluff ( dataConstraint, token, theUnIndent );
	}

      dataConstraint = parseSpawnTask_IndividualSpawnConstraint ( theUnIndent )
        {
	  spawnTask . addConstraint ( dataConstraint );
	}
    )*
  )
    { return spawnTask; }
}


DataSpawnTask
parseSpawnTask ( DataSpawnTask  theDataSpawnTask, int theUnIndent ) :
{
  Token           token;
  DataSpawnTask   spawnTask = ( ( theDataSpawnTask != null )
			       ?  theDataSpawnTask : new DataSpawnTask() );
}
{
  (
    token = <SPAWN>
      {
	spawnTask . setLineNumber ( token.beginLine + 1 );
	parseFluff ( spawnTask, token, theUnIndent );
	spawnTask . setIndex ( DataSpawnTask.SPAWN );
      }

    parseSpawnTask_ExpressionAndScopedTaskOnly ( spawnTask, theUnIndent )

	/* Parse optional constraint-clause. */
    [
      token = <WITH>
        {
	  parseFluff ( spawnTask, token, theUnIndent );
	  spawnTask . setIndex ( DataSpawnTask.WITH );
	}

      parseSpawnTask_ConstraintsOnly ( spawnTask, theUnIndent )
    ]


    token = <SEMICOLON>
      {
	parseFluff ( spawnTask, token, theUnIndent );
	spawnTask . setIndex ( DataSpawnTask.SEMICOLON );
      }
  )
    { return spawnTask; }
}



DataSpawnTask
parseLabeledSpawnTask ( DataSpawnTask  theDataSpawnTask, int theUnIndent ) :
{
  DataLabelStatement  dataLabel, oldLabel  = null;
  DataSpawnTask       spawnTask = ( ( theDataSpawnTask != null )
			           ?  theDataSpawnTask : new DataSpawnTask() );
}
{
  (
    ( LOOKAHEAD ( parseLabel ( theUnIndent, false ) )
        dataLabel = parseLabel ( theUnIndent, false )
      {
		  /* Order is important here to preserve parent information */
	if ( oldLabel == null )
	  spawnTask . setLabel ( dataLabel );
	else
	  oldLabel . setLabel ( dataLabel );
	oldLabel = dataLabel;
      }
    )*

    parseSpawnTask ( spawnTask, theUnIndent )
  )
    { return spawnTask; }
}


/*************************/
/*** TCM Task Binding ****/
/*************************/
DataBindTaskStatement
parseBindTaskStatement ( int theUnIndent ) :
{
  Token                   token;
  DataBindTaskStatement   dataBindTaskStatement = new DataBindTaskStatement();
  DataExpression          dataExpression = null;
}
{
  (
    token = <TDL_BIND>
      {
	dataBindTaskStatement . setLineNumber ( token.beginLine + 1 );
	parseFluff ( dataBindTaskStatement, token, theUnIndent );
	dataBindTaskStatement
	  . setIndex ( DataBindTaskStatement.BIND_INDEX );
      }

    token = <OPEN_PAREN>
      {
	parseFluff ( dataBindTaskStatement, token, theUnIndent );
	dataBindTaskStatement
	  . setIndex ( DataBindTaskStatement.OPEN_PAREN );
      }

    ( LOOKAHEAD( parseAssignmentExpressionObject ( theUnIndent, false )
		 <COMMA> parseIdToken() )

        ( dataExpression = parseAssignmentExpressionObject (theUnIndent, false)
	    {
	      dataBindTaskStatement
	        . setLineNumberOfTaskValueToBind ( token.next.beginLine + 1 );
	        /*parseFluff is dealt with in parseAssignmentExpressionObject*/
	      dataBindTaskStatement
	        . setTaskValueToBind ( dataExpression . toString() );
	      dataBindTaskStatement
	        . setIndex ( DataBindTaskStatement.TASK_VALUE );
	    }

	  token = <COMMA>
            {
	      parseFluff ( dataBindTaskStatement, token, theUnIndent );
	      dataBindTaskStatement
	        . setIndex ( DataBindTaskStatement.COMMA );
	    }

	  token = parseIdToken()
	    {
	      parseFluff ( dataBindTaskStatement, token, theUnIndent );
	      dataBindTaskStatement . setTaskNameToBind( token.image );
	      dataBindTaskStatement
	        . setIndex ( DataBindTaskStatement.TASK_NAME );
	    }
	)

      | token = parseIdToken()
	  {
	    dataBindTaskStatement
	      . setLineNumberOfTaskValueToBind ( token.beginLine + 1 );
	    parseFluff ( dataBindTaskStatement, token, theUnIndent );
	    dataBindTaskStatement . setTaskValueToBind ( token.image );
	    dataBindTaskStatement . setTaskNameToBind  ( null );
	    dataBindTaskStatement
	    . setIndex ( DataBindTaskStatement.TASK_VALUE );
	  }
    )


    token = <CLOSE_PAREN>
      {
	parseFluff ( dataBindTaskStatement, token, theUnIndent );
	dataBindTaskStatement
	  . setIndex ( DataBindTaskStatement.CLOSE_PAREN );
      }

    token = <SEMICOLON>
      {
	parseFluff ( dataBindTaskStatement, token, theUnIndent );
	dataBindTaskStatement
	  . setIndex ( DataBindTaskStatement.SEMICOLON );
      }
  )
    { return dataBindTaskStatement; }
}


/******************/
/*** Statements ***/
/******************/


DataStatement
parseStatement ( int theUnIndent, int theCompoundUnIndent ) :
{
  DataStatement returnValue = null;
}
{
  (
      returnValue = parseCompoundStatement          ( theCompoundUnIndent )

    | returnValue = parseWithDo                     ( theUnIndent )
    | returnValue = parseSpawnTask                  ( null, theUnIndent )
    | returnValue = parseBindTaskStatement          ( theUnIndent )

    | returnValue = parseSelectionStatement         ( theUnIndent )
    | returnValue = parseIterationStatement         ( theUnIndent )

	/* parseJumpStatement deals with C++ and TDL Jump statements */
    | returnValue = parseJumpStatement              ( theUnIndent )

	/* If the next token is an id, what do we have? */
    | ( LOOKAHEAD ( parseLabel ( theUnIndent, true ) )

		/* Was it a label? */
	  returnValue = parseLabeledStatement ( theUnIndent )

		/* If the next token is a "::", what do we have? */
	| ( LOOKAHEAD ( catchIllegalCode() )

		/* Throws a nice exception on outlawed code */
	      catchIllegalCode()

		/* Caveat Emptor:
		 *    LOOKAHEAD ( parseConstraintStatement ( theUnIndent ) )
		 * at one point was tripping a recursive lookahead bug and
		 * failing.  Unfortunately, it is also quite necessary.
		 * Watch out for this problem reoccuring.
		 */
	    | ( LOOKAHEAD ( parseConstraintStatement ( theUnIndent ) )

		    /* Was it a constraintStatement? */
		  returnValue = parseConstraintStatement ( theUnIndent )

		    /* ForInit does both Expression & Declaration Statements */
		| returnValue = parseForInitStatement ( theUnIndent )
	      )
          )
      )

 /* | parseTryBlock() -- Outlawed.  Checked in catchIllegalCode() */

  )
    {
      if ( returnValue == null )
      {
	System.err.println ( "[TDLParser:parseStatement] Error:  "
		   + "returnValue is null.  Possibly programmer error..." );
      }
      return returnValue;
    }
}


DataLabelStatement
parseLabel ( int theUnIndent, boolean theAllowCaseOrDefaultLabels ) :
{
  Token               token;
  DataLabelStatement  dataLabel = new DataLabelStatement();
}
{
  ( (
	  /* Label'ed statement */
        (
	  token = parseIdToken()
	    {
	      dataLabel . setLineNumber ( token.beginLine + 1 );
	      parseFluff ( dataLabel, token, theUnIndent );
	      dataLabel . setId    ( token.image );
	      dataLabel . setIndex ( DataLabelStatement.FIRST_TOKEN_INDEX );
	    }
	)

	/* case statement */
      | (
	  token = <CASE>
	    {
	      if ( theAllowCaseOrDefaultLabels == false )
	      {
		throw generateParseException ( token,
			      "A \"case ...:\" label is not permitted here." );
	      }
	      dataLabel . setIsCase ( true );
	      dataLabel . setLineNumber ( token.beginLine + 1 );
	      parseFluff ( dataLabel, token, theUnIndent );
	      dataLabel . addSubcomponent ( token.image );
	      dataLabel . setIndex ( DataLabelStatement.FIRST_TOKEN_INDEX );
	    }
	  parseConstantExpression()
	    {
	      parseMiscTokens ( dataLabel, token, theUnIndent );
	    }
	)

	/* default-case statement */
      | (
	  token = <DEFAULT_LABEL>
	    {
	      if ( theAllowCaseOrDefaultLabels == false )
	      {
		throw generateParseException ( token,
			       "A \"default:\" label is not permitted here." );
	      }
	      dataLabel . setIsDefault ( true );
	      dataLabel . setLineNumber ( token.beginLine + 1 );
	      parseFluff ( dataLabel, token, theUnIndent );
	      dataLabel . addSubcomponent ( token.image );
	      dataLabel . setIndex ( DataLabelStatement.FIRST_TOKEN_INDEX );
	    }
	)
    )

    token = <COLON>
      {
	parseFluff ( dataLabel, token, theUnIndent );
	dataLabel . setIndex ( DataLabelStatement.COLON );
      }
  )
    { return dataLabel; }
}


DataStatement
parseLabeledStatement ( int theUnIndent ) :
{
  DataLabelStatement   dataLabel, oldStatmentLabel;
  DataStatement        dataStatement;
}
{
  (
    dataLabel     = parseLabel     ( theUnIndent, true )
    dataStatement = parseStatement ( theUnIndent, theUnIndent )
  )
    {
	/* Order is important here to preserve parent information */
      oldStatmentLabel = dataStatement . getLabel();
      dataStatement . setLabel ( dataLabel );
      dataLabel     . setLabel ( oldStatmentLabel );
      return dataStatement;
    }
}


DataExpressionStatement
parseExpressionStatement ( int theUnIndent ) :
{
  Token                    token;
  Token                    firstToken     = getToken(1);
  DataExpression           dataExpression = null;
  DataExpressionStatement  dataExpressionStatement
				          = new DataExpressionStatement();
}
{
  (
     [
       dataExpression = parseExpressionObject ( theUnIndent )
         {
	   dataExpressionStatement . setIndex (
				    DataExpressionStatement.EXPRESSION_INDEX );
	 }
     ]

     token = <SEMICOLON>
       {
	 dataExpressionStatement . setLineNumber ( firstToken.beginLine + 1 );
	 dataExpressionStatement . setExpression ( dataExpression );
	 parseFluff ( dataExpressionStatement, token, theUnIndent );
	 dataExpressionStatement . setIndex (
				        DataExpressionStatement.SEMICOLON );
       }
  )
    { return dataExpressionStatement; }
}


DataCompoundStatement
parseCompoundStatement ( int theUnIndent ) :
{
  Token                  token;
  DataCompoundStatement  dataCompound = new DataCompoundStatement();
  DataStatement          dataStatement;
}
{
  ( token = <OPEN_BRACE>
      {
	dataCompound . setLineNumber ( token.beginLine + 1 );
	parseFluff ( dataCompound, token, theUnIndent );
	dataCompound . setIndex ( DataCompoundStatement.OPEN_BRACE );
      }

    ( dataStatement = parseStatement( theUnIndent + DataComponent.getIndent(),
				      theUnIndent + DataComponent.getIndent())
        {
	  dataCompound . addSubcomponent ( dataStatement );
	}
    )*
 
    token = <CLOSE_BRACE>
      {
	dataCompound . setLineNumberOfCloseBrace ( token.beginLine + 1 );
	parseFluff ( dataCompound, token, theUnIndent );
	dataCompound . setIndex ( DataCompoundStatement.CLOSE_BRACE );
      }
  )
    { return dataCompound; }
}


DataWithDoStatement
parseWithDo_Constraints ( DataWithDoStatement  theDataWithDoStatement,
			  int                  theUnIndent ) :
{
  Token                token;
  DataConstraint       dataConstraint = null;
  DataWithDoStatement  dataWithDoStatement
                         = (   ( theDataWithDoStatement != null )
			     ? theDataWithDoStatement
			     : new DataWithDoStatement() );
}
{
  (
    dataConstraint = parseConstraint ( null, theUnIndent )
      {
	dataWithDoStatement . addConstraint ( dataConstraint );
      }

    (
      token = <COMMA>
        {
	  parseFluff ( dataConstraint, token, theUnIndent );
	}

      dataConstraint = parseConstraint ( null, theUnIndent )
        {
	  dataWithDoStatement . addConstraint ( dataConstraint );
	}
    )*
  )
    {
	/* Parse the fluff off the next (future) token... */
      parseFluff ( dataConstraint, getToken(1), theUnIndent );
      return dataWithDoStatement;
    }
}

DataWithDoStatement
parseWithDo ( int theUnIndent ) :
{
  Token                token;
  DataWithDoStatement  dataWithDoStatement = new DataWithDoStatement();
  DataConstraint       dataConstraint      = null;
  DataStatement        dataStatement       = null;
}
{
  (
    token = <WITH>
      {
	dataWithDoStatement . setLineNumber ( token.beginLine + 1 );
	parseFluff ( dataWithDoStatement, token, theUnIndent );
	dataWithDoStatement . setIndex ( DataWithDoStatement.WITH );
      }

    token = <OPEN_PAREN>
      {
	parseFluff ( dataWithDoStatement, token, theUnIndent );
	dataWithDoStatement . setIndex ( DataWithDoStatement.OPEN_PAREN );
      }

    parseWithDo_Constraints ( dataWithDoStatement, theUnIndent )

    token = <CLOSE_PAREN>
      {
	dataWithDoStatement . setIndex ( DataWithDoStatement.CLOSE_PAREN );
      }

    dataStatement = parseStatement ( theUnIndent + DataComponent.getIndent(),
				     theUnIndent )
      {
	dataWithDoStatement . setStatement ( dataStatement );
      }
  )
    { return dataWithDoStatement; }
}



DataSelectionStatement
parseSelectionStatement ( int theUnIndent ) :
{
  DataSelectionStatement   dataSelectionStatement;
}
{
  (
      dataSelectionStatement = parseIfElse ( theUnIndent )
    | dataSelectionStatement = parseSwitch ( theUnIndent )
  )
    { return dataSelectionStatement; }
}


DataIterationStatement
parseIterationStatement ( int theUnIndent ) :
{
  DataIterationStatement  dataIterationStatement = null;
}
{
  (
      dataIterationStatement = parseFor     ( theUnIndent )
    | dataIterationStatement = parseWhile   ( theUnIndent )
    | dataIterationStatement = parseDoWhile ( theUnIndent )
  )
    { return dataIterationStatement; }
}


DataJumpStatement
parseJumpStatement ( int theUnIndent ) :
{
  Token                 token;
  DataJumpStatement     dataJumpStatement    = new DataJumpStatement();
  DataExpression        dataExpression       = null;
  DataSpawnTask         exceptionTask        = null;
}
{
  (
    (
        token = <BREAK>
	  { dataJumpStatement.setType ( DataJumpStatement.BREAK_TYPE    ); }

      | token = <CONTINUE>
	  { dataJumpStatement.setType ( DataJumpStatement.CONTINUE_TYPE ); }

      | ( token = <RETURN>
	    { dataJumpStatement.setType ( DataJumpStatement.RETURN_TYPE ); }

	  [ dataExpression = parseExpressionObject ( theUnIndent ) ]
	)

      | token = <SUCCESS>
	  { dataJumpStatement.setType ( DataJumpStatement.SUCCESS_TYPE  ); }

      | token = <POSTPONE>
	  { dataJumpStatement.setType ( DataJumpStatement.POSTPONE_TYPE ); }

/*
 * Remove the <BYPASS> Jump Statement from the TDL language for now...
 *
 *      | token = <BYPASS>
 *	  {
 *		/_* BYPASS can only be used inside Exception Handlers *_/
 *	    if ( getIsParsingExceptionHandlerBody() != true )
 *	    {
 *	      throw generateParseException ( token,
 *	        "Encountered BYPASS in a non-Exception-Handler Task.");
 *	    }
 *
 *	    dataJumpStatement.setType ( DataJumpStatement.BYPASS_TYPE   );
 *	  }
 */
      | ( token = <FAIL>
	    { dataJumpStatement.setType ( DataJumpStatement.FAIL_TYPE   ); }

	  [
	    exceptionTask = parseSpawnTask_ExpressionAndScopedTaskOnly (
						      null,
						      getToken(0).endColumn )
	  ]
	)
    )
      {
	parseFluff ( dataJumpStatement, token, theUnIndent );
	dataJumpStatement . setIndex ( DataJumpStatement.FIRST_TOKEN_INDEX );
	dataJumpStatement . setLineNumber     ( token.beginLine + 1 );
	dataJumpStatement . setDataExpression ( dataExpression );
	dataJumpStatement . setExceptionTask  ( exceptionTask );
      }


    token = <SEMICOLON>
      {
	parseFluff ( dataJumpStatement, token, theUnIndent );
	dataJumpStatement . setIndex ( DataJumpStatement.SEMICOLON );
      }
  )
    { return dataJumpStatement; }
}


void
catchIllegalCode ( ) :
{}
{
  (
	/* Some of these could have a global-scoping operator before them */
    [ <SCOPE> ]

    (   <GOTO>
      | <THROW>
      | <CATCH>
      | <FINALLY>
      | <SETJMP>
      | <LONGJMP>
      | <_SETJMP>
      | <_LONGJMP>
      | <SIGSETJMP>
      | <SIGLONGJMP>
    )
  )
    {
      throw generateParseException ( getToken(0),
		     "\"" + getToken(0).image + "\" "
		   + "Is not permitted inside Task Statements.\n"
		   + "(Consider using \"break\", \"continue\", or \"return\".)"
		   );
    }
}


DataDeclarationStatement
parseDeclarationStatement ( int theUnIndent ) :
{
  Token                      token      = getToken(0);
  Token                      firstToken = getToken(1);
  DataDeclarationStatement   dataDeclarationStatement
				        = new DataDeclarationStatement();
}
{
  (
    parseDeclaration()
      {
	dataDeclarationStatement . setLineNumber ( firstToken.beginLine + 1 );
	parseMiscTokens ( dataDeclarationStatement, token, theUnIndent );
	dataDeclarationStatement
	  . setIndex ( DataDeclarationStatement.FIRST_TOKEN_INDEX,
		       firstToken.image );
      }
  )
    { return dataDeclarationStatement; }
}


DataIfElseStatement
parseIfElse ( int theUnIndent ) :
{
  Token                token;
  DataExpression       dataExpression;
  DataStatement        dataStatement;
  DataIfElseStatement  dataIfElseStatement = new DataIfElseStatement();
}
{
  (
    token = <IF>
      {
	dataIfElseStatement . setLineNumber ( token.beginLine + 1 );
	parseFluff ( dataIfElseStatement, token, theUnIndent );
	dataIfElseStatement . setIndex ( DataIfElseStatement.IF );
      }

    token = <OPEN_PAREN>
      {
	parseFluff ( dataIfElseStatement, token, theUnIndent );
	dataIfElseStatement . setIndex ( DataIfElseStatement.OPEN_PAREN );
      }

	/* conditional expression */
    dataExpression = parseExpressionObject ( theUnIndent )
      {
	dataIfElseStatement . setExpression ( dataExpression );
      }

    token = <CLOSE_PAREN>
      {
	parseFluff ( dataExpression, token, theUnIndent );
	dataIfElseStatement . setIndex ( DataIfElseStatement.CLOSE_PAREN );
      }

    dataStatement = parseStatement ( theUnIndent + DataComponent.getIndent(),
				     theUnIndent )
      {
	dataIfElseStatement . setIfStatement ( dataStatement );
      }

	/* There is a problem here with "if() if() else" as to which "if"
	 * the "else" binds to.  This lookahead forces it to the innermost
	 * (nearest) "if".  (Ie: The second "if" in the example.)
	 */
    [ LOOKAHEAD ( <ELSE> )

      token = <ELSE>
        {
	  dataIfElseStatement . setLineNumberOfElse ( token.beginLine + 1 );
	  parseFluff ( dataIfElseStatement, token, theUnIndent );
	  dataIfElseStatement . setIndex ( DataIfElseStatement.ELSE );
	}


      dataStatement = parseStatement ( theUnIndent + DataComponent.getIndent(),
				       theUnIndent )
        {
	  dataIfElseStatement . setElseStatement ( dataStatement );
	}
    ]
  )
    { return dataIfElseStatement; }
}


DataSwitchStatement
parseSwitch ( int theUnIndent ) :
{
  Token                token;
  DataExpression       dataExpression;
  DataStatement        dataStatement;
  DataSwitchStatement  dataSwitchStatement = new DataSwitchStatement();
}
{
  (
    token = <SWITCH>
      {
	dataSwitchStatement . setLineNumber ( token.beginLine + 1 );
	parseFluff ( dataSwitchStatement, token, theUnIndent );
	dataSwitchStatement . setIndex ( dataSwitchStatement.SWITCH );
      }

    token = <OPEN_PAREN>
      {
	parseFluff ( dataSwitchStatement, token, theUnIndent );
	dataSwitchStatement . setIndex ( dataSwitchStatement.OPEN_PAREN );
      }

	/* conditional expression */
    dataExpression = parseExpressionObject ( theUnIndent )
      {
	dataSwitchStatement . setExpression ( dataExpression );
      }

    token = <CLOSE_PAREN>
      {
	parseFluff ( dataSwitchStatement, token, theUnIndent );
	dataSwitchStatement . setIndex ( dataSwitchStatement.CLOSE_PAREN );
      }

    dataStatement = parseStatement ( theUnIndent + DataComponent.getIndent(),
				     theUnIndent )
      {
	dataSwitchStatement . setStatement ( dataStatement );
      }
  )
    { return dataSwitchStatement; }
}



DataForStatement
parseFor ( int theUnIndent ) :
{
  Token             token;
  DataStatement     initialStatement    = null;
  DataExpression    testExpression      = null;
  DataExpression    iterationExpression = null;
  DataStatement     dataStatement;
  DataForStatement  dataForStatement = new DataForStatement();
}
{
  (
    token = <FOR_CS>
      {
	dataForStatement . setLineNumber ( token.beginLine + 1 );
	parseFluff ( dataForStatement, token, theUnIndent );
	dataForStatement . setIndex ( DataForStatement.FOR );
      }

    token = <OPEN_PAREN>
      {
	parseFluff ( dataForStatement, token, theUnIndent );
	dataForStatement . setIndex ( DataForStatement.OPEN_PAREN );
      }

	/* optional initializer expression/declaration */
    initialStatement = parseForInitStatement ( theUnIndent )
      {
	dataForStatement
	  . setInitialExpressionOrDeclarationStatement ( initialStatement );
      }


	/* optional conditional expression, stored below */
    [ testExpression = parseExpressionObject ( theUnIndent ) ]
    

    token = <SEMICOLON>
      {
	parseFluff ( dataForStatement, token, theUnIndent );
	dataForStatement . setIndex ( DataForStatement.SEMICOLON );
      }


	/* optional iteration expression, stored below */
    [ iterationExpression = parseExpressionObject ( theUnIndent ) ]


    token = <CLOSE_PAREN>
      {
	parseFluff ( dataForStatement, token, theUnIndent );
	dataForStatement . setIndex ( DataForStatement.CLOSE_PAREN );
      }

    dataStatement = parseStatement ( theUnIndent + DataComponent.getIndent(),
				     theUnIndent )
      {
	dataForStatement . setStatement ( dataStatement );
      }
  )
    {
	/* Store these here so we can set them to null if they don't exist.. */
      dataForStatement . setTestExpression      ( testExpression      );
      dataForStatement . setIterationExpression ( iterationExpression );

	/* And return the result. */
      return dataForStatement;
    }
}


DataStatement
parseForInitStatement ( int theUnIndent ) :
{
  DataStatement returnValue;
}
{
  ( LOOKAHEAD ( parseDeclarationStatement ( theUnIndent ) )
      returnValue = parseDeclarationStatement ( theUnIndent )
    | returnValue = parseExpressionStatement  ( theUnIndent )
  )
    { return returnValue; }
}


DataWhileStatement
parseWhile ( int theUnIndent ) :
{
  Token               token;
  DataExpression      dataExpression;
  DataStatement       dataStatement;
  DataWhileStatement  dataWhileStatement = new DataWhileStatement();
}
{
  (
    token = <WHILE>
      {
	dataWhileStatement . setLineNumber ( token.beginLine + 1 );
	parseFluff ( dataWhileStatement, token, theUnIndent );
	dataWhileStatement . setIndex ( DataWhileStatement.WHILE );
      }

    token = <OPEN_PAREN>
      {
	parseFluff ( dataWhileStatement, token, theUnIndent );
	dataWhileStatement . setIndex ( DataWhileStatement.OPEN_PAREN );
      }

	/* conditional expression */
    dataExpression = parseExpressionObject ( theUnIndent )
      {
	dataWhileStatement . setExpression ( dataExpression );
      }

    token = <CLOSE_PAREN>
      {
	parseFluff ( dataWhileStatement, token, theUnIndent );
	dataWhileStatement . setIndex ( DataWhileStatement.CLOSE_PAREN );
      }

    dataStatement = parseStatement ( theUnIndent + DataComponent.getIndent(),
				     theUnIndent )
      {
	dataWhileStatement . setStatement ( dataStatement );
      }
  )
    { return dataWhileStatement; }
}


DataDoWhileStatement
parseDoWhile ( int theUnIndent ) :
{
  Token                 token;
  DataExpression        dataExpression;
  DataStatement         dataStatement;
  DataDoWhileStatement  dataDoWhileStatement = new DataDoWhileStatement();
}
{
  (
    token = <DO>
      {
	dataDoWhileStatement . setLineNumber ( token.beginLine + 1 );
	parseFluff ( dataDoWhileStatement, token, theUnIndent );
	dataDoWhileStatement . setIndex ( DataDoWhileStatement.DO );
      }

    dataStatement = parseStatement ( theUnIndent + DataComponent.getIndent(),
				     theUnIndent )
      {
	dataDoWhileStatement . setStatement ( dataStatement );
      }

    token = <WHILE>
      {
	parseFluff ( dataDoWhileStatement, token, theUnIndent );
	dataDoWhileStatement . setIndex ( DataDoWhileStatement.WHILE );
      }

    token = <OPEN_PAREN>
      {
	parseFluff ( dataDoWhileStatement, token, theUnIndent );
	dataDoWhileStatement . setIndex ( DataDoWhileStatement.OPEN_PAREN );
      }

	/* conditional expression */
    dataExpression = parseExpressionObject ( theUnIndent )
      {
	dataDoWhileStatement . setExpression ( dataExpression );
      }

    token = <CLOSE_PAREN>
      {
	parseFluff ( dataDoWhileStatement, token, theUnIndent );
	dataDoWhileStatement . setIndex ( DataDoWhileStatement.CLOSE_PAREN );
      }

    token = <SEMICOLON>
      {
	parseFluff ( dataDoWhileStatement, token, theUnIndent );
	dataDoWhileStatement . setIndex ( DataDoWhileStatement.SEMICOLON );
      }
  )
    { return dataDoWhileStatement; }
}



DataExpression
parseExpressionObject ( int theUnIndent ) :
{
  Token           token          = getToken(0);
  Token           firstToken     = getToken(1);
  DataExpression  dataExpression = new DataExpression();
}
{
  (
    parseExpression()
      {
	dataExpression . setLineNumber ( firstToken.beginLine + 1 );
	parseMiscTokens ( dataExpression, token, theUnIndent );
	dataExpression . setIndex ( DataExpression.FIRST_TOKEN_INDEX,
				    firstToken.image );
      }
  )
    { return dataExpression; }
}



DataExpression
parseConstantExpressionObject ( int theUnIndent ) :
{
  Token           token          = getToken(0);
  Token           firstToken     = getToken(1);
  DataExpression  dataExpression = new DataExpression();
}
{
  (
    parseConstantExpression()
      {
	dataExpression . setLineNumber ( firstToken.beginLine + 1 );
	parseMiscTokens ( dataExpression, token, theUnIndent );
	dataExpression . setIndex ( DataExpression.FIRST_TOKEN_INDEX,
				    firstToken.image );
      }
  )
    { return dataExpression; }
}



	/* Sometime we just can't deal with the comma operator
	 * like in with-do constrants, or argument defaults...
	 */
DataExpression
parseAssignmentExpressionObject ( int      theUnIndent,
				  boolean  theLineNumberStartsAtFirstToken ) :
{
  Token           token          = getToken(0);
  Token           firstToken     = getToken(1);
  DataExpression  dataExpression = new DataExpression();
}
{
  (
    parseAssignmentExpression()
      {
	parseMiscTokens ( dataExpression, token, theUnIndent );

	if ( theLineNumberStartsAtFirstToken == false )
	{
	    /* "token" is the last token before our Assignment-Expression */
	  dataExpression . setLineNumber ( token . endLine + 1 );
	}
	else
	{
	  dataExpression . setLineNumber ( firstToken.beginLine + 1 );
	  dataExpression . setIndex ( DataExpression.FIRST_TOKEN_INDEX,
				      firstToken.image );
	}
      }
  )
    { return dataExpression; }
}



DataExpression
parseAssignmentExpressionObject_NoDereference (
					   DataExpression theDataExpression,
					   int            theUnIndent       ) :
{
  Token           token          = getToken(0);
  Token           firstToken     = getToken(1);
  DataExpression  dataExpression = ( ( theDataExpression != null )
				    ?  theDataExpression
				    : new DataExpression() );
}
{
  (
    parseAssignmentExpression_NoDereference()
      {
	parseMiscTokens ( dataExpression, token, theUnIndent );
	if ( theDataExpression == null )
	{
	  dataExpression . setLineNumber ( firstToken.beginLine + 1 );
	  dataExpression . setIndex ( DataExpression.FIRST_TOKEN_INDEX,
				      firstToken.image );
	}
      }
  )
    { return dataExpression; }
}

/********************/
/***  Basic Types ***/
/********************/

  /* Note:  Includes templateClassNames as class-names. */
void
parseClassName ( ) :
{}
{
  ( LOOKAHEAD ( parseTemplateClassName() )
      parseTemplateClassName()
    | parseIdToken()
  )
    {}
}

void
parseEnumName ( ) :
{}
{
  (
    parseIdToken()
  )
    {}
}

void
parseTypedefName ( ) :
{}
{
  (
    parseIdToken()
  )
    {}
}

void
parseTemplateName ( ) :
{}
{
  (
    parseIdToken()
  )
    {}
}



/******************************/
/***  Expression parsing..  ***/
/******************************/

void
parseExpression ( ) :
{}
{
  (
    parseAssignmentExpression()
    ( <COMMA> parseAssignmentExpression() ) *
  )
    {}
}


void
parseAssignmentExpression_Subpart ( ) :
{}
{
  (
    parseUnaryExpression()
    parseAssignmentOperator()
    parseAssignmentExpression()
  )
    {}
}

void
parseAssignmentExpression ( ) :
{}
{
	/* ConditionalExpression could be a UnaryExpression... */
  ( LOOKAHEAD ( parseAssignmentExpression_Subpart() )
      parseAssignmentExpression_Subpart()
    | parseConditionalExpression()
  )
    {}
}


void
parseAssignmentOperator ( ) :
{}
{
  (
      <EQUAL>
    | <MULTIPLY_EQUAL>
    | <DIVIDE_EQUAL>
    | <MODULO_EQUAL>
    | <PLUS_EQUAL>
    | <MINUS_EQUAL>
    | <RIGHTSHIFT_EQUAL>
    | <LEFTSHIFT_EQUAL>
    | <AND_EQUAL>
    | <XOR_EQUAL>
    | <OR_EQUAL>
  )
    {}
}


/* AKA:  parseConstantExpression() */
void
parseConditionalExpression ( ) :
{}
{
  (
    parseLogicalOrExpression()
    [ 
      <QUESTION_MARK>
      parseExpression()
      <COLON>

	/* Note:  C++ seems to define what comes after the ':' as a 
	 * ConditionalExpression, however g++ will take an AssignmentExpression
	 */
      /* Was:  parseConditionalExpression() */
      parseAssignmentExpression()
    ]
  )
    {}
}


void
parseLogicalOrExpression ( ) :
{}
{
  (
    parseLogicalAndExpression()
    ( <LOGICAL_OR> parseLogicalAndExpression() ) *
  )
    {}
}


void
parseLogicalAndExpression ( ) :
{}
{
  (
    parseInclusiveOrExpression()
    ( <LOGICAL_AND> parseInclusiveOrExpression() ) *
  )
    {}
}


void
parseInclusiveOrExpression ( ) :
{}
{
  (
    parseExclusiveOrExpression()
    ( <INCLUSIVE_OR> parseExclusiveOrExpression() ) *
  )
    {}
}


void
parseExclusiveOrExpression ( ) :
{}
{
  (
    parseAndExpression()
    ( <EXCLUSIVE_OR> parseAndExpression() ) *
  )
    {}
}


void
parseAndExpression ( ) :
{}
{
  (
    parseEqualityExpression()
    ( <AMPERSAND> parseEqualityExpression() ) *
  )
    {}
}


void
parseEqualityExpression ( ) :
{}
{
  (
    parseRelationalExpression()
    ( (
          <EQUALITY>
        | <INEQUALITY>
      )
      parseRelationalExpression()
    )*
  )
    {}
}


void
parseRelationalExpression ( ) :
{}
{
  (
    parseShiftExpression()
    ( (
          <LESS_THAN>
        | <GREATER_THAN>
        | <LESS_THAN_OR_EQUALS>
        | <GREATER_THAN_OR_EQUALS>
      )
      parseShiftExpression()
    )*
  )
    {}
}


	/* TemplateArg's have a problem with <GREATER_THAN> */
void
parseRelationalExpression_ExcludingGreaterThan ( ) :
{}
{
  (
    parseShiftExpression()
    ( (
          <LESS_THAN>
        | <LESS_THAN_OR_EQUALS>
        | <GREATER_THAN_OR_EQUALS>
      )
      parseShiftExpression()
    )*
  )
    {}
}


void
parseShiftExpression ( ) :
{}
{
  (
    parseAdditiveExpression()
    ( (
          <LEFT_SHIFT>
        | <RIGHT_SHIFT>
      )
      parseAdditiveExpression()
    )*
  )
    {}
}


void
parseAdditiveExpression ( ) :
{}
{
  (
    parseMultiplicativeExpression()
    ( (
          <PLUS>
	| <MINUS>
      )
      parseMultiplicativeExpression()
    )*
  )
    {}
}


void
parseMultiplicativeExpression ( ) :
{}
{
  (
    parsePointerToMemberExpression()
    ( (
          <ASTERISK>
	| <DIVIDE>
	| <MODULO>
      )
      parsePointerToMemberExpression()
    )*
  )
    {}
}


void
parsePointerToMemberExpression ( ) :
{}
{
  (
    parseCastExpression()
    ( (
          <POINTER_TO_MEMBER>
	| <POINTER_TO_MEMBER_DEREFERENCE>
      )
      parseCastExpression()
    )*
  )
    {}
}


void
parseCastExpression_Subpart ( ) :
{}
{
  ( <OPEN_PAREN> parseTypeName() <CLOSE_PAREN> parseCastExpression() )
    {}
}


void
parseCastExpression ( ) :
{}
{
  ( LOOKAHEAD ( parseCastExpression_Subpart() )
      parseCastExpression_Subpart()
    | parseUnaryExpression()
  )
    {}
}


void
parseUnaryExpression ( ) :
{}
{
  (
      ( <INCREMENT> parseUnaryExpression() )
    | ( <DECREMENT> parseUnaryExpression() )
    | ( <SIZEOF> ( LOOKAHEAD ( parseCastExpression_Subpart() )
		     parseCastExpression_Subpart()
		   | parseUnaryExpression()
		 )
      )

	/* sort out common "::" operations */

    | ( LOOKAHEAD ( parseDeallocationExpression() )
	  parseDeallocationExpression()

	| ( LOOKAHEAD ( parseAllocationExpression() )
	      parseAllocationExpression()

		/* Sort out common "~" possibilities.  */
	        /* ARM: pg 279, Section 12.4:
		 *  ~ binds to complement unless "." or "->"  are used.
		 * Ie: new X()->~X()  or  X x; x.~X();
		 * These only occur if parseName() is accessed through
		 * parsePostfixExpression().  If a ~ is seen here,
		 * it's the complement operation. */
	    | ( LOOKAHEAD ( parseUnaryOperator() parseCastExpression() )
	          ( parseUnaryOperator() parseCastExpression() )
	        | parsePostfixExpression()
	      )
	  )
      )
  )
}


void
parseUnaryOperator ( ) :
{}
{
  (
      <ASTERISK>
    | <AMPERSAND>
    | <PLUS>
    | <MINUS>
    | <NOT>
    | <TILDE>
  )
    {}
}


void
parseAllocationExpression ( ) :
{}
{
  (
    [ <SCOPE> ]

    <NEW>

    [ LOOKAHEAD ( parsePlacement() )
      parsePlacement()
    ]
    
    (   parseNewTypeName()
      | ( <OPEN_PAREN> parseTypeName() <CLOSE_PAREN> )
    )

    [ parseNewInitializer() ]
  )
    {}
}


void
parsePlacement ( ) :
{}
{
  (
    <OPEN_PAREN>  parseExpressionList()  <CLOSE_PAREN>
  )
    {}
}


void
parseNewTypeName ( ) :
{}
{
	/* There are two conflicts here.
	 *
	 * (1) NewDeclarator can end with a '*' that should bind to the
	 *     type (ie: in NewDeclarator) and not to a subsequent 
	 *     multiply expression.  (See comment in parseNewDeclarator().)
	 *
	 * (2) TypeSpecifier may BE a CompleteClassName, which can also
	 *     start a NewDeclarator.  (Though, in the NewDeclarator case,
	 *     the CompleteClassName must be followed by a <SCOPE>.)
	 */
  (
	/* (parseTypeSpecifier())+  [ parseNewDeclarator() ] */
    parseTypeSpecifier()

    ( LOOKAHEAD ( parseNewDeclarator() )

        parseNewDeclarator()

      | [ LOOKAHEAD ( parseTypeSpecifier() )

	    parseNewTypeName() /* Recurse, parse TypeSpecifier, and try again*/
	]
    )
  )
    {}
}


void
parseNewDeclarator_Subpart ( ) :
{}
{
  ( [  parseCompleteClassName()  <SCOPE>  ]
    <ASTERISK>  [ parseCvQualifierList() ]
  )
    {}
}

void
parseNewDeclarator ( ) :
{}
{
	/* ARM:  pg 62, End of Section 5.3.3:
	 *  new int * 3  ==>  new (int*) 3  ==>  syntax error.
	 */
  (
      (
         ( LOOKAHEAD ( parseNewDeclarator_Subpart() )
	   parseNewDeclarator_Subpart()
	 )+
	 ( <OPEN_BRACKET> parseExpression() <CLOSE_BRACKET>
	 )*
      )
    | ( /* NO  parseNewDeclarator_Subpart() */
         ( <OPEN_BRACKET> parseExpression() <CLOSE_BRACKET>
	 )+
      )
  )
    {}
}


void
parseNewInitializer ( ) :
{}
{
  (
    <OPEN_PAREN> [ parseInitializerList() ] <CLOSE_PAREN>
  )
    {}
}


void
parseDeallocationExpression ( ) :
{}
{
  (
     [ <SCOPE> ]
     <DELETE>
     [ <OPEN_BRACKET> <CLOSE_BRACKET> ]
     parseCastExpression()
  )
    {}
}


void
parsePostfixExpression_internalSimpleTypeNameBit ( ) :
{}
{
  ( parseSimpleTypeName()
    <OPEN_PAREN>
    [ parseExpressionList() ]
    <CLOSE_PAREN>
  )
    {}
}

void
parsePostfixExpression ( ) :
{}
{
  (
	/* Possible BUG in this lookahead! */
     ( LOOKAHEAD ( parsePostfixExpression_internalSimpleTypeNameBit() )
         parsePostfixExpression_internalSimpleTypeNameBit()
       | parsePrimaryExpression()
     )

     (   ( <OPEN_BRACKET>   parseExpression()       <CLOSE_BRACKET> )
       | ( <OPEN_PAREN>   [ parseExpressionList() ] <CLOSE_PAREN>   )
       | ( <PERIOD>      parseName() )
       | ( <DEREFERENCE> parseName() )
       | ( <INCREMENT>  )
       | ( <DECREMENT>  )
     )*
  )
    {}
}


void
parseExpressionList ( ) :
{}
{
  (
    parseAssignmentExpression()
    ( <COMMA> parseAssignmentExpression() ) *
  )
    {}
}



String
parseTdlRefTaskName ( ) :
{
  Token    token;
  String   taskName;
}
{
  (
    ( <TDL_REF>
        {   /* <TDL_REF> matches regardless of case and underscores. *
	     * We want uppercaes only.                               */
	  getToken ( 0 ) . image = "TDL_REF";
	}

       <OPEN_PAREN>
	    /* Permit "parent )" here as an option to TDL_REF. */ 
       (   (   <PARENT>
	         {
		   System.err.println (
				    TDLParser.getFilenameWithoutPathPlusColon()
				    + ( getToken( 0 ) . beginLine + 1 )
				    + TDLParser.PARENT_WARNING );
		 }
	     | <THIS_CS>
	     | <THIS_CI>
	   )
	     {    /* We want uppercase "THIS" only. */
	       getToken ( 0 ) . image = "THIS";
	       taskName = "THIS";
	     }

	 | token = parseIdToken()
	     {
	       taskName = token.image;
	     }
       )

       <CLOSE_PAREN>
    )
  )
    {
      return taskName;
    }
}


void
parsePrimaryExpression ( ) :
{}
{
  (
	  /* Because we are trying to allow macros and string concatenation
	   * inside Expressions, this is absolutely hideous!
	   *  <ID> <SCOPE>            is a parseName().
	   *  <ID> <STRING_CONSTANT>  is a parseLiteral().
	   */
      ( LOOKAHEAD ( parseIdToken() (parseIdToken() | <STRING_CONSTANT>) )
	   ( parseLiteral() )
	 | ( LOOKAHEAD ( parseName() )
	        ( parseName()    )
	      | ( parseLiteral() )
	   )
      )

//    | ( <THIS_CS> )  /* No TDL inside classes */
    | ( <SCOPE>
        (   parseOperatorFunctionName()
	  | ( LOOKAHEAD ( parseQualifiedName() )
	        parseQualifiedName()
	      | parseIdToken()
	    )
	)
      )
    | ( <OPEN_PAREN> parseExpression() <CLOSE_PAREN> )


	/*************************************************************
	 * Deal with TDL-specific <ID>'s for inside expresions here. *
	 *************************************************************/
    | (   (
	    <TRIGGER>
	      {	   /* Trigger can only be used inside Monitors! */
		if ( getIsParsingMonitorBody() != true )
		{
		  throw generateParseException ( getToken ( 0 ),
		        "Encountered TRIGGER in a non-Monitor Task." );
		}
		   /* <TRIGGER> matches regardless of case. *
		    *  We want uppercase only.              */
		getToken ( 0 ) . image = "TRIGGER";
	      }
	    <OPEN_PAREN>
	    <CLOSE_PAREN>
	  )
        | 
	  parseTdlRefTaskName() 
	|
	  ( 
	    (   <GET_NUMBER_OF_TRIGGERS>
	      | <GET_NUMBER_OF_ACTIVATES>
	    )
	      {	   /* These can only be used inside Monitors! */
		if ( getIsParsingMonitorBody() != true )
		{
		  throw generateParseException ( getToken ( 0 ),
			      "Encountered " + getToken ( 0 ) . image 
			    + "() in a non-Monitor Task." );
		}
		   /* These match regardless of case.      *
		    * We want these specific strings only. */
		if      ( getToken ( 0 ) . kind == GET_NUMBER_OF_TRIGGERS  )
		  getToken ( 0 ) . image = "getNumberOfTriggers";
		else if ( getToken ( 0 ) . kind == GET_NUMBER_OF_ACTIVATES )
		  getToken ( 0 ) . image = "getNumberOfActivates";
	      }
	    <OPEN_PAREN>
	    <CLOSE_PAREN>
	  )
      )
  )
    {}
}


/*
 * Used as a hack to avoid declaring Operator() and Conversion functions
 * inside classes inside TDL code.
 */
void
parseName_WithoutOperatorOrConversionFunctionNames ( ) :
{}
{
  (
	/* Both Start with "<ID>" */
      ( LOOKAHEAD ( parseQualifiedName() )
          parseQualifiedName()
        | parseIdToken()
      )

    | ( <TILDE> parseClassName() )
  )
    {}
}


void
parseName ( ) :
{}
{
  (
      parseName_WithoutOperatorOrConversionFunctionNames()

	/* Both Start with "operator" */
    | ( LOOKAHEAD ( parseOperatorFunctionName() )
	  parseOperatorFunctionName()
	| parseConversionFunctionName()
      )
  )
    {}
}


void
parseQualifiedName ( ) :
{}
{
  (
	/* Bug work around.  We are hitting a bug with JavaCC 0.7pre5 that
	 * prevents lookahead from working right in certain nested situations.
	 * Specifically, parseQualifiedClassName() seems to break.
	 *
	 * However, since parseName() includes parseQualifiedName(),
	 * the recursion can occur here...  (Ie:  These are equivalent:)
	 */
//    parseQualifiedClassName_LeaveTrailingScope() <SCOPE> parseName()
   parseClassName() <SCOPE> parseName()
  )
    {}
}


void
parseLiteral ( ) :
{}
{
  (
      <INTEGER_CONSTANT>
    | <FLOAT_CONSTANT_BASIC>
    | <FLOATING_CONSTANT>
    | <CHARACTER_CONSTANT>
    | parseStringConstantAndIdsAssumingTheyAreMacros()
  )
    {}
}


/*******************************/
/***  Declaration parsing..  ***/
/*******************************/

void
parseDeclaration_Subpart ( ) :
{}
{
  /* [ parseDeclSpecifiers() ]  [ parseDeclaratorList() ]  <SEMICOLON>
   * -- However, parseDeclSpecifiers and parseDeclaratorList
   *    can BOTH start with complete-class-name, leading to difficulties...
   */
  ( LOOKAHEAD ( parseDeclaratorList() <SEMICOLON> )
      ( parseDeclaratorList() <SEMICOLON> )
    | (   <SEMICOLON>
        | ( parseDeclSpecifier() parseDeclaration_Subpart() )
      )
  )
    {}
}

void
parseDeclaration ( ) :
{}
{
  (
      ( LOOKAHEAD ( parseLinkageSpecification() )
	  parseLinkageSpecification()
	| parseDeclaration_Subpart()
      )
    | parseAsmDeclaration()
//    | parseFunctionDefinition()  /* No Functions inside TDL code */
//    | parseTemplateDeclaration() /* No Template Decls inside TDL code */
				   /* (Templates must be declared globally) */
  )
    {}
}


void
parseDeclSpecifier ( ) :
{}
{
  (
      parseStorageClassSpecifier()
    | parseTypeSpecifier()
    | parseFctSpecifier() //?
    | <FRIEND> //?
    | <TYPEDEF>
  )
    {}
}


void
parseDeclSpecifiers ( ) :
{}
{
  (
    ( parseDeclSpecifier() ) +
  )
    {}
}


void
parseStorageClassSpecifier ( ) :
{}
{
  (
      <AUTO>
    | <REGISTER>
    | <STATIC_CS>
    | <EXTERN_CS>
  )
    {}
}


void
parseFctSpecifier ( ) :
{}
{
  (
      <INLINE>
    | <VIRTUAL_CS>
  )
    {}
}


void
parseTypeSpecifier ( ) :
{}
{
  (
      parseSimpleTypeName()

      /* ElaboratedTypeSpecifier begins the same way as Enum/Class Specifiers*/
    | ( LOOKAHEAD ( parseEnumSpecifier() )

          parseEnumSpecifier()

	| ( LOOKAHEAD ( parseClassSpecifier() )

	      parseClassSpecifier()

	    | parseElaboratedTypeSpecifier()
	  )
      )
    | <CONST>
    | <VOLATILE>
  )
    {}
}


void
parseSimpleTypeName ( ) :
{}
{
  (
      ( LOOKAHEAD ( parseCompleteClassName() )
          parseCompleteClassName()
	| parseQualifiedTypeName()
      )
    | <CHAR>
    | <SHORT>
    | <INT>
    | <LONG>
    | <SIGNED>
    | <UNSIGNED>
    | <FLOAT>
    | <DOUBLE>
    | <VOID>
  )
    {}
}


void
parseElaboratedTypeSpecifier ( ) :
{}
{
  (
      ( parseClassKey()
	parseClassName() // | parseIdToken()
      )
    | ( <ENUM> parseEnumName() )
  )
    {}
}


void
parseClassKey ( ) :
{}
{
  (
      <CLASS>
    | <STRUCT>
    | <UNION>
  )
    {}
}


void
parseQualifiedTypeName_Subpart ( ) :
{}
{
  (
    parseClassName()
    <SCOPE>
  )
    {}
}


void
parseQualifiedTypeName ( ) :
{}
{
  (
    ( LOOKAHEAD ( parseQualifiedTypeName_Subpart() )
      parseQualifiedTypeName_Subpart()
    )*
    parseTypedefName()
  )
    {}
}


void
parseCompleteClassName ( ) :
{}
{
  (
    [ <SCOPE> ]  parseQualifiedClassName()
  )
    {}
}


void
parseQualifiedClassName_LeaveTrailingScope ( ) :
{}
{
  (
    parseClassName()
    ( LOOKAHEAD ( <SCOPE> parseClassName() <SCOPE> )
      ( <SCOPE> parseClassName() )
    )*
  )
    {}
}


void
parseQualifiedClassName ( ) :
{}
{
  (
    parseClassName()
    ( LOOKAHEAD ( <SCOPE> parseClassName() )
      ( <SCOPE> parseClassName() )
    )*
  )
    {}
}


void
parseEnumSpecifier ( ) :
{}
{
  (
     <ENUM> [ parseIdToken() ] <OPEN_BRACE>  [ parseEnumList() ]  <CLOSE_BRACE>
  )
    {}
}


void
parseEnumList ( ) :
{}
{
  (
    parseEnumerator() ( <COMMA> parseEnumerator() )*
  )
    {}
}


void
parseEnumerator ( ) :
{}
{
  (
    parseIdToken() [ <EQUAL> parseConstantExpression() ]
  )
    {}
}


void
parseConstantExpression ( ) :
{}
{
  parseConditionalExpression()
}


void
parseLinkageSpecification ( ) :
{}
{
  (
    <EXTERN_CS> <STRING_CONSTANT>
    (
        ( <OPEN_BRACE>  [ parseDeclarationList() ]  <CLOSE_BRACE> )
      | parseDeclaration()
    )
  )
    {}
}


void
parseDeclarationList ( ) :
{}
{
  (
    ( parseDeclaration() ) +
  )
    {}
}


void
parseAsmDeclaration ( ) :
{}
{
  (
    <ASM> <OPEN_PAREN>
    parseStringConstantAndIdsAssumingTheyAreMacros()
    <CLOSE_PAREN> <SEMICOLON>
  )
    {}
}


/*******************************/
/***  Declarators parsing..  ***/
/*******************************/

void
parseDeclaratorList ( ) :
{}
{
  (
    parseInitDeclarator() ( <COMMA> parseInitDeclarator() ) *
  )
    {}
}


void
parseInitDeclarator ( ) :
{}
{
  (
    parseDeclarator()  [ parseInitializer() ]
  )
    {}
}


void
parseDeclarator_Subpart ( ) :
{}
{
  (   ( parseArgumentDeclarationList()   [ parseCvQualifierList() ] )
    | ( <OPEN_BRACKET>  [ parseConstantExpression() ]  <CLOSE_BRACKET> )
  )
    {}
}


/*
 * Used as a hack to avoid declaring methods inside classes inside TDL code.
 */
void
parseDeclarator_WithoutFunctions ( ) :
{}
{
  (
    ( LOOKAHEAD ( parsePtrOperator() )
      parsePtrOperator()
    )*

    (   parseDname_WithoutOperatorOrConversionFunctionNames()
      | ( <OPEN_PAREN> parseDeclarator() <CLOSE_PAREN> )
    )

    ( <OPEN_BRACKET>  [ parseConstantExpression() ]  <CLOSE_BRACKET>
    )*
  )
    {}
}


void
parseDeclarator ( ) :
{}
{
  (
    ( LOOKAHEAD ( parsePtrOperator() )
      parsePtrOperator()
    )*

    (   parseDname()
      | ( <OPEN_PAREN> parseDeclarator() <CLOSE_PAREN> )
    )

    ( LOOKAHEAD ( parseDeclarator_Subpart() )
      parseDeclarator_Subpart()
    )*
  )
    {}
}


void
parsePtrOperator ( ) :
{}
{
  (
    (
        <ASTERISK>
      | <AMPERSAND>
      | ( parseCompleteClassName() <SCOPE> <ASTERISK> )
    )
    [ parseCvQualifierList() ]
  )
    {}
}


void
parseCvQualifierList ( ) :
{}
{
  (
    ( parseCvQualifer() ) +
  )
    {}
}


void
parseCvQualifer ( ) :
{}
{
  (
      <CONST>
    | <VOLATILE>
  )
    {}
}


/*
 * Used as a hack to avoid declaring Operator() and Conversion functions
 * inside classes inside TDL code.
 */
void
parseDname_WithoutOperatorOrConversionFunctionNames ( ) :
{}
{
  (
    ( LOOKAHEAD ( parseQualifiedTypeName() )

        parseQualifiedTypeName()

      | ( LOOKAHEAD ( parseClassName() )

	    parseClassName()
	  | parseName_WithoutOperatorOrConversionFunctionNames()
	)
    )
/*
 *  | parseTypedefName()            -- included in all three.
 *  | ( <TILDE> parseClassName() )  -- included in parseName()
 */
  )
    {}
}


void
parseDname ( ) :
{}
{
  (
    ( LOOKAHEAD ( parseQualifiedTypeName() )

        parseQualifiedTypeName()

      | ( LOOKAHEAD ( parseClassName() )

	    parseClassName()
	  | parseName()
	)
    )
/*
 *  | parseTypedefName()            -- included in all three.
 *  | ( <TILDE> parseClassName() )  -- included in parseName()
 */
  )
    {}
}


void
parseTypeName ( ) :
{}
{
	/* Conflict:  Both TypeSpecifier and AbstractDeclarator
	 * can begin with a CompleteClassName.
	 */
  (
    /* (parseTypeSpecifier())+  [ parseAbstractDeclarator() ] */
    parseTypeSpecifier()

    ( LOOKAHEAD ( parseAbstractDeclarator() )

        parseAbstractDeclarator()

      | [ LOOKAHEAD ( parseTypeSpecifier() )

	    parseTypeName() /* Recurse, parse TypeSpecifier, and try again*/
	]
    )
  )
    {}
}


void
parseTypeSpecifierList ( ) :
{}
{
  (
    ( parseTypeSpecifier() ) +
  )
    {}
}


void
parseAbstractDeclarator ( ) :
{}
{
  (
      (
        ( parsePtrOperator()
	)+

	[ LOOKAHEAD ( <OPEN_PAREN>  parseAbstractDeclarator()  <CLOSE_PAREN> )
	            ( <OPEN_PAREN>  parseAbstractDeclarator()  <CLOSE_PAREN> )
	]

	(
	    ( parseArgumentDeclarationList()   [ parseCvQualifierList() ] )
	  |
	    ( <OPEN_BRACKET>  [ parseConstantExpression() ]  <CLOSE_BRACKET> )
	)*
      )

    | ( LOOKAHEAD ( <OPEN_PAREN>  parseAbstractDeclarator()  <CLOSE_PAREN> )
	  (
	    /* There can't be a parsePtrOperator() if we get here... */
	    /* ( parsePtrOperator() ) *   */

	    ( <OPEN_PAREN>  parseAbstractDeclarator()  <CLOSE_PAREN> )

	    (
	        ( parseArgumentDeclarationList()   [ parseCvQualifierList() ] )
	      |
	        ( <OPEN_BRACKET> [ parseConstantExpression() ] <CLOSE_BRACKET>)
	    )*
          )
	|
          (
	    /* There can't be a parsePtrOperator() if we get here... */
	    /* ( parsePtrOperator() ) *   */

	    /*There can't be a "( parseAbstractDeclarator() )" if we get here*/
	    /*[LOOKAHEAD( <OPEN_PAREN> parseAbstractDeclarator() <CLOSE_PAREN>)
	     *          ( <OPEN_PAREN> parseAbstractDeclarator() <CLOSE_PAREN>)
	     *]
	     */

	    (
	       ( parseArgumentDeclarationList()   [ parseCvQualifierList() ] )
	     |
	       ( <OPEN_BRACKET> [ parseConstantExpression() ] <CLOSE_BRACKET> )
	    )+
	  )
      )
  )
    {}
}


void
parseArgumentDeclarationList_Subpart ( ) :
{}
{
	/* Note:  This can expand to a no-op, with zero elements.
	 * Therefore, all invocations of parseArgumentDeclarationList_Subpart()
	 * *MUST* be in []'s, making them optional!
	 */
  (
	/* This is where we would normally handle the ellipsis cases...
	 *    [ArgDeclartionList] [...]
	 *     ArgDeclartionList , ...
	 *
	 *But, for simplicity, we are not currently supporting ellipsis in TDL.
	 */
    ( parseArgDeclarationList_AndTrailingToken() )
  )
    {}
}


void
parseArgumentDeclarationList ( ) :
{}
{
	/* Note:  parseArgumentDeclarationList() now includes parsing the
	 * beginning open-paren and final close-paren...
	 */
  (
    <OPEN_PAREN>
    (   parseArgumentDeclarationList_Subpart()
      | <CLOSE_PAREN>
    )
  )
    {}
}


void
parseArgDeclarationList_AndTrailingToken ( ) :
{}
{
  (
    ( LOOKAHEAD ( parseArgumentDeclaration_AndTrailing_Comma() )
      parseArgumentDeclaration_AndTrailing_Comma()
    )*
    parseArgumentDeclaration_AndTrailing_CloseParen()
  )
    {}
}



void
parseArgumentDeclaration_Subpart ( ) :
{}
{
	/* Note: Comma's deliminate arguments, so "= parseExpression()"
	 * has been changed to "= parseAssignmentExpression()"
	 */
  (
    ( LOOKAHEAD ( parseDeclarator() )
        parseDeclarator()
      | [ parseAbstractDeclarator() ]
    )

    [ <EQUAL> parseAssignmentExpression() ]
  )
    {}
}

void
parseArgumentDeclaration_AndTrailing_Comma ( ) :
{}
{
	/* Unfortunately, DeclSpecifier can be a CompleteClassName,
	 * which can be identical to the Dname or PtrOperator in Declarator's.
	 */
  (
    parseDeclSpecifier()

    ( LOOKAHEAD ( parseArgumentDeclaration_Subpart() <COMMA> )
        ( parseArgumentDeclaration_Subpart() <COMMA> )
      | parseArgumentDeclaration_AndTrailing_Comma()
    )
  )
    {}
}

void
parseArgumentDeclaration_AndTrailing_CloseParen ( ) :
{}
{
	/* Unfortunately, DeclSpecifier can be a CompleteClassName,
	 * which can be identical to the Dname or PtrOperator in Declarator's.
	 */
  (
    parseDeclSpecifier()

    ( LOOKAHEAD ( parseArgumentDeclaration_Subpart() <CLOSE_PAREN> )

        ( parseArgumentDeclaration_Subpart() <CLOSE_PAREN> )

      | parseArgumentDeclaration_AndTrailing_CloseParen()
    )
  )
    {}
}



	/* No Functions inside TDL code... */
// void
// parseFunctionDefinition ( ) :
// {}
// {
//   (
//     [ parseDeclSpecifiers() ]
//     parseDeclarator()
//     [ parseCtorInitializer() ]
//     parseFctBody()
//   )
//     {}
// }

	/* No Functions inside TDL code... */
// void
// parseFctBody ( ) :
// {}
// {
//   (
//     parseCompoundStatement()
//   )
//     {}
// }


void
parseInitializer ( ) :
{}
{
  (
      ( <EQUAL>
        (
	    parseAssignmentExpression()
	  | ( <OPEN_BRACE> parseInitializerList()  [ <COMMA> ]  <CLOSE_BRACE> )
	)
      )
    | ( <OPEN_PAREN> parseExpressionList() <CLOSE_PAREN> )
  )
    {}
}


void
parseInitializerList_Subpart ( ) :
{}
{
  (
      ( parseAssignmentExpression() )
    | ( <OPEN_BRACE>  parseInitializerList()  [ <COMMA> ]  <CLOSE_BRACE> )
  )
    {}
}


void
parseInitializerList ( ) :
{}
{
  (
    parseInitializerList_Subpart()

    ( LOOKAHEAD ( <COMMA> parseInitializerList_Subpart() )
      ( <COMMA> parseInitializerList_Subpart() )
    )*
  )
    {}
}


/**************************************/
/***  Class Declarations Parsing..  ***/
/**************************************/


void
parseClassSpecifier ( ) :
{}
{
  (
    parseClassHead()  <OPEN_BRACE>  [ parseMembersList() ]  <CLOSE_BRACE>
  )
    {}
}


void
parseClassHead ( ) :
{}
{
  (
    parseClassKey()
    [ parseClassName() ]  /* ClassName may be an ID, ID is optional */
    [ parseBaseSpec() ]
  )
    {}
}


void
parseMembersList ( ) :
{}
{
  (
    (
        parseMemeberDeclaration()
      | ( parseAccessSpecifier() <COLON> )
    )+
  )
    {}
}


void
parseMemeberDeclaration_Subpart ( ) :
{}
{
  (
	/* Both DeclSpecifiers and MemberDeclaratorList can start with
	 * a CompleteClassName...
	 */
// ( [ parseDeclSpecifiers() ]  [ parseMemberDeclaratorList() ]  <SEMICOLON> )

      <SEMICOLON>

    | ( LOOKAHEAD ( parseMemberDeclaratorList() <SEMICOLON> )

	  ( parseMemberDeclaratorList() <SEMICOLON> )

	| ( parseDeclSpecifier() parseMemeberDeclaration_Subpart() )
      )
  )
    {}
}
 
 
void
parseMemeberDeclaration ( ) :
{}
{
  ( LOOKAHEAD ( parseQualifiedName() <SEMICOLON> )
      ( parseQualifiedName() <SEMICOLON> )
    | parseMemeberDeclaration_Subpart()

	/* No Functions inside TDL code... */
//    | ( parseFunctionDefinition() [ <SEMICOLON> ] )
  )
    {}
}


void
parseMemberDeclaratorList ( ) :
{}
{
  (
    parseMemberDeclarator() ( <COMMA> parseMemberDeclarator() )*
  )
    {}
}


void
parseMemberDeclarator_Subpart ( ) :
{}
{
  (
   ( [ parseIdToken() ] <COLON> parseConstantExpression() )
  )
    {}
}


void
parseMemberDeclarator ( ) :
{}
{
  ( LOOKAHEAD ( parseMemberDeclarator_Subpart() )

      parseMemberDeclarator_Subpart()

    | ( parseDeclarator_WithoutFunctions()

	/* I'll disallow this since it could only be used for a pure-virtual
	 * FUNCTION (method), which are disallowed in TDL
	 */
//	[ parsePureSpecifier() ]
      )
  )
    {}
}


	/* I'll disallow this since it could only be used for a pure-virtual
	 * FUNCTION (method), which are disallowed in TDL
	 */
// void
// parsePureSpecifier ( ) :
// {}
// {
//   (
// 	/* Zero is an INTEGER_CONSTANT, so this may bomb.
// 	 * But then again, we should never have pure virtual methods
// 	 * inside TDL code to begin with...
// 	 *
// 	 * (But it's too much trouble to dike them out...)
// 	 */
//     <EQUAL>  "0" //<ZERO>
//   )
//     {}
// }


void
parseBaseSpec ( ) :
{}
{
  (
    <COLON> parseBaseList()
  )
    {}
}


void
parseBaseList ( ) :
{}
{
  (
    parseBaseSpecifier() ( <COMMA> parseBaseSpecifier() ) *
  )
    {}
}


void
parseBaseSpecifier ( ) :
{}
{
  (
    [
        (  <VIRTUAL_CS>           [ parseAccessSpecifier() ] )
      | (  parseAccessSpecifier() [ <VIRTUAL_CS>           ] )
    ]

    parseCompleteClassName()
  )
    {}
}


void
parseAccessSpecifier ( ) :
{}
{
  (
      <PRIVATE>
    | <PROTECTED>
    | <PUBLIC>
  )
    {}
}


void
parseConversionFunctionName ( ) :
{}
{
  (
    <OPERATOR> parseConversionTypeName()
  )
    {}
}


void
parseConversionTypeName ( ) :
{}
{
  (
	/* Both TypeSpecifier and PtrOperator can begin the same way */
    // parseTypeSpecifierList()  [ parsePtrOperator() ]

    parseTypeSpecifier()

    ( LOOKAHEAD ( parsePtrOperator() )

        parsePtrOperator()  /* And we are done... */

      | [ LOOKAHEAD ( parseTypeSpecifier() )

	  parseConversionTypeName() /* Recurse and try again. */

        ]
    )
  )
    {}
}


void
parseCtorInitializer ( ) :
{}
{
  (
    <COLON> parseMemInitializerList()
  )
    {}
}


void
parseMemInitializerList ( ) :
{}
{
  (
    parseMemInitializer() ( <COMMA> parseMemInitializer() ) *
  )
    {}
}


void
parseMemInitializer ( ) :
{}
{
  (
    (   parseCompleteClassName()
      /* | parseIdToken() -- Subset of parseCompleteClassName() */
    )
    <OPEN_PAREN>  [ parseExpressionList() ]  <CLOSE_PAREN>
  )
    {}
}


void
parseOperatorFunctionName ( ) :
{}
{
  (
    <OPERATOR>  parseOperator()
  )
    {}
}


void
parseOperator ( ) :
{}
{
  (
      <NEW>
    | <DELETE>
    | <PLUS>
    | <MINUS>
    | <ASTERISK>
    | <DIVIDE>
    | <MODULO>
    | <EXCLUSIVE_OR>
    | <AMPERSAND>
    | <INCLUSIVE_OR>
    | <TILDE>
    | <NOT>
    | <EQUAL>
    | <LESS_THAN>
    | <GREATER_THAN>
    | <PLUS_EQUAL>
    | <MINUS_EQUAL>
    | <MULTIPLY_EQUAL>
    | <DIVIDE_EQUAL>
    | <MODULO_EQUAL>
    | <XOR_EQUAL>
    | <AND_EQUAL>
    | <OR_EQUAL>
    | <LEFT_SHIFT>
    | <RIGHT_SHIFT>
    | <LEFTSHIFT_EQUAL>
    | <RIGHTSHIFT_EQUAL>
    | <EQUALITY>
    | <INEQUALITY>
    | <LESS_THAN_OR_EQUALS>
    | <GREATER_THAN_OR_EQUALS>
    | <LOGICAL_AND>
    | <LOGICAL_OR>
    | <INCREMENT>
    | <DECREMENT>
    | <COMMA>
    | <POINTER_TO_MEMBER_DEREFERENCE>
    | <DEREFERENCE>
    | ( <OPEN_PAREN>   <CLOSE_PAREN>   )
    | ( <OPEN_BRACKET> <CLOSE_BRACKET> )
  )
    {}
}



/*************************/
/***  Template parsing ***/
/*************************/


	/* Templates must be declared GLOBAL, and are therefore **NOT**
	 * part of the TDL syntax.
	 */

// void
// parseTemplateDeclaration ( ) :
// {}
// {
//   (
//     <TEMPLATE>  <LESS_THAN>  parseTemplateArgumentList()  <GREATER_THAN>
//     parseDeclaration()
//   )
//     {}
// }


// void
// parseTemplateArgumentList ( ) :
// {}
// {
//   (
//     parseTemplateArgument() ( <COMMA> parseTemplateArgument() ) *
//   )
//     {}
// }


// void
// parseTemplateArgument ( ) :
// {}
// {
//   (
//       parseTypeArgument()
//     | parseArgumentDeclaration()
//   )
//     {}
// }


// void
// parseTypeArgument ( ) :
// {}
// {
//   (
//     <CLASS> parseIdToken()
//   )
//     {}
// }


	/* Of course, TDL code can USE PRE-EXISTING GLOBAL Templated classes */
void
parseTemplateClassName ( ) :
{}
{
  (
    // parseTemplateName() <LESS_THAN> parseTemplateArgList() <GREATER_THAN>

	/* Notes:  Commas separate template class arguments, so we can NOT
	 * use parseExpression().
	 *
	 * <GREATER_THAN> terminates the template, so an expression that
	 * contains a <GREATER_THAN> outside of parenthesis terminates
	 * the TemplateArg.
	 *
	 * g++ version 2.7.2.1 does NOT support '?:','||','&&','|','^','&',
	 * '==', or '!=' for template args.  Therefore, since this parser
	 * is being designed to be integrated with g++, and since one can
	 * override these limitations by surrounding the expression with ()'s,
	 * and since it greatly simplifies a particularly nasty parsing
	 * problem, we won't support these operations either...
	 *
	 * Both Expressions and TypeNames can begin the same way.
	 *
	 *
	 * Addendum: One can not definitively distinguish between template
	 * declarations and expressions based on tokens.  It's a semantic
	 * distinction, not a syntactical distinction, whether:
	 *   "ID<2<=3> ID;"
	 * Is a template, or the expression: "( ( ( ID < 2 ) <= 3 ) > ID ) ;"
	 *   [With ()s added for clarity.]
	 * Thus, there is nothing that can be done about this bug...
	 * (Though "templateClass<int*,2<=3> templateInstance" will always
	 *  parse correctly...)
	 */

    parseTemplateName()
    <LESS_THAN>
   
    ( LOOKAHEAD ( parseTypeName() ( <GREATER_THAN> | <COMMA> ) )
        parseTypeName()
      | parseRelationalExpression_ExcludingGreaterThan()
    )

    ( <COMMA>
      ( LOOKAHEAD ( parseTypeName() ( <GREATER_THAN> | <COMMA> ) )
          parseTypeName()
	| parseRelationalExpression_ExcludingGreaterThan()
      )
    )*

   <GREATER_THAN>

  )
    {}
}

	/* Note:  Template Args are dealt with directly up above... */
// void
// parseTemplateArgList ( ) :
// {}
// {
//   (
//     parseTemplateArg()  ( <COMMA> parseTemplateArg() ) *
//   )
//     {}
// }

// void
// parseTemplateArg ( ) :
// {}
// {
//   (
//       parseExpression
//     | parseTypeName()
//   )
//     {}
// }



/**************************/
/*** Note:
 ***       Neither Exception Handling nor preprocessing is included here.
 ***/
/**************************/



/********************************************************************
 ***  For Tasks inside classes, we need a specialized version of  ***
 ***  Expression Parsing that does not include "." or "->".       ***
 ***  Due to JavaCC limitations, we are re-implementing           ***
 ***  Expression Parsing here...                                  ***
 ********************************************************************/

void
parseExpression_NoDereference ( ) :
{}
{
  (
    parseAssignmentExpression_NoDereference()
    ( <COMMA> parseAssignmentExpression_NoDereference() ) *
  )
    {}
}


void
parseAssignmentExpression_Subpart_NoDereference ( ) :
{}
{
  (
    parseUnaryExpression_NoDereference()
    parseAssignmentOperator()
    parseAssignmentExpression_NoDereference()
  )
    {}
}

void
parseAssignmentExpression_NoDereference ( ) :
{}
{
	/* ConditionalExpression could be a UnaryExpression... */
  ( LOOKAHEAD ( parseAssignmentExpression_Subpart_NoDereference() )
      parseAssignmentExpression_Subpart_NoDereference()
    | parseConditionalExpression_NoDereference()
  )
    {}
}

/* AKA:  parseConstantExpression_NoDereference() */
void
parseConditionalExpression_NoDereference ( ) :
{}
{
  (
    parseLogicalOrExpression_NoDereference()
    [ 
      <QUESTION_MARK>
      parseExpression_NoDereference()
      <COLON>

	/* Note:  C++ seems to define what comes after the ':' as a 
	 * ConditionalExpression, however g++ will take an AssignmentExpression
	 */
      /* Was:  parseConditionalExpression_NoDereference() */
      parseAssignmentExpression_NoDereference()
    ]
  )
    {}
}


void
parseLogicalOrExpression_NoDereference ( ) :
{}
{
  (
    parseLogicalAndExpression_NoDereference()
    ( <LOGICAL_OR> parseLogicalAndExpression_NoDereference() ) *
  )
    {}
}


void
parseLogicalAndExpression_NoDereference ( ) :
{}
{
  (
    parseInclusiveOrExpression_NoDereference()
    ( <LOGICAL_AND> parseInclusiveOrExpression_NoDereference() ) *
  )
    {}
}


void
parseInclusiveOrExpression_NoDereference ( ) :
{}
{
  (
    parseExclusiveOrExpression_NoDereference()
    ( <INCLUSIVE_OR> parseExclusiveOrExpression_NoDereference() ) *
  )
    {}
}


void
parseExclusiveOrExpression_NoDereference ( ) :
{}
{
  (
    parseAndExpression_NoDereference()
    ( <EXCLUSIVE_OR> parseAndExpression_NoDereference() ) *
  )
    {}
}


void
parseAndExpression_NoDereference ( ) :
{}
{
  (
    parseEqualityExpression_NoDereference()
    ( <AMPERSAND> parseEqualityExpression_NoDereference() ) *
  )
    {}
}


void
parseEqualityExpression_NoDereference ( ) :
{}
{
  (
    parseRelationalExpression_NoDereference()
    ( (
          <EQUALITY>
        | <INEQUALITY>
      )
      parseRelationalExpression_NoDereference()
    )*
  )
    {}
}


void
parseRelationalExpression_NoDereference ( ) :
{}
{
  (
    parseShiftExpression_NoDereference()
    ( (
          <LESS_THAN>
        | <GREATER_THAN>
        | <LESS_THAN_OR_EQUALS>
        | <GREATER_THAN_OR_EQUALS>
      )
      parseShiftExpression_NoDereference()
    )*
  )
    {}
}


void
parseShiftExpression_NoDereference ( ) :
{}
{
  (
    parseAdditiveExpression_NoDereference()
    ( (
          <LEFT_SHIFT>
        | <RIGHT_SHIFT>
      )
      parseAdditiveExpression_NoDereference()
    )*
  )
    {}
}


void
parseAdditiveExpression_NoDereference ( ) :
{}
{
  (
    parseMultiplicativeExpression_NoDereference()
    ( (
          <PLUS>
	| <MINUS>
      )
      parseMultiplicativeExpression_NoDereference()
    )*
  )
    {}
}


void
parseMultiplicativeExpression_NoDereference ( ) :
{}
{
  (
    parsePointerToMemberExpression_NoDereference()
    ( (
          <ASTERISK>
	| <DIVIDE>
	| <MODULO>
      )
      parsePointerToMemberExpression_NoDereference()
    )*
  )
    {}
}


void
parsePointerToMemberExpression_NoDereference ( ) :
{}
{
  (
    parseCastExpression_NoDereference()
    ( (
          <POINTER_TO_MEMBER>
	| <POINTER_TO_MEMBER_DEREFERENCE>
      )
      parseCastExpression_NoDereference()
    )*
  )
    {}
}


void
parseCastExpression_Subpart_NoDereference ( ) :
{}
{
  ( <OPEN_PAREN> parseTypeName() <CLOSE_PAREN>
    parseCastExpression_NoDereference()
  )
    {}
}


void
parseCastExpression_NoDereference ( ) :
{}
{
  ( LOOKAHEAD ( parseCastExpression_Subpart_NoDereference() )
      parseCastExpression_Subpart_NoDereference()
    | parseUnaryExpression_NoDereference()
  )
    {}
}


void
parseUnaryExpression_NoDereference ( ) :
{}
{
  (
      ( <INCREMENT> parseUnaryExpression_NoDereference() )
    | ( <DECREMENT> parseUnaryExpression_NoDereference() )
    | ( <SIZEOF> ( LOOKAHEAD ( parseCastExpression_Subpart_NoDereference() )
		     parseCastExpression_Subpart_NoDereference()
		   | parseUnaryExpression_NoDereference()
		 )
      )

	/* sort out common "::" operations */

    | ( LOOKAHEAD ( parseDeallocationExpression_NoDereference() )
	  parseDeallocationExpression_NoDereference()

	| ( LOOKAHEAD ( parseAllocationExpression() )
	      parseAllocationExpression()

		/* Sort out common "~" possibilities.  */
	        /* ARM: pg 279, Section 12.4:
		 *  ~ binds to complement unless "." or "->"  are used.
		 * Ie: new X()->~X()  or  X x; x.~X();
		 * These only occur if parseName() is accessed through
		 * parsePostfixExpression().  If a ~ is seen here,
		 * it's the complement operation. */
	    | ( LOOKAHEAD ( parseUnaryOperator()
			    parseCastExpression_NoDereference() )
	          ( parseUnaryOperator() parseCastExpression_NoDereference() )
	        | parsePostfixExpression_NoDereference()
	      )
	  )
      )
  )
}


void
parseDeallocationExpression_NoDereference ( ) :
{}
{
  (
     [ <SCOPE> ]
     <DELETE>
     [ <OPEN_BRACKET> <CLOSE_BRACKET> ]
     parseCastExpression_NoDereference()
  )
    {}
}



void
parsePostfixExpression_NoDereference ( ) :
{}
{
  (
	/* Possible BUG in this lookahead! */
     ( LOOKAHEAD ( parsePostfixExpression_internalSimpleTypeNameBit() )
         parsePostfixExpression_internalSimpleTypeNameBit()
       | parsePrimaryExpression()
     )

     (   ( <OPEN_BRACKET>   parseExpression()       <CLOSE_BRACKET> )
       | ( <OPEN_PAREN>   [ parseExpressionList() ] <CLOSE_PAREN>   )
/************************************************************************
 ***************  Removed to avoid Dereferencing classes  ***************
 ************************************************************************
 **    | ( <PERIOD>      parseName() )
 **    | ( <DEREFERENCE> parseName() )
 ************************************************************************/
       | ( <INCREMENT>  )
       | ( <DECREMENT>  )
     )*
  )
    {}
}

