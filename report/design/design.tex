En esta seccion se describe el diseño del lenguaje, su semántica,
así como el diseño del lenguaje de bajo nivel, y cómo es interpretado.

\section{Lenguaje de alto nivel}

\subsection{Sintaxis}

\begin{verbatim}
bool := "True" | "False"
float := [-+]?[0-9]*\.?[0-9]+
int := [-+]?[0-9]*\.?[0-9]+

value := float | int | bool

binop := '+' | '-' | '/' | '*' | '||' | '&&'

expr := expr expr 
      | value
      | expr binop expr
      | "if" expr "then" expr "else" expr
      | "let" name "=" expr "in" expr
      | "\\"

Definición de funciones:
func := name [arglist] = expr

Let:

"let" name = expr1 in expr2

\end{verbatim}


\subsection{Combinadores de FRP}

La función \texttt{lift} combina una función y un valor
dependiente del tiempo, y crea un nuevo valor dependiente
del tiempo, es decir, aplica una función que transforma
una señal en otra:\\


$lift :: (a \rightarrow b) \rightarrow Signal\ a \rightarrow Signal\ b$\\


Para combinar señales, se utiliza la función \texttt{lift2}
que recibe dos señales y produce una nueva aplicando una
función.\\

$lift2 :: (a \rightarrow b \rightarrow c) \rightarrow Signal\ a \rightarrow Signal\ b \rightarrow Signal\ c$\\

Utilizando \texttt{lift2} se pueden definir funciones \texttt{liftN}
combinándola suscesivas veces, por ejemplo:\\
\\
$lift3 :: (a \rightarrow b \rightarrow c \rightarrow d) \rightarrow Signal\ a \rightarrow Signal\ b \rightarrow Signal\ c \rightarrow Signal\ d$\\
$lift3\ f\ sa\ sb\ sc = lift2\ ((lift2\ f\ sa\ sb)\ sc)$\\

Para crear señales que no solo dependen de otra señal, sinó que dependen
de ella y además de su historia, se define otro combinador \texttt{foldE}
que cuando recibe los valores de la señal, los combina y acumula. Éste
combinador es análogo a la operación \texttt{fold} sobre listas.\\

$foldE :: (a \rightarrow b \rightarrow b) \rightarrow b \rightarrow Signal\ a \rightarrow Signal\ b$\\

\subsection{Ejemplo}

En el siguiente ejemplo se muestra como haría para detener un
robot cuando su sensor de distancia muestra un valor menor a un mínimo.

\begin{verbatim}
INPUT_DISTANCE = 1
OUTPUT_MOTOR = 1

MIN_DISTANCE = 30
FULL_SPEED = 100
STOP = 0

distanceToSpeed n = if (n < MIN_DISTANCE) then STOP else FULL_SPEED

main :: IO()
main = let distance = read INPUT_DISTANCE in
   output OUTPUT_MOTOR (lift distanceToSpeed distance)

\end{verbatim}

Primero se definió una fuente de eventos llamada \emph{distance},
de tipo \emph{Event Number}.

\begin{verbatim}
let distance = read INPUT_DISTANCE
\end{verbatim}

La misma emitirá un evento con la distancia en \emph{cm} leída
por un sensor en el robot.

  Luego, se quiere que cuando la distancia sea menor al valor
\emph{MINIMO} dado, el robot se detenga completamente, ésto
quiere decir, que la velocidad sea $0$, en otro caso el mismo
se mueve a velocidad $100$, la cuál asumimos es una velocidad
apropiada.
  Para ésto se crea una nueva fuente de eventos, definida a partir
de \emph{distance}, aplicandole la función \texttt{distanceToSpeed} 
a cada valor para obtener la velocidad.

\begin{verbatim}
(lift distanceToSpeed distance)
\end{verbatim}

  Ésta expresión, también es una fuente de eventos
de tipo \emph{Event Number}.

  Finalmente, se aplica la función nativa \texttt{output} cuyo
primer parámetro es el $id$ de la salida, en éste caso es \texttt{OUTPUT\_MOTOR}
y su segundo parámetro es una fuente de eventos,
en éste caso son velocidades.


\section{Lenguaje de bajo nivel}

 Para presentar el lenguaje, primero defino las estructuras
necesarias para explicar la semántica de cada instrucción.

\begin{enumerate}

\item \emph{Inputs}

  Los valores leídos en las entradas de hardware se mapean
en esta lista. Por ejemplo si el hardware cuenta con un botón,
y el identificador del botón es $i$,
su valor se representará con la notación:

  $Inputs_i$

  A cada entrada se le asocia un conjunto de
rutinas que deben invocarse cuando se tenga un
valor disponible en la entrada. El mismo puede ser vacío si
no hay rutinas esperando por su valor. Queda a criterio de quien
implementa la máquina si éstos valores deben ser guardados o
descartados.
  A éste conjunto de rutinas lo denotamos cómo:

  $Callbacks_i$

\item \emph{Nodes}

  Es utilizado para almacenar todas las transformaciones.
  Cada aplicación de \texttt{lift} o \texttt{lift2} será mapeada en un nodo.
  Cada nodo $Node_i$ tiene una lista de nodos adyacentes
que dependen de él.

\item \emph{Outputs}

  Mapea valores en salidas de hardware, los valores
  son asignados con la operación \texttt{output}.

\item \emph{Stack}

Es una pila global, se utiliza para ejecutar operaciones,
realizar cálculos, es único
y global, y los hilos de ejecución no pueden guardar valores
persistentes en él.

Usaremos el símbolo $TOS$ para referirnos al elemento en el tope
de la pila y $Stack$ para referirnos a la pila.

\item \emph{Ready}

Es una \emph{cola} que contiene punteros a hilos de ejecución
listos para ser ejecutados.


\item Dispatcher

El dispatcher, es quien implementa las acciones de la máquina.
El mismo se encarga de recibir valores de los sensores, mapearlos
a eventos en las entradas $Input_i$.
Éstos eventos, serán recibidos por los nodos $Nodes$, cada $Node_i$
que espera por eventos, entrará en estado activo cuando todos los nodos
por los que espera le envíen un evento.
A su vez, el nodo en estado activo calcula un resultado y notifica a
todos sus nodos adyacentes.

Como $Nodes$ es un grafo acíclico, éste proceso termina, y cada
salida cuenta con un valor, que será mapeado a los actuadores.

\end{enumerate}

\subsection{Instrucciones}

Las siguiente tabla muestra las instrucciones de bajo nivel junto con su semántica.

\begin{itemize}
\item \texttt{lift id source\_id function\_pointer}

 Crea un nodo que recibe valores de la fuente de
 eventos $source_id$,
 les aplica la función $function_pointer$ y emite el resultado
 en la fuente de eventos $id$.

\item \texttt{lift2 id source-id\_1 source-id\_2 function\_pointer}

 Crea un nodo que recibe valores de $source-id_1$ y
 $source-id_2$,
 les aplica la función $function_pointer$ y emite el resultado
 en la fuente de eventos $id$.

\item \texttt{read id input-id}

 Crea un nodo que recibe valores de una entrada,
 y emite el resultado en la fuente de eventos $id$.

\item \texttt{halt}

  Detiene el hilo de ejecución actual.

  \texttt{ip = 0} 

\item \texttt{call function}

  Invoca la funcion $function$.

  \texttt{stack.push(fp)}

  \texttt{stack.push(ip)}

  \texttt{fp = sp}

  \texttt{goto function}

\item \texttt{ret}

  Elimina el frame y coloca el resultado en el stack.

  \texttt{value = stack.pop()}

  \texttt{stack.pop\_frame();}

  \texttt{ip = code[stack.pop()]}

  \texttt{fp = stack.pop()}

  \texttt{stack.pop\_args()}

  \texttt{stack.push(value)}

\item \texttt{load\_param}

  \texttt{a = stack.get\_arg(inm)}

  \texttt{stack.push(a)}

\item \texttt{jump}

  \texttt{goto position}

\item \texttt{jump\_false position}

  \texttt{a = stack.pop()}

  \texttt{if not a: goto position}

\item \texttt{cmp\_eq}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a == b)}

\item \texttt{cmp\_neq}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a != b)}

\item \texttt{cmp\_gt}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a > b)}

\item \texttt{cmp\_lt}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a < b)}

\item \texttt{add}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a + b)}

\item \texttt{sub}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a - b)}

\item \texttt{div}
  
  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a / b)}

\item \texttt{mul}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a * b)}

\item \texttt{op\_and}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a and b)}

\item \texttt{op\_or}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a or b)}

\item \texttt{op\_not}

  Coloca un valor constante en el stack.

  \texttt{stack.push(word)}

\item \texttt{push word}

  Coloca un valor constante en el stack.

  \texttt{stack.push(word)}

\item \texttt{pop}

  Elimina el tope del stack.

  \texttt{stack.pop()}

\item \texttt{dup}

  Duplica el tope del stack.

  \texttt{stask.push(stack.tos())}

\item \texttt{store inm}

  Guarda el tope del stack en la variable $inm$.

  \texttt{var[inm] = stack.pop()}

\item \texttt{load inm}

  Carga la variable $inm \in {0..255}$ en el stack.

  \texttt{stack.push(var[inm])}

\item \texttt{write inm}

  Toma el último valor del stack y lo coloca en la 
  salida número $inm \in {0..255}$.

  \texttt{output(inm, stack.pop())}

\end{itemize}
