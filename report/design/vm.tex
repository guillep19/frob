
  La máquina que interpreta el lenguaje \alf{} es una
\textit{máquina de stack}.\footnote{Stack machine en inglés}.

  En una máquina de stack las instrucciones están en notación
postfija.\footnote{RPN (\textit{Reverse polish notation}) del inglés}
  Para evaluar expresiones se colocan sus argumentos en una pila, y luego
se ejecuta la operación asociada.
  
  Por ejemplo la expresión ``$5 + 19 * 8$'' en RPN se
escribe ``$5\ 19\ 8 * +$''.
  
  A modo de ejemplo en \alf{} se representa con las
  siguientes 5 instrucciones.

  \begin{Verbatim}[frame=single]
  push 5
  push 19
  push 8
  mul
  add
  \end{Verbatim}

  El conjunto \textit{Inputs} representa las entradas de la máquina.
  Dadas $m$ entradas fijas, cada una se identifica con un entero único
  entre $1$ y $m = | \textit{Inputs} |$.

  Cada $\texttt{I}_i, i \in (1 \dotsb m)$ se corresponderá con un sensor
  definido en el robot.

\begin{definicion}
  \textit{Entradas de la máquina}\\
  \begin{center}
    $\textit{Inputs} \equiv \{\texttt{I}_1 \dotsb \texttt{I}_m\}$.
  \end{center}
\end{definicion}
  
  Graficamente las representaré con la notación:

  \input{design/ll_diagram_input.tex}

  También se cuenta con un conjunto \textit{Outputs} de salidas,
  identificadas de $1$ a $k = | \textit{Outputs} |$.
  
  Cada $\texttt{O}_i, i \in (1 \dotsb k)$ se corresponderá con un actuador
  del robot.

\begin{definicion}
  \textit{Salidas de la máquina}\\
  \begin{center}
    $\textit{Outputs} \equiv \{\texttt{O}_1 \dotsb \texttt{I}_k\}$.
  \end{center}
\end{definicion}
  
  Graficamente las representaré con la notación:

  \input{design/ll_diagram_output.tex}

  Las señales que se definan se denotarán $\texttt{S}_i$, siendo $i$ un
  índice único que las identifica. El conjunto de las señales se llama
  \textit{Signals}.

\begin{definicion}
  \textit{Señales}
  \begin{center}
    $\textit{Signals} \equiv \{\texttt{S}_1 \dotsb \texttt{S}_s\}$.
  \end{center}
\end{definicion}

  Graficamente las representaré con la notación:

  \input{design/ll_diagram_signal.tex}

  La máquina tendrá una pila global, denotada \textit{Stack}. El mismo
  se representa con una secuencia de valores.

\begin{definicion}
  \textit{Pila global}
  \begin{center}
    $\textit{Stack} \equiv s_1, \dotsb, s_n$.
  \end{center}
\end{definicion}

  El \textit{Stack} lo representaré graficamente con la notación:

  \input{design/ll_diagram_stack.tex}

  Donde \texttt{TOS}\footnote{Del inglés: Top
  of stack} indica el índice del tope del mismo.
  Se cumple que $\textit{Stack}_{TOS} = s_n$.



%% TODO: Esto es parte de la implementacion.
%%  A diferencia del compilador, es necesario implementar una máquina virtual
%%para cada arquitectura objetivo.\\
%%
%%  Por ejemplo, para ejecutar programas en un robot
%%  con un procesador \emph{arduino}, debe
%%  existir una implementación de la máquina para ese modelo
%%  de \emph{arduino}.
%%
%%  Al momento de implementar la máquina, se tomará en cuenta ésto para
%%  factorizar partes en común y sólo implementar por arquitectura, las
%%  partes que realmente sean diferentes como ser la comunicación con
%%  los periféricos de entrada/salida y las llamadas al sistema.

  El dispatcher, es quien implementa las acciones de la máquina.
  El mismo se encarga de recibir valores de los sensores y mapearlos
  a eventos en las entradas $\texttt{I}_i$.

  Éstos eventos, serán recibidos por los nodos $Nodes$.
  Cada $Node_i$ que espera por eventos entrará en estado activo cuando
todos los nodos por los que espera le envíen un evento.
  A su vez, el nodo en estado activo calcula un resultado y notifica a
todos sus nodos adyacentes.

  TODO: Forzar que Nodes sea un grafo acíclico en la descripción.

  El dispatcher, realizará implicitamente un orden topológico de los
nodos, como $Nodes$ es un grafo acíclico, éste proceso es posible y
termina, y cada salida cuenta con un valor, que será mapeado a los actuadores.

