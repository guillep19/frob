  Al compilar un programa \frob{}, se obtiene como salida un código
intermedio llamado lenguaje \alf{}.
  El mismo es independiente de la plataforma en la que va a ser ejecutado.
  Para lograr ésto, se define el lenguaje como un conjunto de instrucciones
con su semántica y una máquina abstracta que las ejecuta.

  TODO: Modificar toda esta sección, parece más una descripción de la máquina
virtual que del lenguaje.

\subsection{Instrucciones}

  Utilizaré la siguiente notación para describir las instrucciones:

  $\texttt{codigo}\ \textit{inmediato}\ [{arg}_1 \dotsb {arg}_n]$
 
  TODO: Ver si ésto debería ir aca o en implementación:

  Las instrucciones van a tener la siguiente representación en memoria:

  \begin{center}
      \begin{tabular}{|c|c|}
      \hline
      codigo de 8 bit & \cellcolor{gray!25}inmediato de 8 bit \\
      \hline
      \multicolumn{2}{|c|}{argumento $1$ opcional de 16 bit} \\
      \hline
      \multicolumn{2}{|c|}{...} \\
      \hline
      \multicolumn{2}{|c|}{argumento $n$ opcional de 16 bit} \\
      \hline
      \end{tabular}
  \end{center}

\begin{itemize}

\item \texttt{read id}

  Toma el tope del stack (\texttt{TOS}) como identificador de una entrada.
  Crea una señal \texttt{id} que contendrá el valor de la entrada asociada.
  Como precondición, la señal \texttt{id} no debe existir.

\begin{tikzpicture}
\selectlanguage{english}
 \begin{scope}[xshift=0cm,yshift=-5cm,very thick,
    node distance=2cm,on grid,>=stealth',
    block/.style={rectangle,draw,fill=cyan!20},
    comp/.style={circle,draw,fill=orange!40}]
   \node [comp]  (ca2)      {$\textit{S}_{id}$};
   \node [block] (s2) [above=of ca2]   {$\textit{Input}_{TOS}$} edge [->] (ca2);
   \end{scope} 
\selectlanguage{spanish}
\end{tikzpicture}


\item \texttt{lift id src f}

 Crea una señal \texttt{id} aplicando la función \texttt{f}
a la señal \texttt{src}.

\begin{tikzpicture}
\selectlanguage{english}
 \begin{scope}[xshift=0cm,yshift=-5cm,very thick,
    node distance=2cm,on grid,>=stealth',
    block/.style={rectangle,draw,fill=cyan!20},
    func/.style={rectangle,draw,fill=green!20},
    comp/.style={circle,draw,fill=orange!40}]
   \node [func]  (f1) [xshift=1.3cm]     {f} ;
   \node [comp]  (cb)  []   {$S_{id}$} edge [-] (f1);
   \node [comp]  (ca1)  [above=of cb] {$S_{src}$} edge [->] (cb);
   \end{scope} 
\selectlanguage{spanish}
\end{tikzpicture}




\item \texttt{lift2 id src\_1 src\_2 f}

  Crea una señal \texttt{id} aplicando el combinador \texttt{lift2} usando
la función \texttt{f}, y las señales \texttt{src\_1} y \texttt{src\_2}.

\begin{tikzpicture}
\selectlanguage{english}
  \begin{scope}[xshift=0cm,yshift=-4cm,very thick,
    node distance=2cm,on grid,>=stealth',
    block/.style={rectangle,draw,fill=cyan!20},
    func/.style={rectangle,draw,fill=green!20},
    comp/.style={circle,draw,fill=orange!40}]
   \node [comp] (ca1) [xshift=-1cm] {$S_{src_1}$};
   \node [comp]  (ca2) [right=of ca1] {$S_{src_2}$};
   \end{scope}
  \draw [dashed] (4.5,-3) -- (4.5,-5.5);
 \begin{scope}[xshift=8cm,yshift=-5cm,very thick,
    node distance=2cm,on grid,>=stealth',
    block/.style={rectangle,draw,fill=cyan!20},
    func/.style={rectangle,draw,fill=green!20},
    comp/.style={circle,draw,fill=orange!40}]
   \node [func] (f1) [xshift=1.3cm] {f};
   \node [comp] (cb) {$S_{id}$} edge [-] (f1);
   \node [comp] (ca1) [above=of cb,xshift=-1cm] {$S_{src_1}$} edge [->] (cb);
   \node [comp]  (ca2) [right=of ca1] {$S_{src_2}$} edge [->] (cb);
   \end{scope} 
\selectlanguage{spanish}
\end{tikzpicture}



\item \texttt{write index id}

  Crea un nodo $Output$ que recibe valores de la señal \texttt{id}
y los emite en la salida número \texttt{index}.
  El nodo guarda dicho valor y el dispatcher decide en que momento
debe escribirlo en la salida asociada.
  Se intentará que sea lo más instantáneo posible
ya que el valor depende del tiempo y a mayor demora, menos correcto
será el comportamiento.

\begin{tikzpicture}
\selectlanguage{english}
 \begin{scope}[xshift=0cm,yshift=-5cm,very thick,
    node distance=2cm,on grid,>=stealth',
    block/.style={rectangle,draw,fill=cyan!20},
    comp/.style={circle,draw,fill=orange!40}]
   \node [block] (re)         {Receiver};
   \node [comp]  (cb) [above=of re]     {B}  edge [->] (re);
   \node [comp]  (ca1)  [above=of cb,xshift=-1cm] {A1} edge [->] (cb);
   \node [comp]  (ca2)  [right=of ca1]      {A2} edge [->] (cb);
   \node [block] (s1) [above=of ca1]    {Source1} edge [->] (ca1);
   \node [block] (s2) [right=of s1]   {Source2} edge [->] (ca2);
   \end{scope} 
\selectlanguage{spanish}
\end{tikzpicture}




\end{itemize}

TODO: Comentario de Marcos: Sólo ésto? Describir más instrucciones.
Mostrar que es una máquina de stack. Mostrar ejemplos. 
Hacer referencia al apéndice A.2.


\pagebreak

