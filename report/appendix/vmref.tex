

\subsection{Instrucciones de bajo nivel}

  A continuación se presenta el resto de las instrucciones
de bajo nivel y pseudocódigo indicando su semántica.

\begin{itemize}

\item \texttt{halt}

  Detiene el hilo de ejecución actual.

  \texttt{ip = 0} 

\item \texttt{call function}

  Invoca la funcion $function$.
  Se asume que los parámetros están en el stack.

\item \texttt{ret}

  Toma el resultado de una función del tope del stack,
  limpia el espacio ocupado por la función,
  y deja el resultado en el nuevo tope del stack.

  \texttt{value = stack.pop()}

  \texttt{stack.pop\_frame();}

  \texttt{ip = code[stack.pop()]}

  \texttt{fp = stack.pop()}

  \texttt{stack.pop\_args()}

  \texttt{stack.push(value)}

\item \texttt{load\_param inm}

  \texttt{a = stack.get\_arg(inm)}

  \texttt{stack.push(a)}

\item \texttt{jump}

  \texttt{goto position}

\item \texttt{jump\_false position}

  \texttt{a = stack.pop()}

  \texttt{if not a: goto position}

\item \texttt{cmp\_eq}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a == b)}

\item \texttt{cmp\_neq}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a != b)}

\item \texttt{cmp\_gt}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a > b)}

\item \texttt{cmp\_lt}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a < b)}

\item \texttt{add}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a + b)}

\item \texttt{sub}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a - b)}

\item \texttt{div}
  
  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a / b)}

\item \texttt{mul}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a * b)}

\item \texttt{op\_and}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a and b)}

\item \texttt{op\_or}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a or b)}

\item \texttt{op\_not}

  Coloca un valor constante en el stack.

  \texttt{stack.push(word)}

\item \texttt{push word}

  Coloca un valor constante en el stack.

  \texttt{stack.push(word)}

\item \texttt{pop}

  Elimina el tope del stack.

  \texttt{stack.pop()}

\item \texttt{dup}

  Duplica el tope del stack.

  \texttt{stask.push(stack.tos())}

\item \texttt{store inm}

  Guarda el tope del stack en la variable $inm$.

  \texttt{var[inm] = stack.pop()}

\item \texttt{load inm}

  Carga la variable $inm \in {0..255}$ en el stack.

  \texttt{stack.push(var[inm])}

\end{itemize}

