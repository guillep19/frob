
\section{Gramática del lenguaje de alto nivel}

\subsection{Sintaxis}

La gramática del lenguaje es la siguiente:

\begin{verbatim}

number := [-+]?[0-9]*\.?[0-9]+

name := [a-z_A-Z]+

value := number | name

binop := '+' | '-' | '/' | '*'
       | 'or' | 'and' | '==' | '<='
       | '>' | '<' | '<>' | '>=';

arg_list := name arg_list | name;

expr := value
      | expr binop expr
      | "if" expr "then" expr "else" expr;

assign := name "<- read" name
        | name "<- lift" name name
        | name "<- lift2" name name name
        | name "<- folds" value name
        | "output" name name

assign_list = assign assign_list | assign;

definitions := name arg_list "=" expr;

main_block := "do {" assign_list "}";

program := definitions main_block;

\end{verbatim}



\subsection{Instrucciones de bajo nivel}

  A continuación se presenta el resto de las instrucciones
de bajo nivel y pseudocódigo indicando su semántica.

\begin{itemize}

\item \texttt{halt}

  Detiene el hilo de ejecución actual.

  \texttt{ip = 0} 

\item \texttt{call function}

  Invoca la funcion $function$.
  Se asume que los parámetros están en el stack.

\item \texttt{ret}

  Toma el resultado de una función del tope del stack,
  limpia el espacio ocupado por la función,
  y deja el resultado en el nuevo tope del stack.

  \texttt{value = stack.pop()}

  \texttt{stack.pop\_frame();}

  \texttt{ip = code[stack.pop()]}

  \texttt{fp = stack.pop()}

  \texttt{stack.pop\_args()}

  \texttt{stack.push(value)}

\item \texttt{load\_param inm}

  \texttt{a = stack.get\_arg(inm)}

  \texttt{stack.push(a)}

\item \texttt{jump}

  \texttt{goto position}

\item \texttt{jump\_false position}

  \texttt{a = stack.pop()}

  \texttt{if not a: goto position}

\item \texttt{cmp\_eq}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a == b)}

\item \texttt{cmp\_neq}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a != b)}

\item \texttt{cmp\_gt}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a > b)}

\item \texttt{cmp\_lt}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a < b)}

\item \texttt{add}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a + b)}

\item \texttt{sub}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a - b)}

\item \texttt{div}
  
  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a / b)}

\item \texttt{mul}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a * b)}

\item \texttt{op\_and}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a and b)}

\item \texttt{op\_or}

  \texttt{a = stack.pop()}

  \texttt{b = stack.pop()}

  \texttt{stack.push(a or b)}

\item \texttt{op\_not}

  Coloca un valor constante en el stack.

  \texttt{stack.push(word)}

\item \texttt{push word}

  Coloca un valor constante en el stack.

  \texttt{stack.push(word)}

\item \texttt{pop}

  Elimina el tope del stack.

  \texttt{stack.pop()}

\item \texttt{dup}

  Duplica el tope del stack.

  \texttt{stask.push(stack.tos())}

\item \texttt{store inm}

  Guarda el tope del stack en la variable $inm$.

  \texttt{var[inm] = stack.pop()}

\item \texttt{load inm}

  Carga la variable $inm \in {0..255}$ en el stack.

  \texttt{stack.push(var[inm])}

\end{itemize}

